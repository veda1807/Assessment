{"ast":null,"code":"import { EditorSelection } from '@codemirror/state';\nimport { EditorView } from '@codemirror/view';\nimport { findColumn, countColumn } from '@codemirror/text'; // Don't compute precise column positions for line offsets above this\n// (since it could get expensive). Assume offset==column for them.\n\nconst MaxOff = 2000;\n\nfunction rectangleFor(state, a, b) {\n  let startLine = Math.min(a.line, b.line),\n      endLine = Math.max(a.line, b.line);\n  let ranges = [];\n\n  if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {\n    let startOff = Math.min(a.off, b.off),\n        endOff = Math.max(a.off, b.off);\n\n    for (let i = startLine; i <= endLine; i++) {\n      let line = state.doc.line(i);\n      if (line.length <= endOff) ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));\n    }\n  } else {\n    let startCol = Math.min(a.col, b.col),\n        endCol = Math.max(a.col, b.col);\n\n    for (let i = startLine; i <= endLine; i++) {\n      let line = state.doc.line(i),\n          str = line.length > MaxOff ? line.text.slice(0, 2 * endCol) : line.text;\n      let start = findColumn(str, 0, startCol, state.tabSize),\n          end = findColumn(str, 0, endCol, state.tabSize);\n      if (!start.leftOver) ranges.push(EditorSelection.range(line.from + start.offset, line.from + end.offset));\n    }\n  }\n\n  return ranges;\n}\n\nfunction absoluteColumn(view, x) {\n  let ref = view.coordsAtPos(view.viewport.from);\n  return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;\n}\n\nfunction getPos(view, event) {\n  let offset = view.posAtCoords({\n    x: event.clientX,\n    y: event.clientY\n  });\n  if (offset == null) return null;\n  let line = view.state.doc.lineAt(offset),\n      off = offset - line.from;\n  let col = off > MaxOff ? -1 : off == line.length ? absoluteColumn(view, event.clientX) : countColumn(line.text.slice(0, offset - line.from), 0, view.state.tabSize);\n  return {\n    line: line.number,\n    col,\n    off\n  };\n}\n\nfunction rectangleSelectionStyle(view, event) {\n  let start = getPos(view, event),\n      startSel = view.state.selection;\n  if (!start) return null;\n  return {\n    update(update) {\n      if (update.docChanged) {\n        let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);\n        let newLine = update.state.doc.lineAt(newStart);\n        start = {\n          line: newLine.number,\n          col: start.col,\n          off: Math.min(start.off, newLine.length)\n        };\n        startSel = startSel.map(update.changes);\n      }\n    },\n\n    get(event, _extend, multiple) {\n      let cur = getPos(view, event);\n      if (!cur) return startSel;\n      let ranges = rectangleFor(view.state, start, cur);\n      if (!ranges.length) return startSel;\n      if (multiple) return EditorSelection.create(ranges.concat(startSel.ranges));else return EditorSelection.create(ranges);\n    }\n\n  };\n} /// Create an extension that enables rectangular selections. By\n/// default, it will react to left mouse drag with the Alt key held\n/// down. When such a selection occurs, the text within the rectangle\n/// that was dragged over will be selected, as one selection\n/// [range](#state.SelectionRange) per line.\n\n\nfunction rectangularSelection(options) {\n  let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || (e => e.altKey && e.button == 0);\n\n  return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);\n}\n\nexport { rectangularSelection };","map":{"version":3,"sources":["D:/MSIT/Practicum - iLMS/editor-codemirror6/node_modules/@codemirror/rectangular-selection/dist/index.js"],"names":["EditorSelection","EditorView","findColumn","countColumn","MaxOff","rectangleFor","state","a","b","startLine","Math","min","line","endLine","max","ranges","off","col","startOff","endOff","i","doc","length","push","range","from","to","startCol","endCol","str","text","slice","start","tabSize","end","leftOver","offset","absoluteColumn","view","x","ref","coordsAtPos","viewport","round","abs","left","defaultCharacterWidth","getPos","event","posAtCoords","clientX","y","clientY","lineAt","number","rectangleSelectionStyle","startSel","selection","update","docChanged","newStart","changes","mapPos","startState","newLine","map","get","_extend","multiple","cur","create","concat","rectangularSelection","options","filter","eventFilter","e","altKey","button","mouseSelectionStyle","of"],"mappings":"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","sourcesContent":["import { EditorSelection } from '@codemirror/state';\nimport { EditorView } from '@codemirror/view';\nimport { findColumn, countColumn } from '@codemirror/text';\n\n// Don't compute precise column positions for line offsets above this\n// (since it could get expensive). Assume offset==column for them.\nconst MaxOff = 2000;\nfunction rectangleFor(state, a, b) {\n    let startLine = Math.min(a.line, b.line), endLine = Math.max(a.line, b.line);\n    let ranges = [];\n    if (a.off > MaxOff || b.off > MaxOff || a.col < 0 || b.col < 0) {\n        let startOff = Math.min(a.off, b.off), endOff = Math.max(a.off, b.off);\n        for (let i = startLine; i <= endLine; i++) {\n            let line = state.doc.line(i);\n            if (line.length <= endOff)\n                ranges.push(EditorSelection.range(line.from + startOff, line.to + endOff));\n        }\n    }\n    else {\n        let startCol = Math.min(a.col, b.col), endCol = Math.max(a.col, b.col);\n        for (let i = startLine; i <= endLine; i++) {\n            let line = state.doc.line(i), str = line.length > MaxOff ? line.text.slice(0, 2 * endCol) : line.text;\n            let start = findColumn(str, 0, startCol, state.tabSize), end = findColumn(str, 0, endCol, state.tabSize);\n            if (!start.leftOver)\n                ranges.push(EditorSelection.range(line.from + start.offset, line.from + end.offset));\n        }\n    }\n    return ranges;\n}\nfunction absoluteColumn(view, x) {\n    let ref = view.coordsAtPos(view.viewport.from);\n    return ref ? Math.round(Math.abs((ref.left - x) / view.defaultCharacterWidth)) : -1;\n}\nfunction getPos(view, event) {\n    let offset = view.posAtCoords({ x: event.clientX, y: event.clientY });\n    if (offset == null)\n        return null;\n    let line = view.state.doc.lineAt(offset), off = offset - line.from;\n    let col = off > MaxOff ? -1\n        : off == line.length ? absoluteColumn(view, event.clientX)\n            : countColumn(line.text.slice(0, offset - line.from), 0, view.state.tabSize);\n    return { line: line.number, col, off };\n}\nfunction rectangleSelectionStyle(view, event) {\n    let start = getPos(view, event), startSel = view.state.selection;\n    if (!start)\n        return null;\n    return {\n        update(update) {\n            if (update.docChanged) {\n                let newStart = update.changes.mapPos(update.startState.doc.line(start.line).from);\n                let newLine = update.state.doc.lineAt(newStart);\n                start = { line: newLine.number, col: start.col, off: Math.min(start.off, newLine.length) };\n                startSel = startSel.map(update.changes);\n            }\n        },\n        get(event, _extend, multiple) {\n            let cur = getPos(view, event);\n            if (!cur)\n                return startSel;\n            let ranges = rectangleFor(view.state, start, cur);\n            if (!ranges.length)\n                return startSel;\n            if (multiple)\n                return EditorSelection.create(ranges.concat(startSel.ranges));\n            else\n                return EditorSelection.create(ranges);\n        }\n    };\n}\n/// Create an extension that enables rectangular selections. By\n/// default, it will react to left mouse drag with the Alt key held\n/// down. When such a selection occurs, the text within the rectangle\n/// that was dragged over will be selected, as one selection\n/// [range](#state.SelectionRange) per line.\nfunction rectangularSelection(options) {\n    let filter = (options === null || options === void 0 ? void 0 : options.eventFilter) || (e => e.altKey && e.button == 0);\n    return EditorView.mouseSelectionStyle.of((view, event) => filter(event) ? rectangleSelectionStyle(view, event) : null);\n}\n\nexport { rectangularSelection };\n"]},"metadata":{},"sourceType":"module"}