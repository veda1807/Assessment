{"ast":null,"code":"import { EditorView, Decoration, ViewPlugin, runScopeHandlers } from '@codemirror/view';\nimport { StateEffect, StateField, EditorSelection, Facet, combineConfig, CharCategory, Prec } from '@codemirror/state';\nimport { showPanel, getPanel } from '@codemirror/panel';\nimport { RangeSetBuilder } from '@codemirror/rangeset';\nimport elt from 'crelt';\nimport { codePointAt, fromCodePoint, codePointSize } from '@codemirror/text';\nconst basicNormalize = typeof String.prototype.normalize == \"function\" ? x => x.normalize(\"NFKD\") : x => x;\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/\n\nclass SearchCursor {\n  /**\n  Create a text cursor. The query is the search string, `from` to\n  `to` provides the region to search.\n  \n  When `normalize` is given, it will be called, on both the query\n  string and the content it is matched against, before comparing.\n  You can, for example, create a case-insensitive search by\n  passing `s => s.toLowerCase()`.\n  \n  Text is always normalized with\n  [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n  (when supported).\n  */\n  constructor(text, query, from = 0, to = text.length, normalize) {\n    /**\n    The current match (only holds a meaningful value after\n    [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n    `done` is false).\n    */\n    this.value = {\n      from: 0,\n      to: 0\n    };\n    /**\n    Whether the end of the iterated region has been reached.\n    */\n\n    this.done = false;\n    this.matches = [];\n    this.buffer = \"\";\n    this.bufferPos = 0;\n    this.iter = text.iterRange(from, to);\n    this.bufferStart = from;\n    this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;\n    this.query = this.normalize(query);\n  }\n\n  peek() {\n    if (this.bufferPos == this.buffer.length) {\n      this.bufferStart += this.buffer.length;\n      this.iter.next();\n      if (this.iter.done) return -1;\n      this.bufferPos = 0;\n      this.buffer = this.iter.value;\n    }\n\n    return codePointAt(this.buffer, this.bufferPos);\n  }\n  /**\n  Look for the next match. Updates the iterator's\n  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n  at least once before using the cursor.\n  */\n\n\n  next() {\n    while (this.matches.length) this.matches.pop();\n\n    return this.nextOverlapping();\n  }\n  /**\n  The `next` method will ignore matches that partially overlap a\n  previous match. This method behaves like `next`, but includes\n  such matches.\n  */\n\n\n  nextOverlapping() {\n    for (;;) {\n      let next = this.peek();\n\n      if (next < 0) {\n        this.done = true;\n        return this;\n      }\n\n      let str = fromCodePoint(next),\n          start = this.bufferStart + this.bufferPos;\n      this.bufferPos += codePointSize(next);\n      let norm = this.normalize(str);\n\n      for (let i = 0, pos = start;; i++) {\n        let code = norm.charCodeAt(i);\n        let match = this.match(code, pos);\n\n        if (match) {\n          this.value = match;\n          return this;\n        }\n\n        if (i == norm.length - 1) break;\n        if (pos == start && i < str.length && str.charCodeAt(i) == code) pos++;\n      }\n    }\n  }\n\n  match(code, pos) {\n    let match = null;\n\n    for (let i = 0; i < this.matches.length; i += 2) {\n      let index = this.matches[i],\n          keep = false;\n\n      if (this.query.charCodeAt(index) == code) {\n        if (index == this.query.length - 1) {\n          match = {\n            from: this.matches[i + 1],\n            to: pos + 1\n          };\n        } else {\n          this.matches[i]++;\n          keep = true;\n        }\n      }\n\n      if (!keep) {\n        this.matches.splice(i, 2);\n        i -= 2;\n      }\n    }\n\n    if (this.query.charCodeAt(0) == code) {\n      if (this.query.length == 1) match = {\n        from: pos,\n        to: pos + 1\n      };else this.matches.push(1, pos);\n    }\n\n    return match;\n  }\n\n}\n\nconst empty = {\n  from: -1,\n  to: -1,\n  match: /*@__PURE__*/ /.*/.exec(\"\")\n};\nconst baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n/**\nThis class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)\nbut searches for a regular expression pattern instead of a plain\nstring.\n*/\n\nclass RegExpCursor {\n  /**\n  Create a cursor that will search the given range in the given\n  document. `query` should be the raw pattern (as you'd pass it to\n  `new RegExp`).\n  */\n  constructor(text, query, options, from = 0, to = text.length) {\n    this.to = to;\n    this.curLine = \"\";\n    /**\n    Set to `true` when the cursor has reached the end of the search\n    range.\n    */\n\n    this.done = false;\n    /**\n    Will contain an object with the extent of the match and the\n    match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)\n    sucessfully finds a match.\n    */\n\n    this.value = empty;\n    if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query)) return new MultilineRegExpCursor(text, query, options, from, to);\n    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n    this.iter = text.iter();\n    let startLine = text.lineAt(from);\n    this.curLineStart = startLine.from;\n    this.matchPos = from;\n    this.getLine(this.curLineStart);\n  }\n\n  getLine(skip) {\n    this.iter.next(skip);\n\n    if (this.iter.lineBreak) {\n      this.curLine = \"\";\n    } else {\n      this.curLine = this.iter.value;\n      if (this.curLineStart + this.curLine.length > this.to) this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n      this.iter.next();\n    }\n  }\n\n  nextLine() {\n    this.curLineStart = this.curLineStart + this.curLine.length + 1;\n    if (this.curLineStart > this.to) this.curLine = \"\";else this.getLine(0);\n  }\n  /**\n  Move to the next match, if there is one.\n  */\n\n\n  next() {\n    for (let off = this.matchPos - this.curLineStart;;) {\n      this.re.lastIndex = off;\n      let match = this.matchPos <= this.to && this.re.exec(this.curLine);\n\n      if (match) {\n        let from = this.curLineStart + match.index,\n            to = from + match[0].length;\n        this.matchPos = to + (from == to ? 1 : 0);\n        if (from == this.curLine.length) this.nextLine();\n\n        if (from < to || from > this.value.to) {\n          this.value = {\n            from,\n            to,\n            match\n          };\n          return this;\n        }\n\n        off = this.matchPos - this.curLineStart;\n      } else if (this.curLineStart + this.curLine.length < this.to) {\n        this.nextLine();\n        off = 0;\n      } else {\n        this.done = true;\n        return this;\n      }\n    }\n  }\n\n}\n\nconst flattened = /*@__PURE__*/new WeakMap(); // Reusable (partially) flattened document strings\n\nclass FlattenedDoc {\n  constructor(from, text) {\n    this.from = from;\n    this.text = text;\n  }\n\n  get to() {\n    return this.from + this.text.length;\n  }\n\n  static get(doc, from, to) {\n    let cached = flattened.get(doc);\n\n    if (!cached || cached.from >= to || cached.to <= from) {\n      let flat = new FlattenedDoc(from, doc.sliceString(from, to));\n      flattened.set(doc, flat);\n      return flat;\n    }\n\n    if (cached.from == from && cached.to == to) return cached;\n    let {\n      text,\n      from: cachedFrom\n    } = cached;\n\n    if (cachedFrom > from) {\n      text = doc.sliceString(from, cachedFrom) + text;\n      cachedFrom = from;\n    }\n\n    if (cached.to < to) text += doc.sliceString(cached.to, to);\n    flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n    return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n  }\n\n}\n\nclass MultilineRegExpCursor {\n  constructor(text, query, options, from, to) {\n    this.text = text;\n    this.to = to;\n    this.done = false;\n    this.value = empty;\n    this.matchPos = from;\n    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n    this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000\n    /* Base */\n    ));\n  }\n\n  chunkEnd(pos) {\n    return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n  }\n\n  next() {\n    for (;;) {\n      let off = this.re.lastIndex = this.matchPos - this.flat.from;\n      let match = this.re.exec(this.flat.text); // Skip empty matches directly after the last match\n\n      if (match && !match[0] && match.index == off) {\n        this.re.lastIndex = off + 1;\n        match = this.re.exec(this.flat.text);\n      } // If a match goes almost to the end of a noncomplete chunk, try\n      // again, since it'll likely be able to match more\n\n\n      if (match && this.flat.to < this.to && match.index + match[0].length > this.flat.text.length - 10) match = null;\n\n      if (match) {\n        let from = this.flat.from + match.index,\n            to = from + match[0].length;\n        this.value = {\n          from,\n          to,\n          match\n        };\n        this.matchPos = to + (from == to ? 1 : 0);\n        return this;\n      } else {\n        if (this.flat.to == this.to) {\n          this.done = true;\n          return this;\n        } // Grow the flattened doc\n\n\n        this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n      }\n    }\n  }\n\n}\n\nfunction validRegExp(source) {\n  try {\n    new RegExp(source, baseFlags);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\n\nfunction createLineDialog(view) {\n  let input = elt(\"input\", {\n    class: \"cm-textfield\",\n    name: \"line\"\n  });\n  let dom = elt(\"form\", {\n    class: \"cm-gotoLine\",\n    onkeydown: event => {\n      if (event.keyCode == 27) {\n        // Escape\n        event.preventDefault();\n        view.dispatch({\n          effects: dialogEffect.of(false)\n        });\n        view.focus();\n      } else if (event.keyCode == 13) {\n        // Enter\n        event.preventDefault();\n        go();\n      }\n    },\n    onsubmit: event => {\n      event.preventDefault();\n      go();\n    }\n  }, elt(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", elt(\"button\", {\n    class: \"cm-button\",\n    type: \"submit\"\n  }, view.state.phrase(\"go\")));\n\n  function go() {\n    let match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n    if (!match) return;\n    let {\n      state\n    } = view,\n        startLine = state.doc.lineAt(state.selection.main.head);\n    let [, sign, ln, cl, percent] = match;\n    let col = cl ? +cl.slice(1) : 0;\n    let line = ln ? +ln : startLine.number;\n\n    if (ln && percent) {\n      let pc = line / 100;\n      if (sign) pc = pc * (sign == \"-\" ? -1 : 1) + startLine.number / state.doc.lines;\n      line = Math.round(state.doc.lines * pc);\n    } else if (ln && sign) {\n      line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n    }\n\n    let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n    view.dispatch({\n      effects: dialogEffect.of(false),\n      selection: EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),\n      scrollIntoView: true\n    });\n    view.focus();\n  }\n\n  return {\n    dom,\n    pos: -10\n  };\n}\n\nconst dialogEffect = /*@__PURE__*/StateEffect.define();\nconst dialogField = /*@__PURE__*/StateField.define({\n  create() {\n    return true;\n  },\n\n  update(value, tr) {\n    for (let e of tr.effects) if (e.is(dialogEffect)) value = e.value;\n\n    return value;\n  },\n\n  provide: f => showPanel.from(f, val => val ? createLineDialog : null)\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n\nThe dialog can be styled with the `panel.gotoLine` theme\nselector.\n*/\n\nconst gotoLine = view => {\n  let panel = getPanel(view, createLineDialog);\n\n  if (!panel) {\n    let effects = [dialogEffect.of(true)];\n    if (view.state.field(dialogField, false) == null) effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));\n    view.dispatch({\n      effects\n    });\n    panel = getPanel(view, createLineDialog);\n  }\n\n  if (panel) panel.dom.querySelector(\"input\").focus();\n  return true;\n};\n\nconst baseTheme$1 = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-panel.cm-gotoLine\": {\n    padding: \"2px 6px 4px\",\n    \"& label\": {\n      fontSize: \"80%\"\n    }\n  }\n});\nconst defaultHighlightOptions = {\n  highlightWordAroundCursor: false,\n  minSelectionLength: 1,\n  maxMatches: 100\n};\nconst highlightConfig = /*@__PURE__*/Facet.define({\n  combine(options) {\n    return combineConfig(options, defaultHighlightOptions, {\n      highlightWordAroundCursor: (a, b) => a || b,\n      minSelectionLength: Math.min,\n      maxMatches: Math.min\n    });\n  }\n\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/\n\nfunction highlightSelectionMatches(options) {\n  let ext = [defaultTheme, matchHighlighter];\n  if (options) ext.push(highlightConfig.of(options));\n  return ext;\n}\n\nconst matchDeco = /*@__PURE__*/Decoration.mark({\n  class: \"cm-selectionMatch\"\n});\nconst mainMatchDeco = /*@__PURE__*/Decoration.mark({\n  class: \"cm-selectionMatch cm-selectionMatch-main\"\n});\nconst matchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.decorations = this.getDeco(view);\n  }\n\n  update(update) {\n    if (update.selectionSet || update.docChanged || update.viewportChanged) this.decorations = this.getDeco(update.view);\n  }\n\n  getDeco(view) {\n    let conf = view.state.facet(highlightConfig);\n    let {\n      state\n    } = view,\n        sel = state.selection;\n    if (sel.ranges.length > 1) return Decoration.none;\n    let range = sel.main,\n        query,\n        check = null;\n\n    if (range.empty) {\n      if (!conf.highlightWordAroundCursor) return Decoration.none;\n      let word = state.wordAt(range.head);\n      if (!word) return Decoration.none;\n      check = state.charCategorizer(range.head);\n      query = state.sliceDoc(word.from, word.to);\n    } else {\n      let len = range.to - range.from;\n      if (len < conf.minSelectionLength || len > 200) return Decoration.none;\n      query = state.sliceDoc(range.from, range.to).trim();\n      if (!query) return Decoration.none;\n    }\n\n    let deco = [];\n\n    for (let part of view.visibleRanges) {\n      let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n\n      while (!cursor.nextOverlapping().done) {\n        let {\n          from,\n          to\n        } = cursor.value;\n\n        if (!check || (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word)) {\n          if (check && from <= range.from && to >= range.to) deco.push(mainMatchDeco.range(from, to));else if (from >= range.to || to <= range.from) deco.push(matchDeco.range(from, to));\n          if (deco.length > conf.maxMatches) return Decoration.none;\n        }\n      }\n    }\n\n    return Decoration.set(deco);\n  }\n\n}, {\n  decorations: v => v.decorations\n});\nconst defaultTheme = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-selectionMatch\": {\n    backgroundColor: \"#99ff7780\"\n  },\n  \".cm-searchMatch .cm-selectionMatch\": {\n    backgroundColor: \"transparent\"\n  }\n}); // Select the words around the cursors.\n\nconst selectWord = ({\n  state,\n  dispatch\n}) => {\n  let {\n    selection\n  } = state;\n  let newSel = EditorSelection.create(selection.ranges.map(range => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection.mainIndex);\n  if (newSel.eq(selection)) return false;\n  dispatch(state.update({\n    selection: newSel\n  }));\n  return true;\n}; // Find next occurrence of query relative to last cursor. Wrap around\n// the document if there are no more matches.\n\n\nfunction findNextOccurrence(state, query) {\n  let {\n    ranges\n  } = state.selection;\n  let ahead = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to).next();\n  if (!ahead.done) return ahead.value;\n  let cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));\n\n  while (!cursor.next().done) {\n    if (!ranges.some(r => r.from === cursor.value.from)) return cursor.value;\n  }\n\n  return null;\n}\n/**\nSelect next occurrence of the current selection.\nExpand selection to the word when selection range is empty.\n*/\n\n\nconst selectNextOccurrence = ({\n  state,\n  dispatch\n}) => {\n  let {\n    ranges\n  } = state.selection;\n  if (ranges.some(sel => sel.from === sel.to)) return selectWord({\n    state,\n    dispatch\n  });\n  let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);\n  if (state.selection.ranges.some(r => state.sliceDoc(r.from, r.to) != searchedText)) return false;\n  let range = findNextOccurrence(state, searchedText);\n  if (!range) return false;\n  dispatch(state.update({\n    selection: state.selection.addRange(EditorSelection.range(range.from, range.to)),\n    scrollIntoView: true\n  }));\n  return true;\n};\n\nclass Query {\n  constructor(search, replace, caseInsensitive) {\n    this.search = search;\n    this.replace = replace;\n    this.caseInsensitive = caseInsensitive;\n  }\n\n  eq(other) {\n    return this.search == other.search && this.replace == other.replace && this.caseInsensitive == other.caseInsensitive && this.constructor == other.constructor;\n  }\n\n}\n\nclass StringQuery extends Query {\n  constructor(search, replace, caseInsensitive) {\n    super(search, replace, caseInsensitive);\n    this.unquoted = search.replace(/\\\\([nrt\\\\])/g, (_, ch) => ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\\t\" : \"\\\\\");\n  }\n\n  cursor(doc, from = 0, to = doc.length) {\n    return new SearchCursor(doc, this.unquoted, from, to, this.caseInsensitive ? x => x.toLowerCase() : undefined);\n  }\n\n  nextMatch(doc, curFrom, curTo) {\n    let cursor = this.cursor(doc, curTo).nextOverlapping();\n    if (cursor.done) cursor = this.cursor(doc, 0, curFrom).nextOverlapping();\n    return cursor.done ? null : cursor.value;\n  } // Searching in reverse is, rather than implementing inverted search\n  // cursor, done by scanning chunk after chunk forward.\n\n\n  prevMatchInRange(doc, from, to) {\n    for (let pos = to;;) {\n      let start = Math.max(from, pos - 10000\n      /* ChunkSize */\n      - this.unquoted.length);\n      let cursor = this.cursor(doc, start, pos),\n          range = null;\n\n      while (!cursor.nextOverlapping().done) range = cursor.value;\n\n      if (range) return range;\n      if (start == from) return null;\n      pos -= 10000\n      /* ChunkSize */\n      ;\n    }\n  }\n\n  prevMatch(doc, curFrom, curTo) {\n    return this.prevMatchInRange(doc, 0, curFrom) || this.prevMatchInRange(doc, curTo, doc.length);\n  }\n\n  getReplacement(_result) {\n    return this.replace;\n  }\n\n  matchAll(doc, limit) {\n    let cursor = this.cursor(doc),\n        ranges = [];\n\n    while (!cursor.next().done) {\n      if (ranges.length >= limit) return null;\n      ranges.push(cursor.value);\n    }\n\n    return ranges;\n  }\n\n  highlight(doc, from, to, add) {\n    let cursor = this.cursor(doc, Math.max(0, from - this.unquoted.length), Math.min(to + this.unquoted.length, doc.length));\n\n    while (!cursor.next().done) add(cursor.value.from, cursor.value.to);\n  }\n\n  get valid() {\n    return !!this.search;\n  }\n\n}\n\nclass RegExpQuery extends Query {\n  constructor(search, replace, caseInsensitive) {\n    super(search, replace, caseInsensitive);\n    this.valid = !!search && validRegExp(search);\n  }\n\n  cursor(doc, from = 0, to = doc.length) {\n    return new RegExpCursor(doc, this.search, this.caseInsensitive ? {\n      ignoreCase: true\n    } : undefined, from, to);\n  }\n\n  nextMatch(doc, curFrom, curTo) {\n    let cursor = this.cursor(doc, curTo).next();\n    if (cursor.done) cursor = this.cursor(doc, 0, curFrom).next();\n    return cursor.done ? null : cursor.value;\n  }\n\n  prevMatchInRange(doc, from, to) {\n    for (let size = 1;; size++) {\n      let start = Math.max(from, to - size * 10000\n      /* ChunkSize */\n      );\n      let cursor = this.cursor(doc, start, to),\n          range = null;\n\n      while (!cursor.next().done) range = cursor.value;\n\n      if (range && (start == from || range.from > start + 10)) return range;\n      if (start == from) return null;\n    }\n  }\n\n  prevMatch(doc, curFrom, curTo) {\n    return this.prevMatchInRange(doc, 0, curFrom) || this.prevMatchInRange(doc, curTo, doc.length);\n  }\n\n  getReplacement(result) {\n    return this.replace.replace(/\\$([$&\\d+])/g, (m, i) => i == \"$\" ? \"$\" : i == \"&\" ? result.match[0] : i != \"0\" && +i < result.match.length ? result.match[i] : m);\n  }\n\n  matchAll(doc, limit) {\n    let cursor = this.cursor(doc),\n        ranges = [];\n\n    while (!cursor.next().done) {\n      if (ranges.length >= limit) return null;\n      ranges.push(cursor.value);\n    }\n\n    return ranges;\n  }\n\n  highlight(doc, from, to, add) {\n    let cursor = this.cursor(doc, Math.max(0, from - 250\n    /* HighlightMargin */\n    ), Math.min(to + 250\n    /* HighlightMargin */\n    , doc.length));\n\n    while (!cursor.next().done) add(cursor.value.from, cursor.value.to);\n  }\n\n}\n\nconst setQuery = /*@__PURE__*/StateEffect.define();\nconst togglePanel = /*@__PURE__*/StateEffect.define();\nconst searchState = /*@__PURE__*/StateField.define({\n  create() {\n    return new SearchState(new StringQuery(\"\", \"\", false), createSearchPanel);\n  },\n\n  update(value, tr) {\n    for (let effect of tr.effects) {\n      if (effect.is(setQuery)) value = new SearchState(effect.value, value.panel);else if (effect.is(togglePanel)) value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n    }\n\n    return value;\n  },\n\n  provide: f => showPanel.from(f, val => val.panel)\n});\n\nclass SearchState {\n  constructor(query, panel) {\n    this.query = query;\n    this.panel = panel;\n  }\n\n}\n\nconst matchMark = /*@__PURE__*/Decoration.mark({\n  class: \"cm-searchMatch\"\n}),\n      selectedMatchMark = /*@__PURE__*/Decoration.mark({\n  class: \"cm-searchMatch cm-searchMatch-selected\"\n});\nconst searchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.view = view;\n    this.decorations = this.highlight(view.state.field(searchState));\n  }\n\n  update(update) {\n    let state = update.state.field(searchState);\n    if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet) this.decorations = this.highlight(state);\n  }\n\n  highlight({\n    query,\n    panel\n  }) {\n    if (!panel || !query.valid) return Decoration.none;\n    let {\n      view\n    } = this;\n    let builder = new RangeSetBuilder();\n\n    for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n      let {\n        from,\n        to\n      } = ranges[i];\n\n      while (i < l - 1 && to > ranges[i + 1].from - 2 * 250\n      /* HighlightMargin */\n      ) to = ranges[++i].to;\n\n      query.highlight(view.state.doc, from, to, (from, to) => {\n        let selected = view.state.selection.ranges.some(r => r.from == from && r.to == to);\n        builder.add(from, to, selected ? selectedMatchMark : matchMark);\n      });\n    }\n\n    return builder.finish();\n  }\n\n}, {\n  decorations: v => v.decorations\n});\n\nfunction searchCommand(f) {\n  return view => {\n    let state = view.state.field(searchState, false);\n    return state && state.query.valid ? f(view, state) : openSearchPanel(view);\n  };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/\n\n\nconst findNext = /*@__PURE__*/searchCommand((view, {\n  query\n}) => {\n  let {\n    from,\n    to\n  } = view.state.selection.main;\n  let next = query.nextMatch(view.state.doc, from, to);\n  if (!next || next.from == from && next.to == to) return false;\n  view.dispatch({\n    selection: {\n      anchor: next.from,\n      head: next.to\n    },\n    scrollIntoView: true,\n    effects: announceMatch(view, next)\n  });\n  return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/\n\nconst findPrevious = /*@__PURE__*/searchCommand((view, {\n  query\n}) => {\n  let {\n    state\n  } = view,\n      {\n    from,\n    to\n  } = state.selection.main;\n  let range = query.prevMatch(state.doc, from, to);\n  if (!range) return false;\n  view.dispatch({\n    selection: {\n      anchor: range.from,\n      head: range.to\n    },\n    scrollIntoView: true,\n    effects: announceMatch(view, range)\n  });\n  return true;\n});\n/**\nSelect all instances of the search query.\n*/\n\nconst selectMatches = /*@__PURE__*/searchCommand((view, {\n  query\n}) => {\n  let ranges = query.matchAll(view.state.doc, 1000);\n  if (!ranges || !ranges.length) return false;\n  view.dispatch({\n    selection: EditorSelection.create(ranges.map(r => EditorSelection.range(r.from, r.to)))\n  });\n  return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/\n\nconst selectSelectionMatches = ({\n  state,\n  dispatch\n}) => {\n  let sel = state.selection;\n  if (sel.ranges.length > 1 || sel.main.empty) return false;\n  let {\n    from,\n    to\n  } = sel.main;\n  let ranges = [],\n      main = 0;\n\n  for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {\n    if (ranges.length > 1000) return false;\n    if (cur.value.from == from) main = ranges.length;\n    ranges.push(EditorSelection.range(cur.value.from, cur.value.to));\n  }\n\n  dispatch(state.update({\n    selection: EditorSelection.create(ranges, main)\n  }));\n  return true;\n};\n/**\nReplace the current match of the search query.\n*/\n\n\nconst replaceNext = /*@__PURE__*/searchCommand((view, {\n  query\n}) => {\n  let {\n    state\n  } = view,\n      {\n    from,\n    to\n  } = state.selection.main;\n  let next = query.nextMatch(state.doc, from, from);\n  if (!next) return false;\n  let changes = [],\n      selection,\n      replacement;\n\n  if (next.from == from && next.to == to) {\n    replacement = state.toText(query.getReplacement(next));\n    changes.push({\n      from: next.from,\n      to: next.to,\n      insert: replacement\n    });\n    next = query.nextMatch(state.doc, next.from, next.to);\n  }\n\n  if (next) {\n    let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;\n    selection = {\n      anchor: next.from - off,\n      head: next.to - off\n    };\n  }\n\n  view.dispatch({\n    changes,\n    selection,\n    scrollIntoView: !!selection,\n    effects: next ? announceMatch(view, next) : undefined\n  });\n  return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/\n\nconst replaceAll = /*@__PURE__*/searchCommand((view, {\n  query\n}) => {\n  let changes = query.matchAll(view.state.doc, 1e9).map(match => {\n    let {\n      from,\n      to\n    } = match;\n    return {\n      from,\n      to,\n      insert: query.getReplacement(match)\n    };\n  });\n  if (!changes.length) return false;\n  view.dispatch({\n    changes\n  });\n  return true;\n});\n\nfunction createSearchPanel(view) {\n  let {\n    query\n  } = view.state.field(searchState);\n  return {\n    dom: buildPanel({\n      view,\n      query,\n\n      updateQuery(q) {\n        if (!query.eq(q)) {\n          query = q;\n          view.dispatch({\n            effects: setQuery.of(query)\n          });\n        }\n      }\n\n    }),\n\n    mount() {\n      this.dom.querySelector(\"[name=search]\").select();\n    },\n\n    pos: 80\n  };\n}\n/**\nMake sure the search panel is open and focused.\n*/\n\n\nconst openSearchPanel = view => {\n  let state = view.state.field(searchState, false);\n\n  if (state && state.panel) {\n    let panel = getPanel(view, createSearchPanel);\n    if (!panel) return false;\n    panel.dom.querySelector(\"[name=search]\").focus();\n  } else {\n    view.dispatch({\n      effects: [togglePanel.of(true), ...(state ? [] : [StateEffect.appendConfig.of(searchExtensions)])]\n    });\n  }\n\n  return true;\n};\n/**\nClose the search panel.\n*/\n\n\nconst closeSearchPanel = view => {\n  let state = view.state.field(searchState, false);\n  if (!state || !state.panel) return false;\n  let panel = getPanel(view, createSearchPanel);\n  if (panel && panel.dom.contains(view.root.activeElement)) view.focus();\n  view.dispatch({\n    effects: togglePanel.of(false)\n  });\n  return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)\n*/\n\n\nconst searchKeymap = [{\n  key: \"Mod-f\",\n  run: openSearchPanel,\n  scope: \"editor search-panel\"\n}, {\n  key: \"F3\",\n  run: findNext,\n  shift: findPrevious,\n  scope: \"editor search-panel\"\n}, {\n  key: \"Mod-g\",\n  run: findNext,\n  shift: findPrevious,\n  scope: \"editor search-panel\"\n}, {\n  key: \"Escape\",\n  run: closeSearchPanel,\n  scope: \"editor search-panel\"\n}, {\n  key: \"Mod-Shift-l\",\n  run: selectSelectionMatches\n}, {\n  key: \"Alt-g\",\n  run: gotoLine\n}, {\n  key: \"Mod-d\",\n  run: selectNextOccurrence\n}];\n\nfunction buildPanel(conf) {\n  function phrase(phrase) {\n    return conf.view.state.phrase(phrase);\n  }\n\n  let searchField = elt(\"input\", {\n    value: conf.query.search,\n    placeholder: phrase(\"Find\"),\n    \"aria-label\": phrase(\"Find\"),\n    class: \"cm-textfield\",\n    name: \"search\",\n    onchange: update,\n    onkeyup: update\n  });\n  let replaceField = elt(\"input\", {\n    value: conf.query.replace,\n    placeholder: phrase(\"Replace\"),\n    \"aria-label\": phrase(\"Replace\"),\n    class: \"cm-textfield\",\n    name: \"replace\",\n    onchange: update,\n    onkeyup: update\n  });\n  let caseField = elt(\"input\", {\n    type: \"checkbox\",\n    name: \"case\",\n    checked: !conf.query.caseInsensitive,\n    onchange: update\n  });\n  let reField = elt(\"input\", {\n    type: \"checkbox\",\n    name: \"re\",\n    checked: conf.query instanceof RegExpQuery,\n    onchange: update\n  });\n\n  function update() {\n    conf.updateQuery(new (reField.checked ? RegExpQuery : StringQuery)(searchField.value, replaceField.value, !caseField.checked));\n  }\n\n  function keydown(e) {\n    if (runScopeHandlers(conf.view, e, \"search-panel\")) {\n      e.preventDefault();\n    } else if (e.keyCode == 13 && e.target == searchField) {\n      e.preventDefault();\n      (e.shiftKey ? findPrevious : findNext)(conf.view);\n    } else if (e.keyCode == 13 && e.target == replaceField) {\n      e.preventDefault();\n      replaceNext(conf.view);\n    }\n  }\n\n  function button(name, onclick, content) {\n    return elt(\"button\", {\n      class: \"cm-button\",\n      name,\n      onclick\n    }, content);\n  }\n\n  let panel = elt(\"div\", {\n    onkeydown: keydown,\n    class: \"cm-search\"\n  }, [searchField, button(\"next\", () => findNext(conf.view), [phrase(\"next\")]), button(\"prev\", () => findPrevious(conf.view), [phrase(\"previous\")]), button(\"select\", () => selectMatches(conf.view), [phrase(\"all\")]), elt(\"label\", null, [caseField, phrase(\"match case\")]), elt(\"label\", null, [reField, phrase(\"regexp\")]), elt(\"br\"), replaceField, button(\"replace\", () => replaceNext(conf.view), [phrase(\"replace\")]), button(\"replaceAll\", () => replaceAll(conf.view), [phrase(\"replace all\")]), elt(\"button\", {\n    name: \"close\",\n    onclick: () => closeSearchPanel(conf.view),\n    \"aria-label\": phrase(\"close\")\n  }, [\"×\"])]);\n  return panel;\n}\n\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\n\nfunction announceMatch(view, {\n  from,\n  to\n}) {\n  let lineStart = view.state.doc.lineAt(from).from,\n      lineEnd = view.state.doc.lineAt(to).to;\n  let start = Math.max(lineStart, from - AnnounceMargin),\n      end = Math.min(lineEnd, to + AnnounceMargin);\n  let text = view.state.sliceDoc(start, end);\n\n  if (start != lineStart) {\n    for (let i = 0; i < AnnounceMargin; i++) if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n      text = text.slice(i);\n      break;\n    }\n  }\n\n  if (end != lineEnd) {\n    for (let i = text.length - 1; i > text.length - AnnounceMargin; i--) if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n      text = text.slice(0, i);\n      break;\n    }\n  }\n\n  return EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${view.state.doc.lineAt(from).number}`);\n}\n\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n  \".cm-panel.cm-search\": {\n    padding: \"2px 6px 4px\",\n    position: \"relative\",\n    \"& [name=close]\": {\n      position: \"absolute\",\n      top: \"0\",\n      right: \"4px\",\n      backgroundColor: \"inherit\",\n      border: \"none\",\n      font: \"inherit\",\n      padding: 0,\n      margin: 0\n    },\n    \"& input, & button, & label\": {\n      margin: \".2em .6em .2em 0\"\n    },\n    \"& input[type=checkbox]\": {\n      marginRight: \".2em\"\n    },\n    \"& label\": {\n      fontSize: \"80%\",\n      whiteSpace: \"pre\"\n    }\n  },\n  \"&light .cm-searchMatch\": {\n    backgroundColor: \"#ffff0054\"\n  },\n  \"&dark .cm-searchMatch\": {\n    backgroundColor: \"#00ffff8a\"\n  },\n  \"&light .cm-searchMatch-selected\": {\n    backgroundColor: \"#ff6a0054\"\n  },\n  \"&dark .cm-searchMatch-selected\": {\n    backgroundColor: \"#ff00ff8a\"\n  }\n});\nconst searchExtensions = [searchState, /*@__PURE__*/Prec.override(searchHighlighter), baseTheme];\nexport { RegExpCursor, SearchCursor, closeSearchPanel, findNext, findPrevious, gotoLine, highlightSelectionMatches, openSearchPanel, replaceAll, replaceNext, searchKeymap, selectMatches, selectNextOccurrence, selectSelectionMatches };","map":{"version":3,"sources":["D:/MSIT/Practicum - iLMS/AssessmentsSystem/node_modules/@codemirror/search/dist/index.js"],"names":["EditorView","Decoration","ViewPlugin","runScopeHandlers","StateEffect","StateField","EditorSelection","Facet","combineConfig","CharCategory","Prec","showPanel","getPanel","RangeSetBuilder","elt","codePointAt","fromCodePoint","codePointSize","basicNormalize","String","prototype","normalize","x","SearchCursor","constructor","text","query","from","to","length","value","done","matches","buffer","bufferPos","iter","iterRange","bufferStart","peek","next","pop","nextOverlapping","str","start","norm","i","pos","code","charCodeAt","match","index","keep","splice","push","empty","exec","baseFlags","unicode","RegExpCursor","options","curLine","test","MultilineRegExpCursor","re","RegExp","ignoreCase","startLine","lineAt","curLineStart","matchPos","getLine","skip","lineBreak","slice","nextLine","off","lastIndex","flattened","WeakMap","FlattenedDoc","get","doc","cached","flat","sliceString","set","cachedFrom","chunkEnd","validRegExp","source","_a","createLineDialog","view","input","class","name","dom","onkeydown","event","keyCode","preventDefault","dispatch","effects","dialogEffect","of","focus","go","onsubmit","state","phrase","type","selection","main","head","sign","ln","cl","percent","col","line","number","pc","lines","Math","round","docLine","max","min","cursor","scrollIntoView","define","dialogField","create","update","tr","e","is","provide","f","val","gotoLine","panel","field","appendConfig","baseTheme$1","querySelector","baseTheme","padding","fontSize","defaultHighlightOptions","highlightWordAroundCursor","minSelectionLength","maxMatches","highlightConfig","combine","a","b","highlightSelectionMatches","ext","defaultTheme","matchHighlighter","matchDeco","mark","mainMatchDeco","fromClass","decorations","getDeco","selectionSet","docChanged","viewportChanged","conf","facet","sel","ranges","none","range","check","word","wordAt","charCategorizer","sliceDoc","len","trim","deco","part","visibleRanges","Word","v","backgroundColor","selectWord","newSel","map","mainIndex","eq","findNextOccurrence","ahead","some","r","selectNextOccurrence","searchedText","addRange","Query","search","replace","caseInsensitive","other","StringQuery","unquoted","_","ch","toLowerCase","undefined","nextMatch","curFrom","curTo","prevMatchInRange","prevMatch","getReplacement","_result","matchAll","limit","highlight","add","valid","RegExpQuery","size","result","m","setQuery","togglePanel","searchState","SearchState","createSearchPanel","effect","matchMark","selectedMatchMark","searchHighlighter","startState","builder","l","selected","finish","searchCommand","openSearchPanel","findNext","anchor","announceMatch","findPrevious","selectMatches","selectSelectionMatches","cur","replaceNext","changes","replacement","toText","insert","replaceAll","buildPanel","updateQuery","q","mount","select","searchExtensions","closeSearchPanel","contains","root","activeElement","searchKeymap","key","run","scope","shift","searchField","placeholder","onchange","onkeyup","replaceField","caseField","checked","reField","keydown","target","shiftKey","button","onclick","content","AnnounceMargin","Break","lineStart","lineEnd","end","announce","position","top","right","border","font","margin","marginRight","whiteSpace","override"],"mappings":"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","sourcesContent":["import { EditorView, Decoration, ViewPlugin, runScopeHandlers } from '@codemirror/view';\nimport { StateEffect, StateField, EditorSelection, Facet, combineConfig, CharCategory, Prec } from '@codemirror/state';\nimport { showPanel, getPanel } from '@codemirror/panel';\nimport { RangeSetBuilder } from '@codemirror/rangeset';\nimport elt from 'crelt';\nimport { codePointAt, fromCodePoint, codePointSize } from '@codemirror/text';\n\nconst basicNormalize = typeof String.prototype.normalize == \"function\"\n    ? x => x.normalize(\"NFKD\") : x => x;\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/\nclass SearchCursor {\n    /**\n    Create a text cursor. The query is the search string, `from` to\n    `to` provides the region to search.\n    \n    When `normalize` is given, it will be called, on both the query\n    string and the content it is matched against, before comparing.\n    You can, for example, create a case-insensitive search by\n    passing `s => s.toLowerCase()`.\n    \n    Text is always normalized with\n    [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n    (when supported).\n    */\n    constructor(text, query, from = 0, to = text.length, normalize) {\n        /**\n        The current match (only holds a meaningful value after\n        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n        `done` is false).\n        */\n        this.value = { from: 0, to: 0 };\n        /**\n        Whether the end of the iterated region has been reached.\n        */\n        this.done = false;\n        this.matches = [];\n        this.buffer = \"\";\n        this.bufferPos = 0;\n        this.iter = text.iterRange(from, to);\n        this.bufferStart = from;\n        this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;\n        this.query = this.normalize(query);\n    }\n    peek() {\n        if (this.bufferPos == this.buffer.length) {\n            this.bufferStart += this.buffer.length;\n            this.iter.next();\n            if (this.iter.done)\n                return -1;\n            this.bufferPos = 0;\n            this.buffer = this.iter.value;\n        }\n        return codePointAt(this.buffer, this.bufferPos);\n    }\n    /**\n    Look for the next match. Updates the iterator's\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n    at least once before using the cursor.\n    */\n    next() {\n        while (this.matches.length)\n            this.matches.pop();\n        return this.nextOverlapping();\n    }\n    /**\n    The `next` method will ignore matches that partially overlap a\n    previous match. This method behaves like `next`, but includes\n    such matches.\n    */\n    nextOverlapping() {\n        for (;;) {\n            let next = this.peek();\n            if (next < 0) {\n                this.done = true;\n                return this;\n            }\n            let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;\n            this.bufferPos += codePointSize(next);\n            let norm = this.normalize(str);\n            for (let i = 0, pos = start;; i++) {\n                let code = norm.charCodeAt(i);\n                let match = this.match(code, pos);\n                if (match) {\n                    this.value = match;\n                    return this;\n                }\n                if (i == norm.length - 1)\n                    break;\n                if (pos == start && i < str.length && str.charCodeAt(i) == code)\n                    pos++;\n            }\n        }\n    }\n    match(code, pos) {\n        let match = null;\n        for (let i = 0; i < this.matches.length; i += 2) {\n            let index = this.matches[i], keep = false;\n            if (this.query.charCodeAt(index) == code) {\n                if (index == this.query.length - 1) {\n                    match = { from: this.matches[i + 1], to: pos + 1 };\n                }\n                else {\n                    this.matches[i]++;\n                    keep = true;\n                }\n            }\n            if (!keep) {\n                this.matches.splice(i, 2);\n                i -= 2;\n            }\n        }\n        if (this.query.charCodeAt(0) == code) {\n            if (this.query.length == 1)\n                match = { from: pos, to: pos + 1 };\n            else\n                this.matches.push(1, pos);\n        }\n        return match;\n    }\n}\n\nconst empty = { from: -1, to: -1, match: /*@__PURE__*//.*/.exec(\"\") };\nconst baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n/**\nThis class is similar to [`SearchCursor`](https://codemirror.net/6/docs/ref/#search.SearchCursor)\nbut searches for a regular expression pattern instead of a plain\nstring.\n*/\nclass RegExpCursor {\n    /**\n    Create a cursor that will search the given range in the given\n    document. `query` should be the raw pattern (as you'd pass it to\n    `new RegExp`).\n    */\n    constructor(text, query, options, from = 0, to = text.length) {\n        this.to = to;\n        this.curLine = \"\";\n        /**\n        Set to `true` when the cursor has reached the end of the search\n        range.\n        */\n        this.done = false;\n        /**\n        Will contain an object with the extent of the match and the\n        match object when [`next`](https://codemirror.net/6/docs/ref/#search.RegExpCursor.next)\n        sucessfully finds a match.\n        */\n        this.value = empty;\n        if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query))\n            return new MultilineRegExpCursor(text, query, options, from, to);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.iter = text.iter();\n        let startLine = text.lineAt(from);\n        this.curLineStart = startLine.from;\n        this.matchPos = from;\n        this.getLine(this.curLineStart);\n    }\n    getLine(skip) {\n        this.iter.next(skip);\n        if (this.iter.lineBreak) {\n            this.curLine = \"\";\n        }\n        else {\n            this.curLine = this.iter.value;\n            if (this.curLineStart + this.curLine.length > this.to)\n                this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n            this.iter.next();\n        }\n    }\n    nextLine() {\n        this.curLineStart = this.curLineStart + this.curLine.length + 1;\n        if (this.curLineStart > this.to)\n            this.curLine = \"\";\n        else\n            this.getLine(0);\n    }\n    /**\n    Move to the next match, if there is one.\n    */\n    next() {\n        for (let off = this.matchPos - this.curLineStart;;) {\n            this.re.lastIndex = off;\n            let match = this.matchPos <= this.to && this.re.exec(this.curLine);\n            if (match) {\n                let from = this.curLineStart + match.index, to = from + match[0].length;\n                this.matchPos = to + (from == to ? 1 : 0);\n                if (from == this.curLine.length)\n                    this.nextLine();\n                if (from < to || from > this.value.to) {\n                    this.value = { from, to, match };\n                    return this;\n                }\n                off = this.matchPos - this.curLineStart;\n            }\n            else if (this.curLineStart + this.curLine.length < this.to) {\n                this.nextLine();\n                off = 0;\n            }\n            else {\n                this.done = true;\n                return this;\n            }\n        }\n    }\n}\nconst flattened = /*@__PURE__*/new WeakMap();\n// Reusable (partially) flattened document strings\nclass FlattenedDoc {\n    constructor(from, text) {\n        this.from = from;\n        this.text = text;\n    }\n    get to() { return this.from + this.text.length; }\n    static get(doc, from, to) {\n        let cached = flattened.get(doc);\n        if (!cached || cached.from >= to || cached.to <= from) {\n            let flat = new FlattenedDoc(from, doc.sliceString(from, to));\n            flattened.set(doc, flat);\n            return flat;\n        }\n        if (cached.from == from && cached.to == to)\n            return cached;\n        let { text, from: cachedFrom } = cached;\n        if (cachedFrom > from) {\n            text = doc.sliceString(from, cachedFrom) + text;\n            cachedFrom = from;\n        }\n        if (cached.to < to)\n            text += doc.sliceString(cached.to, to);\n        flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n    }\n}\nclass MultilineRegExpCursor {\n    constructor(text, query, options, from, to) {\n        this.text = text;\n        this.to = to;\n        this.done = false;\n        this.value = empty;\n        this.matchPos = from;\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Base */));\n    }\n    chunkEnd(pos) {\n        return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n    }\n    next() {\n        for (;;) {\n            let off = this.re.lastIndex = this.matchPos - this.flat.from;\n            let match = this.re.exec(this.flat.text);\n            // Skip empty matches directly after the last match\n            if (match && !match[0] && match.index == off) {\n                this.re.lastIndex = off + 1;\n                match = this.re.exec(this.flat.text);\n            }\n            // If a match goes almost to the end of a noncomplete chunk, try\n            // again, since it'll likely be able to match more\n            if (match && this.flat.to < this.to && match.index + match[0].length > this.flat.text.length - 10)\n                match = null;\n            if (match) {\n                let from = this.flat.from + match.index, to = from + match[0].length;\n                this.value = { from, to, match };\n                this.matchPos = to + (from == to ? 1 : 0);\n                return this;\n            }\n            else {\n                if (this.flat.to == this.to) {\n                    this.done = true;\n                    return this;\n                }\n                // Grow the flattened doc\n                this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n            }\n        }\n    }\n}\nfunction validRegExp(source) {\n    try {\n        new RegExp(source, baseFlags);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\n\nfunction createLineDialog(view) {\n    let input = elt(\"input\", { class: \"cm-textfield\", name: \"line\" });\n    let dom = elt(\"form\", {\n        class: \"cm-gotoLine\",\n        onkeydown: (event) => {\n            if (event.keyCode == 27) { // Escape\n                event.preventDefault();\n                view.dispatch({ effects: dialogEffect.of(false) });\n                view.focus();\n            }\n            else if (event.keyCode == 13) { // Enter\n                event.preventDefault();\n                go();\n            }\n        },\n        onsubmit: (event) => {\n            event.preventDefault();\n            go();\n        }\n    }, elt(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", elt(\"button\", { class: \"cm-button\", type: \"submit\" }, view.state.phrase(\"go\")));\n    function go() {\n        let match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n        if (!match)\n            return;\n        let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);\n        let [, sign, ln, cl, percent] = match;\n        let col = cl ? +cl.slice(1) : 0;\n        let line = ln ? +ln : startLine.number;\n        if (ln && percent) {\n            let pc = line / 100;\n            if (sign)\n                pc = pc * (sign == \"-\" ? -1 : 1) + (startLine.number / state.doc.lines);\n            line = Math.round(state.doc.lines * pc);\n        }\n        else if (ln && sign) {\n            line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n        }\n        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n        view.dispatch({\n            effects: dialogEffect.of(false),\n            selection: EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),\n            scrollIntoView: true\n        });\n        view.focus();\n    }\n    return { dom, pos: -10 };\n}\nconst dialogEffect = /*@__PURE__*/StateEffect.define();\nconst dialogField = /*@__PURE__*/StateField.define({\n    create() { return true; },\n    update(value, tr) {\n        for (let e of tr.effects)\n            if (e.is(dialogEffect))\n                value = e.value;\n        return value;\n    },\n    provide: f => showPanel.from(f, val => val ? createLineDialog : null)\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n\nThe dialog can be styled with the `panel.gotoLine` theme\nselector.\n*/\nconst gotoLine = view => {\n    let panel = getPanel(view, createLineDialog);\n    if (!panel) {\n        let effects = [dialogEffect.of(true)];\n        if (view.state.field(dialogField, false) == null)\n            effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));\n        view.dispatch({ effects });\n        panel = getPanel(view, createLineDialog);\n    }\n    if (panel)\n        panel.dom.querySelector(\"input\").focus();\n    return true;\n};\nconst baseTheme$1 = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-panel.cm-gotoLine\": {\n        padding: \"2px 6px 4px\",\n        \"& label\": { fontSize: \"80%\" }\n    }\n});\n\nconst defaultHighlightOptions = {\n    highlightWordAroundCursor: false,\n    minSelectionLength: 1,\n    maxMatches: 100\n};\nconst highlightConfig = /*@__PURE__*/Facet.define({\n    combine(options) {\n        return combineConfig(options, defaultHighlightOptions, {\n            highlightWordAroundCursor: (a, b) => a || b,\n            minSelectionLength: Math.min,\n            maxMatches: Math.min\n        });\n    }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/\nfunction highlightSelectionMatches(options) {\n    let ext = [defaultTheme, matchHighlighter];\n    if (options)\n        ext.push(highlightConfig.of(options));\n    return ext;\n}\nconst matchDeco = /*@__PURE__*/Decoration.mark({ class: \"cm-selectionMatch\" });\nconst mainMatchDeco = /*@__PURE__*/Decoration.mark({ class: \"cm-selectionMatch cm-selectionMatch-main\" });\nconst matchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.selectionSet || update.docChanged || update.viewportChanged)\n            this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let conf = view.state.facet(highlightConfig);\n        let { state } = view, sel = state.selection;\n        if (sel.ranges.length > 1)\n            return Decoration.none;\n        let range = sel.main, query, check = null;\n        if (range.empty) {\n            if (!conf.highlightWordAroundCursor)\n                return Decoration.none;\n            let word = state.wordAt(range.head);\n            if (!word)\n                return Decoration.none;\n            check = state.charCategorizer(range.head);\n            query = state.sliceDoc(word.from, word.to);\n        }\n        else {\n            let len = range.to - range.from;\n            if (len < conf.minSelectionLength || len > 200)\n                return Decoration.none;\n            query = state.sliceDoc(range.from, range.to).trim();\n            if (!query)\n                return Decoration.none;\n        }\n        let deco = [];\n        for (let part of view.visibleRanges) {\n            let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n            while (!cursor.nextOverlapping().done) {\n                let { from, to } = cursor.value;\n                if (!check || ((from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) &&\n                    (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word))) {\n                    if (check && from <= range.from && to >= range.to)\n                        deco.push(mainMatchDeco.range(from, to));\n                    else if (from >= range.to || to <= range.from)\n                        deco.push(matchDeco.range(from, to));\n                    if (deco.length > conf.maxMatches)\n                        return Decoration.none;\n                }\n            }\n        }\n        return Decoration.set(deco);\n    }\n}, {\n    decorations: v => v.decorations\n});\nconst defaultTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-selectionMatch\": { backgroundColor: \"#99ff7780\" },\n    \".cm-searchMatch .cm-selectionMatch\": { backgroundColor: \"transparent\" }\n});\n// Select the words around the cursors.\nconst selectWord = ({ state, dispatch }) => {\n    let { selection } = state;\n    let newSel = EditorSelection.create(selection.ranges.map(range => state.wordAt(range.head) || EditorSelection.cursor(range.head)), selection.mainIndex);\n    if (newSel.eq(selection))\n        return false;\n    dispatch(state.update({ selection: newSel }));\n    return true;\n};\n// Find next occurrence of query relative to last cursor. Wrap around\n// the document if there are no more matches.\nfunction findNextOccurrence(state, query) {\n    let { ranges } = state.selection;\n    let ahead = new SearchCursor(state.doc, query, ranges[ranges.length - 1].to).next();\n    if (!ahead.done)\n        return ahead.value;\n    let cursor = new SearchCursor(state.doc, query, 0, Math.max(0, ranges[ranges.length - 1].from - 1));\n    while (!cursor.next().done) {\n        if (!ranges.some(r => r.from === cursor.value.from))\n            return cursor.value;\n    }\n    return null;\n}\n/**\nSelect next occurrence of the current selection.\nExpand selection to the word when selection range is empty.\n*/\nconst selectNextOccurrence = ({ state, dispatch }) => {\n    let { ranges } = state.selection;\n    if (ranges.some(sel => sel.from === sel.to))\n        return selectWord({ state, dispatch });\n    let searchedText = state.sliceDoc(ranges[0].from, ranges[0].to);\n    if (state.selection.ranges.some(r => state.sliceDoc(r.from, r.to) != searchedText))\n        return false;\n    let range = findNextOccurrence(state, searchedText);\n    if (!range)\n        return false;\n    dispatch(state.update({\n        selection: state.selection.addRange(EditorSelection.range(range.from, range.to)),\n        scrollIntoView: true\n    }));\n    return true;\n};\n\nclass Query {\n    constructor(search, replace, caseInsensitive) {\n        this.search = search;\n        this.replace = replace;\n        this.caseInsensitive = caseInsensitive;\n    }\n    eq(other) {\n        return this.search == other.search && this.replace == other.replace &&\n            this.caseInsensitive == other.caseInsensitive && this.constructor == other.constructor;\n    }\n}\nclass StringQuery extends Query {\n    constructor(search, replace, caseInsensitive) {\n        super(search, replace, caseInsensitive);\n        this.unquoted = search.replace(/\\\\([nrt\\\\])/g, (_, ch) => ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\\t\" : \"\\\\\");\n    }\n    cursor(doc, from = 0, to = doc.length) {\n        return new SearchCursor(doc, this.unquoted, from, to, this.caseInsensitive ? x => x.toLowerCase() : undefined);\n    }\n    nextMatch(doc, curFrom, curTo) {\n        let cursor = this.cursor(doc, curTo).nextOverlapping();\n        if (cursor.done)\n            cursor = this.cursor(doc, 0, curFrom).nextOverlapping();\n        return cursor.done ? null : cursor.value;\n    }\n    // Searching in reverse is, rather than implementing inverted search\n    // cursor, done by scanning chunk after chunk forward.\n    prevMatchInRange(doc, from, to) {\n        for (let pos = to;;) {\n            let start = Math.max(from, pos - 10000 /* ChunkSize */ - this.unquoted.length);\n            let cursor = this.cursor(doc, start, pos), range = null;\n            while (!cursor.nextOverlapping().done)\n                range = cursor.value;\n            if (range)\n                return range;\n            if (start == from)\n                return null;\n            pos -= 10000 /* ChunkSize */;\n        }\n    }\n    prevMatch(doc, curFrom, curTo) {\n        return this.prevMatchInRange(doc, 0, curFrom) ||\n            this.prevMatchInRange(doc, curTo, doc.length);\n    }\n    getReplacement(_result) { return this.replace; }\n    matchAll(doc, limit) {\n        let cursor = this.cursor(doc), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(doc, from, to, add) {\n        let cursor = this.cursor(doc, Math.max(0, from - this.unquoted.length), Math.min(to + this.unquoted.length, doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n    get valid() { return !!this.search; }\n}\nclass RegExpQuery extends Query {\n    constructor(search, replace, caseInsensitive) {\n        super(search, replace, caseInsensitive);\n        this.valid = !!search && validRegExp(search);\n    }\n    cursor(doc, from = 0, to = doc.length) {\n        return new RegExpCursor(doc, this.search, this.caseInsensitive ? { ignoreCase: true } : undefined, from, to);\n    }\n    nextMatch(doc, curFrom, curTo) {\n        let cursor = this.cursor(doc, curTo).next();\n        if (cursor.done)\n            cursor = this.cursor(doc, 0, curFrom).next();\n        return cursor.done ? null : cursor.value;\n    }\n    prevMatchInRange(doc, from, to) {\n        for (let size = 1;; size++) {\n            let start = Math.max(from, to - size * 10000 /* ChunkSize */);\n            let cursor = this.cursor(doc, start, to), range = null;\n            while (!cursor.next().done)\n                range = cursor.value;\n            if (range && (start == from || range.from > start + 10))\n                return range;\n            if (start == from)\n                return null;\n        }\n    }\n    prevMatch(doc, curFrom, curTo) {\n        return this.prevMatchInRange(doc, 0, curFrom) ||\n            this.prevMatchInRange(doc, curTo, doc.length);\n    }\n    getReplacement(result) {\n        return this.replace.replace(/\\$([$&\\d+])/g, (m, i) => i == \"$\" ? \"$\"\n            : i == \"&\" ? result.match[0]\n                : i != \"0\" && +i < result.match.length ? result.match[i]\n                    : m);\n    }\n    matchAll(doc, limit) {\n        let cursor = this.cursor(doc), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(doc, from, to, add) {\n        let cursor = this.cursor(doc, Math.max(0, from - 250 /* HighlightMargin */), Math.min(to + 250 /* HighlightMargin */, doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n}\nconst setQuery = /*@__PURE__*/StateEffect.define();\nconst togglePanel = /*@__PURE__*/StateEffect.define();\nconst searchState = /*@__PURE__*/StateField.define({\n    create() {\n        return new SearchState(new StringQuery(\"\", \"\", false), createSearchPanel);\n    },\n    update(value, tr) {\n        for (let effect of tr.effects) {\n            if (effect.is(setQuery))\n                value = new SearchState(effect.value, value.panel);\n            else if (effect.is(togglePanel))\n                value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n        }\n        return value;\n    },\n    provide: f => showPanel.from(f, val => val.panel)\n});\nclass SearchState {\n    constructor(query, panel) {\n        this.query = query;\n        this.panel = panel;\n    }\n}\nconst matchMark = /*@__PURE__*/Decoration.mark({ class: \"cm-searchMatch\" }), selectedMatchMark = /*@__PURE__*/Decoration.mark({ class: \"cm-searchMatch cm-searchMatch-selected\" });\nconst searchHighlighter = /*@__PURE__*/ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.decorations = this.highlight(view.state.field(searchState));\n    }\n    update(update) {\n        let state = update.state.field(searchState);\n        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet)\n            this.decorations = this.highlight(state);\n    }\n    highlight({ query, panel }) {\n        if (!panel || !query.valid)\n            return Decoration.none;\n        let { view } = this;\n        let builder = new RangeSetBuilder();\n        for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n            let { from, to } = ranges[i];\n            while (i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* HighlightMargin */)\n                to = ranges[++i].to;\n            query.highlight(view.state.doc, from, to, (from, to) => {\n                let selected = view.state.selection.ranges.some(r => r.from == from && r.to == to);\n                builder.add(from, to, selected ? selectedMatchMark : matchMark);\n            });\n        }\n        return builder.finish();\n    }\n}, {\n    decorations: v => v.decorations\n});\nfunction searchCommand(f) {\n    return view => {\n        let state = view.state.field(searchState, false);\n        return state && state.query.valid ? f(view, state) : openSearchPanel(view);\n    };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/\nconst findNext = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { from, to } = view.state.selection.main;\n    let next = query.nextMatch(view.state.doc, from, to);\n    if (!next || next.from == from && next.to == to)\n        return false;\n    view.dispatch({\n        selection: { anchor: next.from, head: next.to },\n        scrollIntoView: true,\n        effects: announceMatch(view, next)\n    });\n    return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/\nconst findPrevious = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { state } = view, { from, to } = state.selection.main;\n    let range = query.prevMatch(state.doc, from, to);\n    if (!range)\n        return false;\n    view.dispatch({\n        selection: { anchor: range.from, head: range.to },\n        scrollIntoView: true,\n        effects: announceMatch(view, range)\n    });\n    return true;\n});\n/**\nSelect all instances of the search query.\n*/\nconst selectMatches = /*@__PURE__*/searchCommand((view, { query }) => {\n    let ranges = query.matchAll(view.state.doc, 1000);\n    if (!ranges || !ranges.length)\n        return false;\n    view.dispatch({\n        selection: EditorSelection.create(ranges.map(r => EditorSelection.range(r.from, r.to)))\n    });\n    return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/\nconst selectSelectionMatches = ({ state, dispatch }) => {\n    let sel = state.selection;\n    if (sel.ranges.length > 1 || sel.main.empty)\n        return false;\n    let { from, to } = sel.main;\n    let ranges = [], main = 0;\n    for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {\n        if (ranges.length > 1000)\n            return false;\n        if (cur.value.from == from)\n            main = ranges.length;\n        ranges.push(EditorSelection.range(cur.value.from, cur.value.to));\n    }\n    dispatch(state.update({ selection: EditorSelection.create(ranges, main) }));\n    return true;\n};\n/**\nReplace the current match of the search query.\n*/\nconst replaceNext = /*@__PURE__*/searchCommand((view, { query }) => {\n    let { state } = view, { from, to } = state.selection.main;\n    let next = query.nextMatch(state.doc, from, from);\n    if (!next)\n        return false;\n    let changes = [], selection, replacement;\n    if (next.from == from && next.to == to) {\n        replacement = state.toText(query.getReplacement(next));\n        changes.push({ from: next.from, to: next.to, insert: replacement });\n        next = query.nextMatch(state.doc, next.from, next.to);\n    }\n    if (next) {\n        let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;\n        selection = { anchor: next.from - off, head: next.to - off };\n    }\n    view.dispatch({\n        changes, selection,\n        scrollIntoView: !!selection,\n        effects: next ? announceMatch(view, next) : undefined\n    });\n    return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/\nconst replaceAll = /*@__PURE__*/searchCommand((view, { query }) => {\n    let changes = query.matchAll(view.state.doc, 1e9).map(match => {\n        let { from, to } = match;\n        return { from, to, insert: query.getReplacement(match) };\n    });\n    if (!changes.length)\n        return false;\n    view.dispatch({ changes });\n    return true;\n});\nfunction createSearchPanel(view) {\n    let { query } = view.state.field(searchState);\n    return {\n        dom: buildPanel({\n            view,\n            query,\n            updateQuery(q) {\n                if (!query.eq(q)) {\n                    query = q;\n                    view.dispatch({ effects: setQuery.of(query) });\n                }\n            }\n        }),\n        mount() {\n            this.dom.querySelector(\"[name=search]\").select();\n        },\n        pos: 80\n    };\n}\n/**\nMake sure the search panel is open and focused.\n*/\nconst openSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (state && state.panel) {\n        let panel = getPanel(view, createSearchPanel);\n        if (!panel)\n            return false;\n        panel.dom.querySelector(\"[name=search]\").focus();\n    }\n    else {\n        view.dispatch({ effects: [togglePanel.of(true), ...state ? [] : [StateEffect.appendConfig.of(searchExtensions)]] });\n    }\n    return true;\n};\n/**\nClose the search panel.\n*/\nconst closeSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (!state || !state.panel)\n        return false;\n    let panel = getPanel(view, createSearchPanel);\n    if (panel && panel.dom.contains(view.root.activeElement))\n        view.focus();\n    view.dispatch({ effects: togglePanel.of(false) });\n    return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n - Mod-d: [`selectNextOccurrence`](https://codemirror.net/6/docs/ref/#search.selectNextOccurrence)\n*/\nconst searchKeymap = [\n    { key: \"Mod-f\", run: openSearchPanel, scope: \"editor search-panel\" },\n    { key: \"F3\", run: findNext, shift: findPrevious, scope: \"editor search-panel\" },\n    { key: \"Mod-g\", run: findNext, shift: findPrevious, scope: \"editor search-panel\" },\n    { key: \"Escape\", run: closeSearchPanel, scope: \"editor search-panel\" },\n    { key: \"Mod-Shift-l\", run: selectSelectionMatches },\n    { key: \"Alt-g\", run: gotoLine },\n    { key: \"Mod-d\", run: selectNextOccurrence },\n];\nfunction buildPanel(conf) {\n    function phrase(phrase) { return conf.view.state.phrase(phrase); }\n    let searchField = elt(\"input\", {\n        value: conf.query.search,\n        placeholder: phrase(\"Find\"),\n        \"aria-label\": phrase(\"Find\"),\n        class: \"cm-textfield\",\n        name: \"search\",\n        onchange: update,\n        onkeyup: update\n    });\n    let replaceField = elt(\"input\", {\n        value: conf.query.replace,\n        placeholder: phrase(\"Replace\"),\n        \"aria-label\": phrase(\"Replace\"),\n        class: \"cm-textfield\",\n        name: \"replace\",\n        onchange: update,\n        onkeyup: update\n    });\n    let caseField = elt(\"input\", {\n        type: \"checkbox\",\n        name: \"case\",\n        checked: !conf.query.caseInsensitive,\n        onchange: update\n    });\n    let reField = elt(\"input\", {\n        type: \"checkbox\",\n        name: \"re\",\n        checked: conf.query instanceof RegExpQuery,\n        onchange: update\n    });\n    function update() {\n        conf.updateQuery(new (reField.checked ? RegExpQuery : StringQuery)(searchField.value, replaceField.value, !caseField.checked));\n    }\n    function keydown(e) {\n        if (runScopeHandlers(conf.view, e, \"search-panel\")) {\n            e.preventDefault();\n        }\n        else if (e.keyCode == 13 && e.target == searchField) {\n            e.preventDefault();\n            (e.shiftKey ? findPrevious : findNext)(conf.view);\n        }\n        else if (e.keyCode == 13 && e.target == replaceField) {\n            e.preventDefault();\n            replaceNext(conf.view);\n        }\n    }\n    function button(name, onclick, content) {\n        return elt(\"button\", { class: \"cm-button\", name, onclick }, content);\n    }\n    let panel = elt(\"div\", { onkeydown: keydown, class: \"cm-search\" }, [\n        searchField,\n        button(\"next\", () => findNext(conf.view), [phrase(\"next\")]),\n        button(\"prev\", () => findPrevious(conf.view), [phrase(\"previous\")]),\n        button(\"select\", () => selectMatches(conf.view), [phrase(\"all\")]),\n        elt(\"label\", null, [caseField, phrase(\"match case\")]),\n        elt(\"label\", null, [reField, phrase(\"regexp\")]),\n        elt(\"br\"),\n        replaceField,\n        button(\"replace\", () => replaceNext(conf.view), [phrase(\"replace\")]),\n        button(\"replaceAll\", () => replaceAll(conf.view), [phrase(\"replace all\")]),\n        elt(\"button\", { name: \"close\", onclick: () => closeSearchPanel(conf.view), \"aria-label\": phrase(\"close\") }, [\"×\"])\n    ]);\n    return panel;\n}\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\nfunction announceMatch(view, { from, to }) {\n    let lineStart = view.state.doc.lineAt(from).from, lineEnd = view.state.doc.lineAt(to).to;\n    let start = Math.max(lineStart, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);\n    let text = view.state.sliceDoc(start, end);\n    if (start != lineStart) {\n        for (let i = 0; i < AnnounceMargin; i++)\n            if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n                text = text.slice(i);\n                break;\n            }\n    }\n    if (end != lineEnd) {\n        for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)\n            if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n                text = text.slice(0, i);\n                break;\n            }\n    }\n    return EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${view.state.doc.lineAt(from).number}`);\n}\nconst baseTheme = /*@__PURE__*/EditorView.baseTheme({\n    \".cm-panel.cm-search\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        },\n        \"& input, & button, & label\": {\n            margin: \".2em .6em .2em 0\"\n        },\n        \"& input[type=checkbox]\": {\n            marginRight: \".2em\"\n        },\n        \"& label\": {\n            fontSize: \"80%\",\n            whiteSpace: \"pre\"\n        }\n    },\n    \"&light .cm-searchMatch\": { backgroundColor: \"#ffff0054\" },\n    \"&dark .cm-searchMatch\": { backgroundColor: \"#00ffff8a\" },\n    \"&light .cm-searchMatch-selected\": { backgroundColor: \"#ff6a0054\" },\n    \"&dark .cm-searchMatch-selected\": { backgroundColor: \"#ff00ff8a\" }\n});\nconst searchExtensions = [\n    searchState,\n    /*@__PURE__*/Prec.override(searchHighlighter),\n    baseTheme\n];\n\nexport { RegExpCursor, SearchCursor, closeSearchPanel, findNext, findPrevious, gotoLine, highlightSelectionMatches, openSearchPanel, replaceAll, replaceNext, searchKeymap, selectMatches, selectNextOccurrence, selectSelectionMatches };\n"]},"metadata":{},"sourceType":"module"}