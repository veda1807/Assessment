{"ast":null,"code":"import { parser } from 'lezer-java';\nimport { LezerLanguage, indentNodeProp, continuedIndent, flatIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\nimport { styleTags, tags } from '@codemirror/highlight'; /// A language provider based on the [Lezer Java\n/// parser](https://github.com/lezer-parser/java), extended with\n/// highlighting and indentation information.\n\nconst javaLanguage = LezerLanguage.define({\n  parser: parser.configure({\n    props: [indentNodeProp.add({\n      IfStatement: continuedIndent({\n        except: /^\\s*({|else\\b)/\n      }),\n      TryStatement: continuedIndent({\n        except: /^\\s*({|catch|finally)\\b/\n      }),\n      LabeledStatement: flatIndent,\n      SwitchBlock: context => {\n        let after = context.textAfter,\n            closed = /^\\s*\\}/.test(after),\n            isCase = /^\\s*(case|default)\\b/.test(after);\n        return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;\n      },\n      BlockComment: () => -1,\n      Statement: continuedIndent({\n        except: /^{/\n      })\n    }), foldNodeProp.add({\n      [\"Block SwitchBlock ClassBody ElementValueArrayInitializer ModuleBody EnumBody \" + \"ConstructorBody InterfaceBody ArrayInitializer\"]: foldInside,\n\n      BlockComment(tree) {\n        return {\n          from: tree.from + 2,\n          to: tree.to - 2\n        };\n      }\n\n    }), styleTags({\n      null: tags.null,\n      instanceof: tags.operatorKeyword,\n      this: tags.self,\n      \"new super assert open to with void\": tags.keyword,\n      \"class interface extends implements module package import enum\": tags.definitionKeyword,\n      \"switch while for if else case default do break continue return try catch finally throw\": tags.controlKeyword,\n      [\"requires exports opens uses provides public private protected static transitive abstract final \" + \"strictfp synchronized native transient volatile throws\"]: tags.modifier,\n      IntegerLiteral: tags.integer,\n      FloatLiteral: tags.float,\n      StringLiteral: tags.string,\n      CharacterLiteral: tags.character,\n      LineComment: tags.lineComment,\n      BlockComment: tags.blockComment,\n      BooleanLiteral: tags.bool,\n      PrimitiveType: tags.standard(tags.typeName),\n      TypeName: tags.typeName,\n      Identifier: tags.variableName,\n      \"MethodName/Identifier\": tags.function(tags.variableName),\n      Definition: tags.definition(tags.variableName),\n      ArithOp: tags.arithmeticOperator,\n      LogicOp: tags.logicOperator,\n      BitOp: tags.bitwiseOperator,\n      CompareOp: tags.compareOperator,\n      AssignOp: tags.definitionOperator,\n      UpdateOp: tags.updateOperator,\n      Asterisk: tags.punctuation,\n      Label: tags.labelName,\n      \"( )\": tags.paren,\n      \"[ ]\": tags.squareBracket,\n      \"{ }\": tags.brace,\n      \".\": tags.derefOperator,\n      \", ;\": tags.separator\n    })]\n  }),\n  languageData: {\n    commentTokens: {\n      line: \"//\",\n      block: {\n        open: \"/*\",\n        close: \"*/\"\n      }\n    },\n    indentOnInput: /^\\s*(?:case |default:|\\{|\\})$/\n  }\n}); /// Java language support.\n\nfunction java() {\n  return new LanguageSupport(javaLanguage);\n}\n\nexport { java, javaLanguage };","map":{"version":3,"sources":["D:/MSIT/Practicum - iLMS/editor-codemirror6/node_modules/@codemirror/lang-java/dist/index.js"],"names":["parser","LezerLanguage","indentNodeProp","continuedIndent","flatIndent","foldNodeProp","foldInside","LanguageSupport","styleTags","tags","javaLanguage","define","configure","props","add","IfStatement","except","TryStatement","LabeledStatement","SwitchBlock","context","after","textAfter","closed","test","isCase","baseIndent","unit","BlockComment","Statement","tree","from","to","null","instanceof","operatorKeyword","this","self","keyword","definitionKeyword","controlKeyword","modifier","IntegerLiteral","integer","FloatLiteral","float","StringLiteral","string","CharacterLiteral","character","LineComment","lineComment","blockComment","BooleanLiteral","bool","PrimitiveType","standard","typeName","TypeName","Identifier","variableName","function","Definition","definition","ArithOp","arithmeticOperator","LogicOp","logicOperator","BitOp","bitwiseOperator","CompareOp","compareOperator","AssignOp","definitionOperator","UpdateOp","updateOperator","Asterisk","punctuation","Label","labelName","paren","squareBracket","brace","derefOperator","separator","languageData","commentTokens","line","block","open","close","indentOnInput","java"],"mappings":"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","sourcesContent":["import { parser } from 'lezer-java';\nimport { LezerLanguage, indentNodeProp, continuedIndent, flatIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\nimport { styleTags, tags } from '@codemirror/highlight';\n\n/// A language provider based on the [Lezer Java\n/// parser](https://github.com/lezer-parser/java), extended with\n/// highlighting and indentation information.\nconst javaLanguage = LezerLanguage.define({\n    parser: parser.configure({\n        props: [\n            indentNodeProp.add({\n                IfStatement: continuedIndent({ except: /^\\s*({|else\\b)/ }),\n                TryStatement: continuedIndent({ except: /^\\s*({|catch|finally)\\b/ }),\n                LabeledStatement: flatIndent,\n                SwitchBlock: context => {\n                    let after = context.textAfter, closed = /^\\s*\\}/.test(after), isCase = /^\\s*(case|default)\\b/.test(after);\n                    return context.baseIndent + (closed ? 0 : isCase ? 1 : 2) * context.unit;\n                },\n                BlockComment: () => -1,\n                Statement: continuedIndent({ except: /^{/ })\n            }),\n            foldNodeProp.add({\n                [\"Block SwitchBlock ClassBody ElementValueArrayInitializer ModuleBody EnumBody \" +\n                    \"ConstructorBody InterfaceBody ArrayInitializer\"]: foldInside,\n                BlockComment(tree) { return { from: tree.from + 2, to: tree.to - 2 }; }\n            }),\n            styleTags({\n                null: tags.null,\n                instanceof: tags.operatorKeyword,\n                this: tags.self,\n                \"new super assert open to with void\": tags.keyword,\n                \"class interface extends implements module package import enum\": tags.definitionKeyword,\n                \"switch while for if else case default do break continue return try catch finally throw\": tags.controlKeyword,\n                [\"requires exports opens uses provides public private protected static transitive abstract final \" +\n                    \"strictfp synchronized native transient volatile throws\"]: tags.modifier,\n                IntegerLiteral: tags.integer,\n                FloatLiteral: tags.float,\n                StringLiteral: tags.string,\n                CharacterLiteral: tags.character,\n                LineComment: tags.lineComment,\n                BlockComment: tags.blockComment,\n                BooleanLiteral: tags.bool,\n                PrimitiveType: tags.standard(tags.typeName),\n                TypeName: tags.typeName,\n                Identifier: tags.variableName,\n                \"MethodName/Identifier\": tags.function(tags.variableName),\n                Definition: tags.definition(tags.variableName),\n                ArithOp: tags.arithmeticOperator,\n                LogicOp: tags.logicOperator,\n                BitOp: tags.bitwiseOperator,\n                CompareOp: tags.compareOperator,\n                AssignOp: tags.definitionOperator,\n                UpdateOp: tags.updateOperator,\n                Asterisk: tags.punctuation,\n                Label: tags.labelName,\n                \"( )\": tags.paren,\n                \"[ ]\": tags.squareBracket,\n                \"{ }\": tags.brace,\n                \".\": tags.derefOperator,\n                \", ;\": tags.separator\n            })\n        ]\n    }),\n    languageData: {\n        commentTokens: { line: \"//\", block: { open: \"/*\", close: \"*/\" } },\n        indentOnInput: /^\\s*(?:case |default:|\\{|\\})$/\n    }\n});\n/// Java language support.\nfunction java() {\n    return new LanguageSupport(javaLanguage);\n}\n\nexport { java, javaLanguage };\n"]},"metadata":{},"sourceType":"module"}