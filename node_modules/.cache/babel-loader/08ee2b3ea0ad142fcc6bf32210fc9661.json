{"ast":null,"code":"// Compressed representation of the Grapheme_Cluster_Break=Extend\n// information from\n// http://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.\n// Each pair of elements represents a range, as an offet from the\n// previous range and a length. Numbers are in base-36, with the empty\n// string being a shorthand for 1.\nlet extend = \"lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o\".split(\",\").map(s => s ? parseInt(s, 36) : 1); // Convert offsets into absolute values\n\nfor (let i = 1; i < extend.length; i++) extend[i] += extend[i - 1];\n\nfunction isExtendingChar(code) {\n  for (let i = 1; i < extend.length; i += 2) if (extend[i] > code) return extend[i - 1] <= code;\n\n  return false;\n}\n\nfunction isRegionalIndicator(code) {\n  return code >= 0x1F1E6 && code <= 0x1F1FF;\n}\n\nconst ZWJ = 0x200d; /// Returns a next grapheme cluster break _after_ (not equal to)\n/// `pos`, if `forward` is true, or before otherwise. Returns `pos`\n/// itself if no further cluster break is available in the string.\n/// Moves across surrogate pairs, extending characters, characters\n/// joined with zero-width joiners, and flag emoji.\n\nfunction findClusterBreak(str, pos, forward = true) {\n  return (forward ? nextClusterBreak : prevClusterBreak)(str, pos);\n}\n\nfunction nextClusterBreak(str, pos) {\n  if (pos == str.length) return pos; // If pos is in the middle of a surrogate pair, move to its start\n\n  if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1))) pos--;\n  let prev = codePointAt(str, pos);\n  pos += codePointSize(prev);\n\n  while (pos < str.length) {\n    let next = codePointAt(str, pos);\n\n    if (prev == ZWJ || next == ZWJ || isExtendingChar(next)) {\n      pos += codePointSize(next);\n      prev = next;\n    } else if (isRegionalIndicator(next)) {\n      let countBefore = 0,\n          i = pos - 2;\n\n      while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {\n        countBefore++;\n        i -= 2;\n      }\n\n      if (countBefore % 2 == 0) break;else pos += 2;\n    } else {\n      break;\n    }\n  }\n\n  return pos;\n}\n\nfunction prevClusterBreak(str, pos) {\n  while (pos > 0) {\n    let found = nextClusterBreak(str, pos - 2);\n    if (found < pos) return found;\n    pos--;\n  }\n\n  return 0;\n}\n\nfunction surrogateLow(ch) {\n  return ch >= 0xDC00 && ch < 0xE000;\n}\n\nfunction surrogateHigh(ch) {\n  return ch >= 0xD800 && ch < 0xDC00;\n} /// Find the code point at the given position in a string (like the\n/// [`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)\n/// string method).\n\n\nfunction codePointAt(str, pos) {\n  let code0 = str.charCodeAt(pos);\n  if (!surrogateHigh(code0) || pos + 1 == str.length) return code0;\n  let code1 = str.charCodeAt(pos + 1);\n  if (!surrogateLow(code1)) return code0;\n  return (code0 - 0xd800 << 10) + (code1 - 0xdc00) + 0x10000;\n} /// Given a Unicode codepoint, return the JavaScript string that\n/// respresents it (like\n/// [`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).\n\n\nfunction fromCodePoint(code) {\n  if (code <= 0xffff) return String.fromCharCode(code);\n  code -= 0x10000;\n  return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);\n} /// The first character that takes up two positions in a JavaScript\n/// string. It is often useful to compare with this after calling\n/// `codePointAt`, to figure out whether your character takes up 1 or\n/// 2 index positions.\n\n\nfunction codePointSize(code) {\n  return code < 0x10000 ? 1 : 2;\n} /// Count the column position at the given offset into the string,\n/// taking extending characters and tab size into account.\n\n\nfunction countColumn(string, n, tabSize) {\n  for (let i = 0; i < string.length;) {\n    if (string.charCodeAt(i) == 9) {\n      n += tabSize - n % tabSize;\n      i++;\n    } else {\n      n++;\n      i = findClusterBreak(string, i);\n    }\n  }\n\n  return n;\n} /// Find the offset that corresponds to the given column position in a\n/// string, taking extending characters and tab size into account.\n\n\nfunction findColumn(string, n, col, tabSize) {\n  for (let i = 0; i < string.length;) {\n    if (n >= col) return {\n      offset: i,\n      leftOver: 0\n    };\n    n += string.charCodeAt(i) == 9 ? tabSize - n % tabSize : 1;\n    i = findClusterBreak(string, i);\n  }\n\n  return {\n    offset: string.length,\n    leftOver: col - n\n  };\n} /// The data structure for documents.\n\n\nclass Text {\n  /// @internal\n  constructor() {} /// Get the line description around the given position.\n\n\n  lineAt(pos) {\n    if (pos < 0 || pos > this.length) throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);\n    return this.lineInner(pos, false, 1, 0);\n  } /// Get the description for the given (1-based) line number.\n\n\n  line(n) {\n    if (n < 1 || n > this.lines) throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);\n    return this.lineInner(n, true, 1, 0);\n  } /// Replace a range of the text with the given content.\n\n\n  replace(from, to, text) {\n    let parts = [];\n    this.decompose(0, from, parts, 2\n    /* To */\n    );\n    if (text.length) text.decompose(0, text.length, parts, 1\n    /* From */\n    | 2\n    /* To */\n    );\n    this.decompose(to, this.length, parts, 1\n    /* From */\n    );\n    return TextNode.from(parts, this.length - (to - from) + text.length);\n  } /// Append another document to this one.\n\n\n  append(other) {\n    return this.replace(this.length, this.length, other);\n  } /// Retrieve the text between the given points.\n\n\n  slice(from, to = this.length) {\n    let parts = [];\n    this.decompose(from, to, parts, 0);\n    return TextNode.from(parts, to - from);\n  } /// Test whether this text is equal to another instance.\n\n\n  eq(other) {\n    if (other == this) return true;\n    if (other.length != this.length || other.lines != this.lines) return false;\n    let a = new RawTextCursor(this),\n        b = new RawTextCursor(other);\n\n    for (;;) {\n      a.next();\n      b.next();\n      if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value) return false;\n      if (a.done) return true;\n    }\n  } /// Iterate over the text. When `dir` is `-1`, iteration happens\n  /// from end to start. This will return lines and the breaks between\n  /// them as separate strings, and for long lines, might split lines\n  /// themselves into multiple chunks as well.\n\n\n  iter(dir = 1) {\n    return new RawTextCursor(this, dir);\n  } /// Iterate over a range of the text. When `from` > `to`, the\n  /// iterator will run in reverse.\n\n\n  iterRange(from, to = this.length) {\n    return new PartialTextCursor(this, from, to);\n  } /// @internal\n\n\n  toString() {\n    return this.sliceString(0);\n  } /// Convert the document to an array of lines (which can be\n  /// deserialized again via [`Text.of`](#text.Text^of)).\n\n\n  toJSON() {\n    let lines = [];\n    this.flatten(lines);\n    return lines;\n  } /// Create a `Text` instance for the given array of lines.\n\n\n  static of(text) {\n    if (text.length == 0) throw new RangeError(\"A document must have at least one line\");\n    if (text.length == 1 && !text[0]) return Text.empty;\n    return text.length <= 32\n    /* Branch */\n    ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));\n  }\n\n}\n\nif (typeof Symbol != \"undefined\") Text.prototype[Symbol.iterator] = function () {\n  return this.iter();\n}; // Leaves store an array of line strings. There are always line breaks\n// between these strings. Leaves are limited in size and have to be\n// contained in TextNode instances for bigger documents.\n\nclass TextLeaf extends Text {\n  constructor(text, length = textLength(text)) {\n    super();\n    this.text = text;\n    this.length = length;\n  }\n\n  get lines() {\n    return this.text.length;\n  }\n\n  get children() {\n    return null;\n  }\n\n  lineInner(target, isLine, line, offset) {\n    for (let i = 0;; i++) {\n      let string = this.text[i],\n          end = offset + string.length;\n      if ((isLine ? line : end) >= target) return new Line(offset, end, line, string);\n      offset = end + 1;\n      line++;\n    }\n  }\n\n  decompose(from, to, target, open) {\n    let text = from <= 0 && to >= this.length ? this : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));\n\n    if (open & 1\n    /* From */\n    ) {\n        let prev = target.pop();\n        let joined = appendText(text.text, prev.text.slice(), 0, text.length);\n\n        if (joined.length <= 32\n        /* Branch */\n        ) {\n            target.push(new TextLeaf(joined, prev.length + text.length));\n          } else {\n          let mid = joined.length >> 1;\n          target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));\n        }\n      } else {\n      target.push(text);\n    }\n  }\n\n  replace(from, to, text) {\n    if (!(text instanceof TextLeaf)) return super.replace(from, to, text);\n    let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);\n    let newLen = this.length + text.length - (to - from);\n    if (lines.length <= 32\n    /* Branch */\n    ) return new TextLeaf(lines, newLen);\n    return TextNode.from(TextLeaf.split(lines, []), newLen);\n  }\n\n  sliceString(from, to = this.length, lineSep = \"\\n\") {\n    let result = \"\";\n\n    for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {\n      let line = this.text[i],\n          end = pos + line.length;\n      if (pos > from && i) result += lineSep;\n      if (from < end && to > pos) result += line.slice(Math.max(0, from - pos), to - pos);\n      pos = end + 1;\n    }\n\n    return result;\n  }\n\n  flatten(target) {\n    for (let line of this.text) target.push(line);\n  }\n\n  static split(text, target) {\n    let part = [],\n        len = -1;\n\n    for (let line of text) {\n      part.push(line);\n      len += line.length + 1;\n\n      if (part.length == 32\n      /* Branch */\n      ) {\n          target.push(new TextLeaf(part, len));\n          part = [];\n          len = -1;\n        }\n    }\n\n    if (len > -1) target.push(new TextLeaf(part, len));\n    return target;\n  }\n\n} // Nodes provide the tree structure of the `Text` type. They store a\n// number of other nodes or leaves, taking care to balance themselves\n// on changes. There are implied line breaks _between_ the children of\n// a node (but not before the first or after the last child).\n\n\nclass TextNode extends Text {\n  constructor(children, length) {\n    super();\n    this.children = children;\n    this.length = length;\n    this.lines = 0;\n\n    for (let child of children) this.lines += child.lines;\n  }\n\n  lineInner(target, isLine, line, offset) {\n    for (let i = 0;; i++) {\n      let child = this.children[i],\n          end = offset + child.length,\n          endLine = line + child.lines - 1;\n      if ((isLine ? endLine : end) >= target) return child.lineInner(target, isLine, line, offset);\n      offset = end + 1;\n      line = endLine + 1;\n    }\n  }\n\n  decompose(from, to, target, open) {\n    for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {\n      let child = this.children[i],\n          end = pos + child.length;\n\n      if (from <= end && to >= pos) {\n        let childOpen = open & ((pos <= from ? 1\n        /* From */\n        : 0) | (end >= to ? 2\n        /* To */\n        : 0));\n        if (pos >= from && end <= to && !childOpen) target.push(child);else child.decompose(from - pos, to - pos, target, childOpen);\n      }\n\n      pos = end + 1;\n    }\n  }\n\n  replace(from, to, text) {\n    if (text.lines < this.lines) for (let i = 0, pos = 0; i < this.children.length; i++) {\n      let child = this.children[i],\n          end = pos + child.length; // Fast path: if the change only affects one child and the\n      // child's size remains in the acceptable range, only update\n      // that child\n\n      if (from >= pos && to <= end) {\n        let updated = child.replace(from - pos, to - pos, text);\n        let totalLines = this.lines - child.lines + updated.lines;\n\n        if (updated.lines < totalLines >> 5\n        /* BranchShift */\n        - 1 && updated.lines > totalLines >> 5\n        /* BranchShift */\n        + 1) {\n          let copy = this.children.slice();\n          copy[i] = updated;\n          return new TextNode(copy, this.length - (to - from) + text.length);\n        }\n\n        return super.replace(pos, end, updated);\n      }\n\n      pos = end + 1;\n    }\n    return super.replace(from, to, text);\n  }\n\n  sliceString(from, to = this.length, lineSep = \"\\n\") {\n    let result = \"\";\n\n    for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {\n      let child = this.children[i],\n          end = pos + child.length;\n      if (pos > from && i) result += lineSep;\n      if (from < end && to > pos) result += child.sliceString(from - pos, to - pos, lineSep);\n      pos = end + 1;\n    }\n\n    return result;\n  }\n\n  flatten(target) {\n    for (let child of this.children) child.flatten(target);\n  }\n\n  static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {\n    let lines = 0;\n\n    for (let ch of children) lines += ch.lines;\n\n    if (lines < 32\n    /* Branch */\n    ) {\n        let flat = [];\n\n        for (let ch of children) ch.flatten(flat);\n\n        return new TextLeaf(flat, length);\n      }\n\n    let chunk = Math.max(32\n    /* Branch */\n    , lines >> 5\n    /* BranchShift */\n    ),\n        maxChunk = chunk << 1,\n        minChunk = chunk >> 1;\n    let chunked = [],\n        currentLines = 0,\n        currentLen = -1,\n        currentChunk = [];\n\n    function add(child) {\n      let last;\n\n      if (child.lines > maxChunk && child instanceof TextNode) {\n        for (let node of child.children) add(node);\n      } else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {\n        flush();\n        chunked.push(child);\n      } else if (child instanceof TextLeaf && currentLines && (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf && child.lines + last.lines <= 32\n      /* Branch */\n      ) {\n          currentLines += child.lines;\n          currentLen += child.length + 1;\n          currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);\n        } else {\n        if (currentLines + child.lines > chunk) flush();\n        currentLines += child.lines;\n        currentLen += child.length + 1;\n        currentChunk.push(child);\n      }\n    }\n\n    function flush() {\n      if (currentLines == 0) return;\n      chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));\n      currentLen = -1;\n      currentLines = currentChunk.length = 0;\n    }\n\n    for (let child of children) add(child);\n\n    flush();\n    return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);\n  }\n\n}\n\nText.empty = new TextLeaf([\"\"], 0);\n\nfunction textLength(text) {\n  let length = -1;\n\n  for (let line of text) length += line.length + 1;\n\n  return length;\n}\n\nfunction appendText(text, target, from = 0, to = 1e9) {\n  for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {\n    let line = text[i],\n        end = pos + line.length;\n\n    if (end >= from) {\n      if (end > to) line = line.slice(0, to - pos);\n      if (pos < from) line = line.slice(from - pos);\n\n      if (first) {\n        target[target.length - 1] += line;\n        first = false;\n      } else target.push(line);\n    }\n\n    pos = end + 1;\n  }\n\n  return target;\n}\n\nfunction sliceText(text, from, to) {\n  return appendText(text, [\"\"], from, to);\n}\n\nclass RawTextCursor {\n  constructor(text, dir = 1) {\n    this.dir = dir;\n    this.done = false;\n    this.lineBreak = false;\n    this.value = \"\";\n    this.nodes = [text];\n    this.offsets = [dir > 0 ? 0 : text instanceof TextLeaf ? text.text.length : text.children.length];\n  }\n\n  next(skip = 0) {\n    for (;;) {\n      let last = this.nodes.length - 1;\n\n      if (last < 0) {\n        this.done = true;\n        this.value = \"\";\n        this.lineBreak = false;\n        return this;\n      }\n\n      let top = this.nodes[last],\n          offset = this.offsets[last];\n      let size = top instanceof TextLeaf ? top.text.length : top.children.length;\n\n      if (offset == (this.dir > 0 ? size : 0)) {\n        this.nodes.pop();\n        this.offsets.pop();\n      } else if (!this.lineBreak && offset != (this.dir > 0 ? 0 : size)) {\n        // Internal offset with lineBreak == false means we have to\n        // count the line break at this position\n        this.lineBreak = true;\n\n        if (skip == 0) {\n          this.value = \"\\n\";\n          return this;\n        }\n\n        skip--;\n      } else if (top instanceof TextLeaf) {\n        // Move to the next string\n        let next = top.text[offset - (this.dir < 0 ? 1 : 0)];\n        this.offsets[last] = offset += this.dir;\n        this.lineBreak = false;\n\n        if (next.length > Math.max(0, skip)) {\n          this.value = skip == 0 ? next : this.dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);\n          return this;\n        }\n\n        skip -= next.length;\n      } else {\n        let next = top.children[this.dir > 0 ? offset : offset - 1];\n        this.offsets[last] = offset + this.dir;\n        this.lineBreak = false;\n\n        if (skip > next.length) {\n          skip -= next.length;\n        } else {\n          this.nodes.push(next);\n          this.offsets.push(this.dir > 0 ? 0 : next instanceof TextLeaf ? next.text.length : next.children.length);\n        }\n      }\n    }\n  }\n\n}\n\nclass PartialTextCursor {\n  constructor(text, start, end) {\n    this.value = \"\";\n    this.cursor = new RawTextCursor(text, start > end ? -1 : 1);\n\n    if (start > end) {\n      this.skip = text.length - start;\n      this.limit = start - end;\n    } else {\n      this.skip = start;\n      this.limit = end - start;\n    }\n  }\n\n  next(skip = 0) {\n    if (this.limit <= 0) {\n      this.limit = -1;\n    } else {\n      let {\n        value,\n        lineBreak,\n        done\n      } = this.cursor.next(this.skip + skip);\n      this.skip = 0;\n      this.value = value;\n      let len = lineBreak ? 1 : value.length;\n      if (len > this.limit) this.value = this.cursor.dir > 0 ? value.slice(0, this.limit) : value.slice(len - this.limit);\n      if (done || this.value.length == 0) this.limit = -1;else this.limit -= this.value.length;\n    }\n\n    return this;\n  }\n\n  get lineBreak() {\n    return this.cursor.lineBreak;\n  }\n\n  get done() {\n    return this.limit < 0;\n  }\n\n} /// This type describes a line in the document. It is created\n/// on-demand when lines are [queried](#text.Text.lineAt).\n\n\nclass Line {\n  /// @internal\n  constructor( /// The position of the start of the line.\n  from, /// The position at the end of the line (_before_ the line break,\n  /// or at the end of document for the last line).\n  to, /// This line's line number (1-based).\n  number, /// The line's content.\n  text) {\n    this.from = from;\n    this.to = to;\n    this.number = number;\n    this.text = text;\n  } /// The length of the line (not including any line break after it).\n\n\n  get length() {\n    return this.to - this.from;\n  }\n\n}\n\nexport { Line, Text, codePointAt, codePointSize, countColumn, findClusterBreak, findColumn, fromCodePoint };","map":{"version":3,"sources":["D:/MSIT/Practicum - iLMS/editor-codemirror6/node_modules/@codemirror/text/dist/index.js"],"names":["extend","split","map","s","parseInt","i","length","isExtendingChar","code","isRegionalIndicator","ZWJ","findClusterBreak","str","pos","forward","nextClusterBreak","prevClusterBreak","surrogateLow","charCodeAt","surrogateHigh","prev","codePointAt","codePointSize","next","countBefore","found","ch","code0","code1","fromCodePoint","String","fromCharCode","countColumn","string","n","tabSize","findColumn","col","offset","leftOver","Text","constructor","lineAt","RangeError","lineInner","line","lines","replace","from","to","text","parts","decompose","TextNode","append","other","slice","eq","a","RawTextCursor","b","lineBreak","done","value","iter","dir","iterRange","PartialTextCursor","toString","sliceString","toJSON","flatten","of","empty","TextLeaf","Symbol","prototype","iterator","textLength","children","target","isLine","end","Line","open","sliceText","Math","min","max","pop","joined","appendText","push","mid","newLen","lineSep","result","part","len","child","endLine","childOpen","updated","totalLines","copy","reduce","l","flat","chunk","maxChunk","minChunk","chunked","currentLines","currentLen","currentChunk","add","last","node","flush","concat","first","nodes","offsets","skip","top","size","start","cursor","limit","number"],"mappings":"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","sourcesContent":["// Compressed representation of the Grapheme_Cluster_Break=Extend\n// information from\n// http://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakProperty.txt.\n// Each pair of elements represents a range, as an offet from the\n// previous range and a length. Numbers are in base-36, with the empty\n// string being a shorthand for 1.\nlet extend = \"lc,34,7n,7,7b,19,,,,2,,2,,,20,b,1c,l,g,,2t,7,2,6,2,2,,4,z,,u,r,2j,b,1m,9,9,,o,4,,9,,3,,5,17,3,3b,f,,w,1j,,,,4,8,4,,3,7,a,2,t,,1m,,,,2,4,8,,9,,a,2,q,,2,2,1l,,4,2,4,2,2,3,3,,u,2,3,,b,2,1l,,4,5,,2,4,,k,2,m,6,,,1m,,,2,,4,8,,7,3,a,2,u,,1n,,,,c,,9,,14,,3,,1l,3,5,3,,4,7,2,b,2,t,,1m,,2,,2,,3,,5,2,7,2,b,2,s,2,1l,2,,,2,4,8,,9,,a,2,t,,20,,4,,2,3,,,8,,29,,2,7,c,8,2q,,2,9,b,6,22,2,r,,,,,,1j,e,,5,,2,5,b,,10,9,,2u,4,,6,,2,2,2,p,2,4,3,g,4,d,,2,2,6,,f,,jj,3,qa,3,t,3,t,2,u,2,1s,2,,7,8,,2,b,9,,19,3,3b,2,y,,3a,3,4,2,9,,6,3,63,2,2,,1m,,,7,,,,,2,8,6,a,2,,1c,h,1r,4,1c,7,,,5,,14,9,c,2,w,4,2,2,,3,1k,,,2,3,,,3,1m,8,2,2,48,3,,d,,7,4,,6,,3,2,5i,1m,,5,ek,,5f,x,2da,3,3x,,2o,w,fe,6,2x,2,n9w,4,,a,w,2,28,2,7k,,3,,4,,p,2,5,,47,2,q,i,d,,12,8,p,b,1a,3,1c,,2,4,2,2,13,,1v,6,2,2,2,2,c,,8,,1b,,1f,,,3,2,2,5,2,,,16,2,8,,6m,,2,,4,,fn4,,kh,g,g,g,a6,2,gt,,6a,,45,5,1ae,3,,2,5,4,14,3,4,,4l,2,fx,4,ar,2,49,b,4w,,1i,f,1k,3,1d,4,2,2,1x,3,10,5,,8,1q,,c,2,1g,9,a,4,2,,2n,3,2,,,2,6,,4g,,3,8,l,2,1l,2,,,,,m,,e,7,3,5,5f,8,2,3,,,n,,29,,2,6,,,2,,,2,,2,6j,,2,4,6,2,,2,r,2,2d,8,2,,,2,2y,,,,2,6,,,2t,3,2,4,,5,77,9,,2,6t,,a,2,,,4,,40,4,2,2,4,,w,a,14,6,2,4,8,,9,6,2,3,1a,d,,2,ba,7,,6,,,2a,m,2,7,,2,,2,3e,6,3,,,2,,7,,,20,2,3,,,,9n,2,f0b,5,1n,7,t4,,1r,4,29,,f5k,2,43q,,,3,4,5,8,8,2,7,u,4,44,3,1iz,1j,4,1e,8,,e,,m,5,,f,11s,7,,h,2,7,,2,,5,79,7,c5,4,15s,7,31,7,240,5,gx7k,2o,3k,6o\".split(\",\").map(s => s ? parseInt(s, 36) : 1);\n// Convert offsets into absolute values\nfor (let i = 1; i < extend.length; i++)\n    extend[i] += extend[i - 1];\nfunction isExtendingChar(code) {\n    for (let i = 1; i < extend.length; i += 2)\n        if (extend[i] > code)\n            return extend[i - 1] <= code;\n    return false;\n}\nfunction isRegionalIndicator(code) {\n    return code >= 0x1F1E6 && code <= 0x1F1FF;\n}\nconst ZWJ = 0x200d;\n/// Returns a next grapheme cluster break _after_ (not equal to)\n/// `pos`, if `forward` is true, or before otherwise. Returns `pos`\n/// itself if no further cluster break is available in the string.\n/// Moves across surrogate pairs, extending characters, characters\n/// joined with zero-width joiners, and flag emoji.\nfunction findClusterBreak(str, pos, forward = true) {\n    return (forward ? nextClusterBreak : prevClusterBreak)(str, pos);\n}\nfunction nextClusterBreak(str, pos) {\n    if (pos == str.length)\n        return pos;\n    // If pos is in the middle of a surrogate pair, move to its start\n    if (pos && surrogateLow(str.charCodeAt(pos)) && surrogateHigh(str.charCodeAt(pos - 1)))\n        pos--;\n    let prev = codePointAt(str, pos);\n    pos += codePointSize(prev);\n    while (pos < str.length) {\n        let next = codePointAt(str, pos);\n        if (prev == ZWJ || next == ZWJ || isExtendingChar(next)) {\n            pos += codePointSize(next);\n            prev = next;\n        }\n        else if (isRegionalIndicator(next)) {\n            let countBefore = 0, i = pos - 2;\n            while (i >= 0 && isRegionalIndicator(codePointAt(str, i))) {\n                countBefore++;\n                i -= 2;\n            }\n            if (countBefore % 2 == 0)\n                break;\n            else\n                pos += 2;\n        }\n        else {\n            break;\n        }\n    }\n    return pos;\n}\nfunction prevClusterBreak(str, pos) {\n    while (pos > 0) {\n        let found = nextClusterBreak(str, pos - 2);\n        if (found < pos)\n            return found;\n        pos--;\n    }\n    return 0;\n}\nfunction surrogateLow(ch) { return ch >= 0xDC00 && ch < 0xE000; }\nfunction surrogateHigh(ch) { return ch >= 0xD800 && ch < 0xDC00; }\n/// Find the code point at the given position in a string (like the\n/// [`codePointAt`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/codePointAt)\n/// string method).\nfunction codePointAt(str, pos) {\n    let code0 = str.charCodeAt(pos);\n    if (!surrogateHigh(code0) || pos + 1 == str.length)\n        return code0;\n    let code1 = str.charCodeAt(pos + 1);\n    if (!surrogateLow(code1))\n        return code0;\n    return ((code0 - 0xd800) << 10) + (code1 - 0xdc00) + 0x10000;\n}\n/// Given a Unicode codepoint, return the JavaScript string that\n/// respresents it (like\n/// [`String.fromCodePoint`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/fromCodePoint)).\nfunction fromCodePoint(code) {\n    if (code <= 0xffff)\n        return String.fromCharCode(code);\n    code -= 0x10000;\n    return String.fromCharCode((code >> 10) + 0xd800, (code & 1023) + 0xdc00);\n}\n/// The first character that takes up two positions in a JavaScript\n/// string. It is often useful to compare with this after calling\n/// `codePointAt`, to figure out whether your character takes up 1 or\n/// 2 index positions.\nfunction codePointSize(code) { return code < 0x10000 ? 1 : 2; }\n\n/// Count the column position at the given offset into the string,\n/// taking extending characters and tab size into account.\nfunction countColumn(string, n, tabSize) {\n    for (let i = 0; i < string.length;) {\n        if (string.charCodeAt(i) == 9) {\n            n += tabSize - (n % tabSize);\n            i++;\n        }\n        else {\n            n++;\n            i = findClusterBreak(string, i);\n        }\n    }\n    return n;\n}\n/// Find the offset that corresponds to the given column position in a\n/// string, taking extending characters and tab size into account.\nfunction findColumn(string, n, col, tabSize) {\n    for (let i = 0; i < string.length;) {\n        if (n >= col)\n            return { offset: i, leftOver: 0 };\n        n += string.charCodeAt(i) == 9 ? tabSize - (n % tabSize) : 1;\n        i = findClusterBreak(string, i);\n    }\n    return { offset: string.length, leftOver: col - n };\n}\n\n/// The data structure for documents.\nclass Text {\n    /// @internal\n    constructor() { }\n    /// Get the line description around the given position.\n    lineAt(pos) {\n        if (pos < 0 || pos > this.length)\n            throw new RangeError(`Invalid position ${pos} in document of length ${this.length}`);\n        return this.lineInner(pos, false, 1, 0);\n    }\n    /// Get the description for the given (1-based) line number.\n    line(n) {\n        if (n < 1 || n > this.lines)\n            throw new RangeError(`Invalid line number ${n} in ${this.lines}-line document`);\n        return this.lineInner(n, true, 1, 0);\n    }\n    /// Replace a range of the text with the given content.\n    replace(from, to, text) {\n        let parts = [];\n        this.decompose(0, from, parts, 2 /* To */);\n        if (text.length)\n            text.decompose(0, text.length, parts, 1 /* From */ | 2 /* To */);\n        this.decompose(to, this.length, parts, 1 /* From */);\n        return TextNode.from(parts, this.length - (to - from) + text.length);\n    }\n    /// Append another document to this one.\n    append(other) {\n        return this.replace(this.length, this.length, other);\n    }\n    /// Retrieve the text between the given points.\n    slice(from, to = this.length) {\n        let parts = [];\n        this.decompose(from, to, parts, 0);\n        return TextNode.from(parts, to - from);\n    }\n    /// Test whether this text is equal to another instance.\n    eq(other) {\n        if (other == this)\n            return true;\n        if (other.length != this.length || other.lines != this.lines)\n            return false;\n        let a = new RawTextCursor(this), b = new RawTextCursor(other);\n        for (;;) {\n            a.next();\n            b.next();\n            if (a.lineBreak != b.lineBreak || a.done != b.done || a.value != b.value)\n                return false;\n            if (a.done)\n                return true;\n        }\n    }\n    /// Iterate over the text. When `dir` is `-1`, iteration happens\n    /// from end to start. This will return lines and the breaks between\n    /// them as separate strings, and for long lines, might split lines\n    /// themselves into multiple chunks as well.\n    iter(dir = 1) { return new RawTextCursor(this, dir); }\n    /// Iterate over a range of the text. When `from` > `to`, the\n    /// iterator will run in reverse.\n    iterRange(from, to = this.length) { return new PartialTextCursor(this, from, to); }\n    /// @internal\n    toString() { return this.sliceString(0); }\n    /// Convert the document to an array of lines (which can be\n    /// deserialized again via [`Text.of`](#text.Text^of)).\n    toJSON() {\n        let lines = [];\n        this.flatten(lines);\n        return lines;\n    }\n    /// Create a `Text` instance for the given array of lines.\n    static of(text) {\n        if (text.length == 0)\n            throw new RangeError(\"A document must have at least one line\");\n        if (text.length == 1 && !text[0])\n            return Text.empty;\n        return text.length <= 32 /* Branch */ ? new TextLeaf(text) : TextNode.from(TextLeaf.split(text, []));\n    }\n}\nif (typeof Symbol != \"undefined\")\n    Text.prototype[Symbol.iterator] = function () { return this.iter(); };\n// Leaves store an array of line strings. There are always line breaks\n// between these strings. Leaves are limited in size and have to be\n// contained in TextNode instances for bigger documents.\nclass TextLeaf extends Text {\n    constructor(text, length = textLength(text)) {\n        super();\n        this.text = text;\n        this.length = length;\n    }\n    get lines() { return this.text.length; }\n    get children() { return null; }\n    lineInner(target, isLine, line, offset) {\n        for (let i = 0;; i++) {\n            let string = this.text[i], end = offset + string.length;\n            if ((isLine ? line : end) >= target)\n                return new Line(offset, end, line, string);\n            offset = end + 1;\n            line++;\n        }\n    }\n    decompose(from, to, target, open) {\n        let text = from <= 0 && to >= this.length ? this\n            : new TextLeaf(sliceText(this.text, from, to), Math.min(to, this.length) - Math.max(0, from));\n        if (open & 1 /* From */) {\n            let prev = target.pop();\n            let joined = appendText(text.text, prev.text.slice(), 0, text.length);\n            if (joined.length <= 32 /* Branch */) {\n                target.push(new TextLeaf(joined, prev.length + text.length));\n            }\n            else {\n                let mid = joined.length >> 1;\n                target.push(new TextLeaf(joined.slice(0, mid)), new TextLeaf(joined.slice(mid)));\n            }\n        }\n        else {\n            target.push(text);\n        }\n    }\n    replace(from, to, text) {\n        if (!(text instanceof TextLeaf))\n            return super.replace(from, to, text);\n        let lines = appendText(this.text, appendText(text.text, sliceText(this.text, 0, from)), to);\n        let newLen = this.length + text.length - (to - from);\n        if (lines.length <= 32 /* Branch */)\n            return new TextLeaf(lines, newLen);\n        return TextNode.from(TextLeaf.split(lines, []), newLen);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        let result = \"\";\n        for (let pos = 0, i = 0; pos <= to && i < this.text.length; i++) {\n            let line = this.text[i], end = pos + line.length;\n            if (pos > from && i)\n                result += lineSep;\n            if (from < end && to > pos)\n                result += line.slice(Math.max(0, from - pos), to - pos);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let line of this.text)\n            target.push(line);\n    }\n    static split(text, target) {\n        let part = [], len = -1;\n        for (let line of text) {\n            part.push(line);\n            len += line.length + 1;\n            if (part.length == 32 /* Branch */) {\n                target.push(new TextLeaf(part, len));\n                part = [];\n                len = -1;\n            }\n        }\n        if (len > -1)\n            target.push(new TextLeaf(part, len));\n        return target;\n    }\n}\n// Nodes provide the tree structure of the `Text` type. They store a\n// number of other nodes or leaves, taking care to balance themselves\n// on changes. There are implied line breaks _between_ the children of\n// a node (but not before the first or after the last child).\nclass TextNode extends Text {\n    constructor(children, length) {\n        super();\n        this.children = children;\n        this.length = length;\n        this.lines = 0;\n        for (let child of children)\n            this.lines += child.lines;\n    }\n    lineInner(target, isLine, line, offset) {\n        for (let i = 0;; i++) {\n            let child = this.children[i], end = offset + child.length, endLine = line + child.lines - 1;\n            if ((isLine ? endLine : end) >= target)\n                return child.lineInner(target, isLine, line, offset);\n            offset = end + 1;\n            line = endLine + 1;\n        }\n    }\n    decompose(from, to, target, open) {\n        for (let i = 0, pos = 0; pos <= to && i < this.children.length; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (from <= end && to >= pos) {\n                let childOpen = open & ((pos <= from ? 1 /* From */ : 0) | (end >= to ? 2 /* To */ : 0));\n                if (pos >= from && end <= to && !childOpen)\n                    target.push(child);\n                else\n                    child.decompose(from - pos, to - pos, target, childOpen);\n            }\n            pos = end + 1;\n        }\n    }\n    replace(from, to, text) {\n        if (text.lines < this.lines)\n            for (let i = 0, pos = 0; i < this.children.length; i++) {\n                let child = this.children[i], end = pos + child.length;\n                // Fast path: if the change only affects one child and the\n                // child's size remains in the acceptable range, only update\n                // that child\n                if (from >= pos && to <= end) {\n                    let updated = child.replace(from - pos, to - pos, text);\n                    let totalLines = this.lines - child.lines + updated.lines;\n                    if (updated.lines < (totalLines >> (5 /* BranchShift */ - 1)) &&\n                        updated.lines > (totalLines >> (5 /* BranchShift */ + 1))) {\n                        let copy = this.children.slice();\n                        copy[i] = updated;\n                        return new TextNode(copy, this.length - (to - from) + text.length);\n                    }\n                    return super.replace(pos, end, updated);\n                }\n                pos = end + 1;\n            }\n        return super.replace(from, to, text);\n    }\n    sliceString(from, to = this.length, lineSep = \"\\n\") {\n        let result = \"\";\n        for (let i = 0, pos = 0; i < this.children.length && pos <= to; i++) {\n            let child = this.children[i], end = pos + child.length;\n            if (pos > from && i)\n                result += lineSep;\n            if (from < end && to > pos)\n                result += child.sliceString(from - pos, to - pos, lineSep);\n            pos = end + 1;\n        }\n        return result;\n    }\n    flatten(target) {\n        for (let child of this.children)\n            child.flatten(target);\n    }\n    static from(children, length = children.reduce((l, ch) => l + ch.length + 1, -1)) {\n        let lines = 0;\n        for (let ch of children)\n            lines += ch.lines;\n        if (lines < 32 /* Branch */) {\n            let flat = [];\n            for (let ch of children)\n                ch.flatten(flat);\n            return new TextLeaf(flat, length);\n        }\n        let chunk = Math.max(32 /* Branch */, lines >> 5 /* BranchShift */), maxChunk = chunk << 1, minChunk = chunk >> 1;\n        let chunked = [], currentLines = 0, currentLen = -1, currentChunk = [];\n        function add(child) {\n            let last;\n            if (child.lines > maxChunk && child instanceof TextNode) {\n                for (let node of child.children)\n                    add(node);\n            }\n            else if (child.lines > minChunk && (currentLines > minChunk || !currentLines)) {\n                flush();\n                chunked.push(child);\n            }\n            else if (child instanceof TextLeaf && currentLines &&\n                (last = currentChunk[currentChunk.length - 1]) instanceof TextLeaf &&\n                child.lines + last.lines <= 32 /* Branch */) {\n                currentLines += child.lines;\n                currentLen += child.length + 1;\n                currentChunk[currentChunk.length - 1] = new TextLeaf(last.text.concat(child.text), last.length + 1 + child.length);\n            }\n            else {\n                if (currentLines + child.lines > chunk)\n                    flush();\n                currentLines += child.lines;\n                currentLen += child.length + 1;\n                currentChunk.push(child);\n            }\n        }\n        function flush() {\n            if (currentLines == 0)\n                return;\n            chunked.push(currentChunk.length == 1 ? currentChunk[0] : TextNode.from(currentChunk, currentLen));\n            currentLen = -1;\n            currentLines = currentChunk.length = 0;\n        }\n        for (let child of children)\n            add(child);\n        flush();\n        return chunked.length == 1 ? chunked[0] : new TextNode(chunked, length);\n    }\n}\nText.empty = new TextLeaf([\"\"], 0);\nfunction textLength(text) {\n    let length = -1;\n    for (let line of text)\n        length += line.length + 1;\n    return length;\n}\nfunction appendText(text, target, from = 0, to = 1e9) {\n    for (let pos = 0, i = 0, first = true; i < text.length && pos <= to; i++) {\n        let line = text[i], end = pos + line.length;\n        if (end >= from) {\n            if (end > to)\n                line = line.slice(0, to - pos);\n            if (pos < from)\n                line = line.slice(from - pos);\n            if (first) {\n                target[target.length - 1] += line;\n                first = false;\n            }\n            else\n                target.push(line);\n        }\n        pos = end + 1;\n    }\n    return target;\n}\nfunction sliceText(text, from, to) {\n    return appendText(text, [\"\"], from, to);\n}\nclass RawTextCursor {\n    constructor(text, dir = 1) {\n        this.dir = dir;\n        this.done = false;\n        this.lineBreak = false;\n        this.value = \"\";\n        this.nodes = [text];\n        this.offsets = [dir > 0 ? 0 : text instanceof TextLeaf ? text.text.length : text.children.length];\n    }\n    next(skip = 0) {\n        for (;;) {\n            let last = this.nodes.length - 1;\n            if (last < 0) {\n                this.done = true;\n                this.value = \"\";\n                this.lineBreak = false;\n                return this;\n            }\n            let top = this.nodes[last], offset = this.offsets[last];\n            let size = top instanceof TextLeaf ? top.text.length : top.children.length;\n            if (offset == (this.dir > 0 ? size : 0)) {\n                this.nodes.pop();\n                this.offsets.pop();\n            }\n            else if (!this.lineBreak && offset != (this.dir > 0 ? 0 : size)) {\n                // Internal offset with lineBreak == false means we have to\n                // count the line break at this position\n                this.lineBreak = true;\n                if (skip == 0) {\n                    this.value = \"\\n\";\n                    return this;\n                }\n                skip--;\n            }\n            else if (top instanceof TextLeaf) {\n                // Move to the next string\n                let next = top.text[offset - (this.dir < 0 ? 1 : 0)];\n                this.offsets[last] = (offset += this.dir);\n                this.lineBreak = false;\n                if (next.length > Math.max(0, skip)) {\n                    this.value = skip == 0 ? next : this.dir > 0 ? next.slice(skip) : next.slice(0, next.length - skip);\n                    return this;\n                }\n                skip -= next.length;\n            }\n            else {\n                let next = top.children[this.dir > 0 ? offset : offset - 1];\n                this.offsets[last] = offset + this.dir;\n                this.lineBreak = false;\n                if (skip > next.length) {\n                    skip -= next.length;\n                }\n                else {\n                    this.nodes.push(next);\n                    this.offsets.push(this.dir > 0 ? 0 : next instanceof TextLeaf ? next.text.length : next.children.length);\n                }\n            }\n        }\n    }\n}\nclass PartialTextCursor {\n    constructor(text, start, end) {\n        this.value = \"\";\n        this.cursor = new RawTextCursor(text, start > end ? -1 : 1);\n        if (start > end) {\n            this.skip = text.length - start;\n            this.limit = start - end;\n        }\n        else {\n            this.skip = start;\n            this.limit = end - start;\n        }\n    }\n    next(skip = 0) {\n        if (this.limit <= 0) {\n            this.limit = -1;\n        }\n        else {\n            let { value, lineBreak, done } = this.cursor.next(this.skip + skip);\n            this.skip = 0;\n            this.value = value;\n            let len = lineBreak ? 1 : value.length;\n            if (len > this.limit)\n                this.value = this.cursor.dir > 0 ? value.slice(0, this.limit) : value.slice(len - this.limit);\n            if (done || this.value.length == 0)\n                this.limit = -1;\n            else\n                this.limit -= this.value.length;\n        }\n        return this;\n    }\n    get lineBreak() { return this.cursor.lineBreak; }\n    get done() { return this.limit < 0; }\n}\n/// This type describes a line in the document. It is created\n/// on-demand when lines are [queried](#text.Text.lineAt).\nclass Line {\n    /// @internal\n    constructor(\n    /// The position of the start of the line.\n    from, \n    /// The position at the end of the line (_before_ the line break,\n    /// or at the end of document for the last line).\n    to, \n    /// This line's line number (1-based).\n    number, \n    /// The line's content.\n    text) {\n        this.from = from;\n        this.to = to;\n        this.number = number;\n        this.text = text;\n    }\n    /// The length of the line (not including any line break after it).\n    get length() { return this.to - this.from; }\n}\n\nexport { Line, Text, codePointAt, codePointSize, countColumn, findClusterBreak, findColumn, fromCodePoint };\n"]},"metadata":{},"sourceType":"module"}