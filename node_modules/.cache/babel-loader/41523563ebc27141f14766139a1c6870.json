{"ast":null,"code":"import { MapMode } from '@codemirror/state';\n/**\nEach range is associated with a value, which must inherit from\nthis class.\n*/\n\nclass RangeValue {\n  /**\n  Compare this value with another value. The default\n  implementation compares by identity.\n  */\n  eq(other) {\n    return this == other;\n  }\n  /**\n  Create a [range](https://codemirror.net/6/docs/ref/#rangeset.Range) with this value.\n  */\n\n\n  range(from, to = from) {\n    return new Range(from, to, this);\n  }\n\n}\n\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = MapMode.TrackDel;\n/**\nA range associates a value with a range of positions.\n*/\n\nclass Range {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  The range's start position.\n  */\n  from,\n  /**\n  Its end position.\n  */\n  to,\n  /**\n  The value associated with this range.\n  */\n  value) {\n    this.from = from;\n    this.to = to;\n    this.value = value;\n  }\n\n}\n\nfunction cmpRange(a, b) {\n  return a.from - b.from || a.value.startSide - b.value.startSide;\n}\n\nclass Chunk {\n  constructor(from, to, value, // Chunks are marked with the largest point that occurs\n  // in them (or -1 for no points), so that scans that are\n  // only interested in points (such as the\n  // heightmap-related logic) can skip range-only chunks.\n  maxPoint) {\n    this.from = from;\n    this.to = to;\n    this.value = value;\n    this.maxPoint = maxPoint;\n  }\n\n  get length() {\n    return this.to[this.to.length - 1];\n  } // With side == -1, return the first index where to >= pos. When\n  // side == 1, the first index where from > pos.\n\n\n  findIndex(pos, end, side = end * 1000000000\n  /* Far */\n  , startAt = 0) {\n    if (pos <= 0) return startAt;\n    let arr = end < 0 ? this.to : this.from;\n\n    for (let lo = startAt, hi = arr.length;;) {\n      if (lo == hi) return lo;\n      let mid = lo + hi >> 1;\n      let diff = arr[mid] - pos || (end < 0 ? this.value[mid].startSide : this.value[mid].endSide) - side;\n      if (mid == lo) return diff >= 0 ? lo : hi;\n      if (diff >= 0) hi = mid;else lo = mid + 1;\n    }\n  }\n\n  between(offset, from, to, f) {\n    for (let i = this.findIndex(from, -1), e = this.findIndex(to, 1, undefined, i); i < e; i++) if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false) return false;\n  }\n\n  map(offset, changes) {\n    let value = [],\n        from = [],\n        to = [],\n        newPos = -1,\n        maxPoint = -1;\n\n    for (let i = 0; i < this.value.length; i++) {\n      let val = this.value[i],\n          curFrom = this.from[i] + offset,\n          curTo = this.to[i] + offset,\n          newFrom,\n          newTo;\n\n      if (curFrom == curTo) {\n        let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n        if (mapped == null) continue;\n        newFrom = newTo = mapped;\n      } else {\n        newFrom = changes.mapPos(curFrom, val.startSide);\n        newTo = changes.mapPos(curTo, val.endSide);\n        if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0) continue;\n      }\n\n      if ((newTo - newFrom || val.endSide - val.startSide) < 0) continue;\n      if (newPos < 0) newPos = newFrom;\n      if (val.point) maxPoint = Math.max(maxPoint, newTo - newFrom);\n      value.push(val);\n      from.push(newFrom - newPos);\n      to.push(newTo - newPos);\n    }\n\n    return {\n      mapped: value.length ? new Chunk(from, to, value, maxPoint) : null,\n      pos: newPos\n    };\n  }\n\n}\n/**\nA range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#rangeset.Range) in a\nway that makes them efficient to [map](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.map) and\n[update](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.update). This is an immutable data\nstructure.\n*/\n\n\nclass RangeSet {\n  /**\n  @internal\n  */\n  constructor(\n  /**\n  @internal\n  */\n  chunkPos,\n  /**\n  @internal\n  */\n  chunk,\n  /**\n  @internal\n  */\n  nextLayer = RangeSet.empty,\n  /**\n  @internal\n  */\n  maxPoint) {\n    this.chunkPos = chunkPos;\n    this.chunk = chunk;\n    this.nextLayer = nextLayer;\n    this.maxPoint = maxPoint;\n  }\n  /**\n  @internal\n  */\n\n\n  get length() {\n    let last = this.chunk.length - 1;\n    return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n  }\n  /**\n  The number of ranges in the set.\n  */\n\n\n  get size() {\n    if (this == RangeSet.empty) return 0;\n    let size = this.nextLayer.size;\n\n    for (let chunk of this.chunk) size += chunk.value.length;\n\n    return size;\n  }\n  /**\n  @internal\n  */\n\n\n  chunkEnd(index) {\n    return this.chunkPos[index] + this.chunk[index].length;\n  }\n  /**\n  Update the range set, optionally adding new ranges or filtering\n  out existing ones.\n  \n  (The extra type parameter is just there as a kludge to work\n  around TypeScript variance issues that prevented `RangeSet<X>`\n  from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n  `Y`.)\n  */\n\n\n  update(updateSpec) {\n    let {\n      add = [],\n      sort = false,\n      filterFrom = 0,\n      filterTo = this.length\n    } = updateSpec;\n    let filter = updateSpec.filter;\n    if (add.length == 0 && !filter) return this;\n    if (sort) add.slice().sort(cmpRange);\n    if (this == RangeSet.empty) return add.length ? RangeSet.of(add) : this;\n    let cur = new LayerCursor(this, null, -1).goto(0),\n        i = 0,\n        spill = [];\n    let builder = new RangeSetBuilder();\n\n    while (cur.value || i < add.length) {\n      if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n        let range = add[i++];\n        if (!builder.addInner(range.from, range.to, range.value)) spill.push(range);\n      } else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length && (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) && (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) && builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n        cur.nextChunk();\n      } else {\n        if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n          if (!builder.addInner(cur.from, cur.to, cur.value)) spill.push(new Range(cur.from, cur.to, cur.value));\n        }\n\n        cur.next();\n      }\n    }\n\n    return builder.finishInner(this.nextLayer == RangeSet.empty && !spill.length ? RangeSet.empty : this.nextLayer.update({\n      add: spill,\n      filter,\n      filterFrom,\n      filterTo\n    }));\n  }\n  /**\n  Map this range set through a set of changes, return the new set.\n  */\n\n\n  map(changes) {\n    if (changes.length == 0 || this == RangeSet.empty) return this;\n    let chunks = [],\n        chunkPos = [],\n        maxPoint = -1;\n\n    for (let i = 0; i < this.chunk.length; i++) {\n      let start = this.chunkPos[i],\n          chunk = this.chunk[i];\n      let touch = changes.touchesRange(start, start + chunk.length);\n\n      if (touch === false) {\n        maxPoint = Math.max(maxPoint, chunk.maxPoint);\n        chunks.push(chunk);\n        chunkPos.push(changes.mapPos(start));\n      } else if (touch === true) {\n        let {\n          mapped,\n          pos\n        } = chunk.map(start, changes);\n\n        if (mapped) {\n          maxPoint = Math.max(maxPoint, mapped.maxPoint);\n          chunks.push(mapped);\n          chunkPos.push(pos);\n        }\n      }\n    }\n\n    let next = this.nextLayer.map(changes);\n    return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);\n  }\n  /**\n  Iterate over the ranges that touch the region `from` to `to`,\n  calling `f` for each. There is no guarantee that the ranges will\n  be reported in any specific order. When the callback returns\n  `false`, iteration stops.\n  */\n\n\n  between(from, to, f) {\n    if (this == RangeSet.empty) return;\n\n    for (let i = 0; i < this.chunk.length; i++) {\n      let start = this.chunkPos[i],\n          chunk = this.chunk[i];\n      if (to >= start && from <= start + chunk.length && chunk.between(start, from - start, to - start, f) === false) return;\n    }\n\n    this.nextLayer.between(from, to, f);\n  }\n  /**\n  Iterate over the ranges in this set, in order, including all\n  ranges that end at or after `from`.\n  */\n\n\n  iter(from = 0) {\n    return HeapCursor.from([this]).goto(from);\n  }\n  /**\n  Iterate over the ranges in a collection of sets, in order,\n  starting from `from`.\n  */\n\n\n  static iter(sets, from = 0) {\n    return HeapCursor.from(sets).goto(from);\n  }\n  /**\n  Iterate over two groups of sets, calling methods on `comparator`\n  to notify it of possible differences.\n  */\n\n\n  static compare(oldSets, newSets,\n  /**\n  This indicates how the underlying data changed between these\n  ranges, and is needed to synchronize the iteration. `from` and\n  `to` are coordinates in the _new_ space, after these changes.\n  */\n  textDiff, comparator,\n  /**\n  Can be used to ignore all non-point ranges, and points below\n  the given size. When -1, all ranges are compared.\n  */\n  minPointSize = -1) {\n    let a = oldSets.filter(set => set.maxPoint >= 500\n    /* BigPointSize */\n    || set != RangeSet.empty && newSets.indexOf(set) < 0 && set.maxPoint >= minPointSize);\n    let b = newSets.filter(set => set.maxPoint >= 500\n    /* BigPointSize */\n    || set != RangeSet.empty && oldSets.indexOf(set) < 0 && set.maxPoint >= minPointSize);\n    let sharedChunks = findSharedChunks(a, b);\n    let sideA = new SpanCursor(a, sharedChunks, minPointSize);\n    let sideB = new SpanCursor(b, sharedChunks, minPointSize);\n    textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));\n    if (textDiff.empty && textDiff.length == 0) compare(sideA, 0, sideB, 0, 0, comparator);\n  }\n  /**\n  Iterate over a group of range sets at the same time, notifying\n  the iterator about the ranges covering every given piece of\n  content. Returns the open count (see\n  [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#rangeset.SpanIterator.span)) at the end\n  of the iteration.\n  */\n\n\n  static spans(sets, from, to, iterator,\n  /**\n  When given and greater than -1, only points of at least this\n  size are taken into account.\n  */\n  minPointSize = -1) {\n    let cursor = new SpanCursor(sets, null, minPointSize).goto(from),\n        pos = from;\n    let open = cursor.openStart;\n\n    for (;;) {\n      let curTo = Math.min(cursor.to, to);\n\n      if (cursor.point) {\n        iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open);\n        open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);\n      } else if (curTo > pos) {\n        iterator.span(pos, curTo, cursor.active, open);\n        open = cursor.openEnd(curTo);\n      }\n\n      if (cursor.to > to) break;\n      pos = cursor.to;\n      cursor.next();\n    }\n\n    return open;\n  }\n  /**\n  Create a range set for the given range or array of ranges. By\n  default, this expects the ranges to be _sorted_ (by start\n  position and, if two start at the same position,\n  `value.startSide`). You can pass `true` as second argument to\n  cause the method to sort them.\n  */\n\n\n  static of(ranges, sort = false) {\n    let build = new RangeSetBuilder();\n\n    for (let range of ranges instanceof Range ? [ranges] : sort ? ranges.slice().sort(cmpRange) : ranges) build.add(range.from, range.to, range.value);\n\n    return build.finish();\n  }\n\n}\n/**\nThe empty set of ranges.\n*/\n\n\nRangeSet.empty = /*@__PURE__*/new RangeSet([], [], null, -1);\nRangeSet.empty.nextLayer = RangeSet.empty;\n/**\nA range set builder is a data structure that helps build up a\n[range set](https://codemirror.net/6/docs/ref/#rangeset.RangeSet) directly, without first allocating\nan array of [`Range`](https://codemirror.net/6/docs/ref/#rangeset.Range) objects.\n*/\n\nclass RangeSetBuilder {\n  /**\n  Create an empty builder.\n  */\n  constructor() {\n    this.chunks = [];\n    this.chunkPos = [];\n    this.chunkStart = -1;\n    this.last = null;\n    this.lastFrom = -1000000000\n    /* Far */\n    ;\n    this.lastTo = -1000000000\n    /* Far */\n    ;\n    this.from = [];\n    this.to = [];\n    this.value = [];\n    this.maxPoint = -1;\n    this.setMaxPoint = -1;\n    this.nextLayer = null;\n  }\n\n  finishChunk(newArrays) {\n    this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n    this.chunkPos.push(this.chunkStart);\n    this.chunkStart = -1;\n    this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n    this.maxPoint = -1;\n\n    if (newArrays) {\n      this.from = [];\n      this.to = [];\n      this.value = [];\n    }\n  }\n  /**\n  Add a range. Ranges should be added in sorted (by `from` and\n  `value.startSide`) order.\n  */\n\n\n  add(from, to, value) {\n    if (!this.addInner(from, to, value)) (this.nextLayer || (this.nextLayer = new RangeSetBuilder())).add(from, to, value);\n  }\n  /**\n  @internal\n  */\n\n\n  addInner(from, to, value) {\n    let diff = from - this.lastTo || value.startSide - this.last.endSide;\n    if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0) throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n    if (diff < 0) return false;\n    if (this.from.length == 250\n    /* ChunkSize */\n    ) this.finishChunk(true);\n    if (this.chunkStart < 0) this.chunkStart = from;\n    this.from.push(from - this.chunkStart);\n    this.to.push(to - this.chunkStart);\n    this.last = value;\n    this.lastFrom = from;\n    this.lastTo = to;\n    this.value.push(value);\n    if (value.point) this.maxPoint = Math.max(this.maxPoint, to - from);\n    return true;\n  }\n  /**\n  @internal\n  */\n\n\n  addChunk(from, chunk) {\n    if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0) return false;\n    if (this.from.length) this.finishChunk(true);\n    this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n    this.chunks.push(chunk);\n    this.chunkPos.push(from);\n    let last = chunk.value.length - 1;\n    this.last = chunk.value[last];\n    this.lastFrom = chunk.from[last] + from;\n    this.lastTo = chunk.to[last] + from;\n    return true;\n  }\n  /**\n  Finish the range set. Returns the new set. The builder can't be\n  used anymore after this has been called.\n  */\n\n\n  finish() {\n    return this.finishInner(RangeSet.empty);\n  }\n  /**\n  @internal\n  */\n\n\n  finishInner(next) {\n    if (this.from.length) this.finishChunk(false);\n    if (this.chunks.length == 0) return next;\n    let result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n    this.from = null; // Make sure further `add` calls produce errors\n\n    return result;\n  }\n\n}\n\nfunction findSharedChunks(a, b) {\n  let inA = new Map();\n\n  for (let set of a) for (let i = 0; i < set.chunk.length; i++) if (set.chunk[i].maxPoint < 500\n  /* BigPointSize */\n  ) inA.set(set.chunk[i], set.chunkPos[i]);\n\n  let shared = new Set();\n\n  for (let set of b) for (let i = 0; i < set.chunk.length; i++) if (inA.get(set.chunk[i]) == set.chunkPos[i]) shared.add(set.chunk[i]);\n\n  return shared;\n}\n\nclass LayerCursor {\n  constructor(layer, skip, minPoint, rank = 0) {\n    this.layer = layer;\n    this.skip = skip;\n    this.minPoint = minPoint;\n    this.rank = rank;\n  }\n\n  get startSide() {\n    return this.value ? this.value.startSide : 0;\n  }\n\n  get endSide() {\n    return this.value ? this.value.endSide : 0;\n  }\n\n  goto(pos, side = -1000000000\n  /* Far */\n  ) {\n    this.chunkIndex = this.rangeIndex = 0;\n    this.gotoInner(pos, side, false);\n    return this;\n  }\n\n  gotoInner(pos, side, forward) {\n    while (this.chunkIndex < this.layer.chunk.length) {\n      let next = this.layer.chunk[this.chunkIndex];\n      if (!(this.skip && this.skip.has(next) || this.layer.chunkEnd(this.chunkIndex) < pos || next.maxPoint < this.minPoint)) break;\n      this.chunkIndex++;\n      forward = false;\n    }\n\n    let rangeIndex = this.chunkIndex == this.layer.chunk.length ? 0 : this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], -1, side);\n    if (!forward || this.rangeIndex < rangeIndex) this.rangeIndex = rangeIndex;\n    this.next();\n  }\n\n  forward(pos, side) {\n    if ((this.to - pos || this.endSide - side) < 0) this.gotoInner(pos, side, true);\n  }\n\n  next() {\n    for (;;) {\n      if (this.chunkIndex == this.layer.chunk.length) {\n        this.from = this.to = 1000000000\n        /* Far */\n        ;\n        this.value = null;\n        break;\n      } else {\n        let chunkPos = this.layer.chunkPos[this.chunkIndex],\n            chunk = this.layer.chunk[this.chunkIndex];\n        let from = chunkPos + chunk.from[this.rangeIndex];\n        this.from = from;\n        this.to = chunkPos + chunk.to[this.rangeIndex];\n        this.value = chunk.value[this.rangeIndex];\n\n        if (++this.rangeIndex == chunk.value.length) {\n          this.chunkIndex++;\n\n          if (this.skip) {\n            while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex])) this.chunkIndex++;\n          }\n\n          this.rangeIndex = 0;\n        }\n\n        if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint) break;\n      }\n    }\n  }\n\n  nextChunk() {\n    this.chunkIndex++;\n    this.rangeIndex = 0;\n    this.next();\n  }\n\n  compare(other) {\n    return this.from - other.from || this.startSide - other.startSide || this.to - other.to || this.endSide - other.endSide;\n  }\n\n}\n\nclass HeapCursor {\n  constructor(heap) {\n    this.heap = heap;\n  }\n\n  static from(sets, skip = null, minPoint = -1) {\n    let heap = [];\n\n    for (let i = 0; i < sets.length; i++) {\n      for (let cur = sets[i]; cur != RangeSet.empty; cur = cur.nextLayer) {\n        if (cur.maxPoint >= minPoint) heap.push(new LayerCursor(cur, skip, minPoint, i));\n      }\n    }\n\n    return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n  }\n\n  get startSide() {\n    return this.value ? this.value.startSide : 0;\n  }\n\n  goto(pos, side = -1000000000\n  /* Far */\n  ) {\n    for (let cur of this.heap) cur.goto(pos, side);\n\n    for (let i = this.heap.length >> 1; i >= 0; i--) heapBubble(this.heap, i);\n\n    this.next();\n    return this;\n  }\n\n  forward(pos, side) {\n    for (let cur of this.heap) cur.forward(pos, side);\n\n    for (let i = this.heap.length >> 1; i >= 0; i--) heapBubble(this.heap, i);\n\n    if ((this.to - pos || this.value.endSide - side) < 0) this.next();\n  }\n\n  next() {\n    if (this.heap.length == 0) {\n      this.from = this.to = 1000000000\n      /* Far */\n      ;\n      this.value = null;\n      this.rank = -1;\n    } else {\n      let top = this.heap[0];\n      this.from = top.from;\n      this.to = top.to;\n      this.value = top.value;\n      this.rank = top.rank;\n      if (top.value) top.next();\n      heapBubble(this.heap, 0);\n    }\n  }\n\n}\n\nfunction heapBubble(heap, index) {\n  for (let cur = heap[index];;) {\n    let childIndex = (index << 1) + 1;\n    if (childIndex >= heap.length) break;\n    let child = heap[childIndex];\n\n    if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n      child = heap[childIndex + 1];\n      childIndex++;\n    }\n\n    if (cur.compare(child) < 0) break;\n    heap[childIndex] = cur;\n    heap[index] = child;\n    index = childIndex;\n  }\n}\n\nclass SpanCursor {\n  constructor(sets, skip, minPoint) {\n    this.minPoint = minPoint;\n    this.active = [];\n    this.activeTo = [];\n    this.activeRank = [];\n    this.minActive = -1; // A currently active point range, if any\n\n    this.point = null;\n    this.pointFrom = 0;\n    this.pointRank = 0;\n    this.to = -1000000000\n    /* Far */\n    ;\n    this.endSide = 0;\n    this.openStart = -1;\n    this.cursor = HeapCursor.from(sets, skip, minPoint);\n  }\n\n  goto(pos, side = -1000000000\n  /* Far */\n  ) {\n    this.cursor.goto(pos, side);\n    this.active.length = this.activeTo.length = this.activeRank.length = 0;\n    this.minActive = -1;\n    this.to = pos;\n    this.endSide = side;\n    this.openStart = -1;\n    this.next();\n    return this;\n  }\n\n  forward(pos, side) {\n    while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0) this.removeActive(this.minActive);\n\n    this.cursor.forward(pos, side);\n  }\n\n  removeActive(index) {\n    remove(this.active, index);\n    remove(this.activeTo, index);\n    remove(this.activeRank, index);\n    this.minActive = findMinIndex(this.active, this.activeTo);\n  }\n\n  addActive(trackOpen) {\n    let i = 0,\n        {\n      value,\n      to,\n      rank\n    } = this.cursor;\n\n    while (i < this.activeRank.length && this.activeRank[i] <= rank) i++;\n\n    insert(this.active, i, value);\n    insert(this.activeTo, i, to);\n    insert(this.activeRank, i, rank);\n    if (trackOpen) insert(trackOpen, i, this.cursor.from);\n    this.minActive = findMinIndex(this.active, this.activeTo);\n  } // After calling this, if `this.point` != null, the next range is a\n  // point. Otherwise, it's a regular range, covered by `this.active`.\n\n\n  next() {\n    let from = this.to,\n        wasPoint = this.point;\n    this.point = null;\n    let trackOpen = this.openStart < 0 ? [] : null,\n        trackExtra = 0;\n\n    for (;;) {\n      let a = this.minActive;\n\n      if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n        if (this.activeTo[a] > from) {\n          this.to = this.activeTo[a];\n          this.endSide = this.active[a].endSide;\n          break;\n        }\n\n        this.removeActive(a);\n        if (trackOpen) remove(trackOpen, a);\n      } else if (!this.cursor.value) {\n        this.to = this.endSide = 1000000000\n        /* Far */\n        ;\n        break;\n      } else if (this.cursor.from > from) {\n        this.to = this.cursor.from;\n        this.endSide = this.cursor.startSide;\n        break;\n      } else {\n        let nextVal = this.cursor.value;\n\n        if (!nextVal.point) {\n          // Opening a range\n          this.addActive(trackOpen);\n          this.cursor.next();\n        } else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to && nextVal.endSide == this.endSide) {\n          // Ignore any non-empty points that end precisely at the end of the prev point\n          this.cursor.next();\n        } else {\n          // New point\n          this.point = nextVal;\n          this.pointFrom = this.cursor.from;\n          this.pointRank = this.cursor.rank;\n          this.to = this.cursor.to;\n          this.endSide = nextVal.endSide;\n          if (this.cursor.from < from) trackExtra = 1;\n          this.cursor.next();\n          if (this.to > from) this.forward(this.to, this.endSide);\n          break;\n        }\n      }\n    }\n\n    if (trackOpen) {\n      let openStart = 0;\n\n      while (openStart < trackOpen.length && trackOpen[openStart] < from) openStart++;\n\n      this.openStart = openStart + trackExtra;\n    }\n  }\n\n  activeForPoint(to) {\n    if (!this.active.length) return this.active;\n    let active = [];\n\n    for (let i = 0; i < this.active.length; i++) {\n      if (this.activeRank[i] > this.pointRank) break;\n      if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide > this.point.endSide) active.push(this.active[i]);\n    }\n\n    return active;\n  }\n\n  openEnd(to) {\n    let open = 0;\n\n    while (open < this.activeTo.length && this.activeTo[open] > to) open++;\n\n    return open;\n  }\n\n}\n\nfunction compare(a, startA, b, startB, length, comparator) {\n  a.goto(startA);\n  b.goto(startB);\n  let endB = startB + length;\n  let pos = startB,\n      dPos = startB - startA;\n\n  for (;;) {\n    let diff = a.to + dPos - b.to || a.endSide - b.endSide;\n    let end = diff < 0 ? a.to + dPos : b.to,\n        clipEnd = Math.min(end, endB);\n\n    if (a.point || b.point) {\n      if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point)))) comparator.comparePoint(pos, clipEnd, a.point, b.point);\n    } else {\n      if (clipEnd > pos && !sameValues(a.active, b.active)) comparator.compareRange(pos, clipEnd, a.active, b.active);\n    }\n\n    if (end > endB) break;\n    pos = end;\n    if (diff <= 0) a.next();\n    if (diff >= 0) b.next();\n  }\n}\n\nfunction sameValues(a, b) {\n  if (a.length != b.length) return false;\n\n  for (let i = 0; i < a.length; i++) if (a[i] != b[i] && !a[i].eq(b[i])) return false;\n\n  return true;\n}\n\nfunction remove(array, index) {\n  for (let i = index, e = array.length - 1; i < e; i++) array[i] = array[i + 1];\n\n  array.pop();\n}\n\nfunction insert(array, index, value) {\n  for (let i = array.length - 1; i >= index; i--) array[i + 1] = array[i];\n\n  array[index] = value;\n}\n\nfunction findMinIndex(value, array) {\n  let found = -1,\n      foundPos = 1000000000\n  /* Far */\n  ;\n\n  for (let i = 0; i < array.length; i++) if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n    found = i;\n    foundPos = array[i];\n  }\n\n  return found;\n}\n\nexport { Range, RangeSet, RangeSetBuilder, RangeValue };","map":{"version":3,"sources":["D:/MSIT/Practicum - iLMS/editor-codemirror6/node_modules/@codemirror/rangeset/dist/index.js"],"names":["MapMode","RangeValue","eq","other","range","from","to","Range","prototype","startSide","endSide","point","mapMode","TrackDel","constructor","value","cmpRange","a","b","Chunk","maxPoint","length","findIndex","pos","end","side","startAt","arr","lo","hi","mid","diff","between","offset","f","i","e","undefined","map","changes","newPos","val","curFrom","curTo","newFrom","newTo","mapped","mapPos","Math","max","push","RangeSet","chunkPos","chunk","nextLayer","empty","last","chunkEnd","size","index","update","updateSpec","add","sort","filterFrom","filterTo","filter","slice","of","cur","LayerCursor","goto","spill","builder","RangeSetBuilder","addInner","rangeIndex","chunkIndex","addChunk","nextChunk","next","finishInner","chunks","start","touch","touchesRange","iter","HeapCursor","sets","compare","oldSets","newSets","textDiff","comparator","minPointSize","set","indexOf","sharedChunks","findSharedChunks","sideA","SpanCursor","sideB","iterGaps","fromA","fromB","spans","iterator","cursor","open","openStart","min","activeForPoint","openEnd","span","active","ranges","build","finish","chunkStart","lastFrom","lastTo","setMaxPoint","finishChunk","newArrays","Error","result","inA","Map","shared","Set","get","layer","skip","minPoint","rank","gotoInner","forward","has","heap","heapBubble","top","childIndex","child","activeTo","activeRank","minActive","pointFrom","pointRank","removeActive","remove","findMinIndex","addActive","trackOpen","insert","wasPoint","trackExtra","nextVal","startA","startB","endB","dPos","clipEnd","comparePoint","sameValues","compareRange","array","pop","found","foundPos"],"mappings":"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","sourcesContent":["import { MapMode } from '@codemirror/state';\n\n/**\nEach range is associated with a value, which must inherit from\nthis class.\n*/\nclass RangeValue {\n    /**\n    Compare this value with another value. The default\n    implementation compares by identity.\n    */\n    eq(other) { return this == other; }\n    /**\n    Create a [range](https://codemirror.net/6/docs/ref/#rangeset.Range) with this value.\n    */\n    range(from, to = from) { return new Range(from, to, this); }\n}\nRangeValue.prototype.startSide = RangeValue.prototype.endSide = 0;\nRangeValue.prototype.point = false;\nRangeValue.prototype.mapMode = MapMode.TrackDel;\n/**\nA range associates a value with a range of positions.\n*/\nclass Range {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The range's start position.\n    */\n    from, \n    /**\n    Its end position.\n    */\n    to, \n    /**\n    The value associated with this range.\n    */\n    value) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n    }\n}\nfunction cmpRange(a, b) {\n    return a.from - b.from || a.value.startSide - b.value.startSide;\n}\nclass Chunk {\n    constructor(from, to, value, \n    // Chunks are marked with the largest point that occurs\n    // in them (or -1 for no points), so that scans that are\n    // only interested in points (such as the\n    // heightmap-related logic) can skip range-only chunks.\n    maxPoint) {\n        this.from = from;\n        this.to = to;\n        this.value = value;\n        this.maxPoint = maxPoint;\n    }\n    get length() { return this.to[this.to.length - 1]; }\n    // With side == -1, return the first index where to >= pos. When\n    // side == 1, the first index where from > pos.\n    findIndex(pos, end, side = end * 1000000000 /* Far */, startAt = 0) {\n        if (pos <= 0)\n            return startAt;\n        let arr = end < 0 ? this.to : this.from;\n        for (let lo = startAt, hi = arr.length;;) {\n            if (lo == hi)\n                return lo;\n            let mid = (lo + hi) >> 1;\n            let diff = arr[mid] - pos || (end < 0 ? this.value[mid].startSide : this.value[mid].endSide) - side;\n            if (mid == lo)\n                return diff >= 0 ? lo : hi;\n            if (diff >= 0)\n                hi = mid;\n            else\n                lo = mid + 1;\n        }\n    }\n    between(offset, from, to, f) {\n        for (let i = this.findIndex(from, -1), e = this.findIndex(to, 1, undefined, i); i < e; i++)\n            if (f(this.from[i] + offset, this.to[i] + offset, this.value[i]) === false)\n                return false;\n    }\n    map(offset, changes) {\n        let value = [], from = [], to = [], newPos = -1, maxPoint = -1;\n        for (let i = 0; i < this.value.length; i++) {\n            let val = this.value[i], curFrom = this.from[i] + offset, curTo = this.to[i] + offset, newFrom, newTo;\n            if (curFrom == curTo) {\n                let mapped = changes.mapPos(curFrom, val.startSide, val.mapMode);\n                if (mapped == null)\n                    continue;\n                newFrom = newTo = mapped;\n            }\n            else {\n                newFrom = changes.mapPos(curFrom, val.startSide);\n                newTo = changes.mapPos(curTo, val.endSide);\n                if (newFrom > newTo || newFrom == newTo && val.startSide > 0 && val.endSide <= 0)\n                    continue;\n            }\n            if ((newTo - newFrom || val.endSide - val.startSide) < 0)\n                continue;\n            if (newPos < 0)\n                newPos = newFrom;\n            if (val.point)\n                maxPoint = Math.max(maxPoint, newTo - newFrom);\n            value.push(val);\n            from.push(newFrom - newPos);\n            to.push(newTo - newPos);\n        }\n        return { mapped: value.length ? new Chunk(from, to, value, maxPoint) : null, pos: newPos };\n    }\n}\n/**\nA range set stores a collection of [ranges](https://codemirror.net/6/docs/ref/#rangeset.Range) in a\nway that makes them efficient to [map](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.map) and\n[update](https://codemirror.net/6/docs/ref/#rangeset.RangeSet.update). This is an immutable data\nstructure.\n*/\nclass RangeSet {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    @internal\n    */\n    chunkPos, \n    /**\n    @internal\n    */\n    chunk, \n    /**\n    @internal\n    */\n    nextLayer = RangeSet.empty, \n    /**\n    @internal\n    */\n    maxPoint) {\n        this.chunkPos = chunkPos;\n        this.chunk = chunk;\n        this.nextLayer = nextLayer;\n        this.maxPoint = maxPoint;\n    }\n    /**\n    @internal\n    */\n    get length() {\n        let last = this.chunk.length - 1;\n        return last < 0 ? 0 : Math.max(this.chunkEnd(last), this.nextLayer.length);\n    }\n    /**\n    The number of ranges in the set.\n    */\n    get size() {\n        if (this == RangeSet.empty)\n            return 0;\n        let size = this.nextLayer.size;\n        for (let chunk of this.chunk)\n            size += chunk.value.length;\n        return size;\n    }\n    /**\n    @internal\n    */\n    chunkEnd(index) {\n        return this.chunkPos[index] + this.chunk[index].length;\n    }\n    /**\n    Update the range set, optionally adding new ranges or filtering\n    out existing ones.\n    \n    (The extra type parameter is just there as a kludge to work\n    around TypeScript variance issues that prevented `RangeSet<X>`\n    from being a subtype of `RangeSet<Y>` when `X` is a subtype of\n    `Y`.)\n    */\n    update(updateSpec) {\n        let { add = [], sort = false, filterFrom = 0, filterTo = this.length } = updateSpec;\n        let filter = updateSpec.filter;\n        if (add.length == 0 && !filter)\n            return this;\n        if (sort)\n            add.slice().sort(cmpRange);\n        if (this == RangeSet.empty)\n            return add.length ? RangeSet.of(add) : this;\n        let cur = new LayerCursor(this, null, -1).goto(0), i = 0, spill = [];\n        let builder = new RangeSetBuilder();\n        while (cur.value || i < add.length) {\n            if (i < add.length && (cur.from - add[i].from || cur.startSide - add[i].value.startSide) >= 0) {\n                let range = add[i++];\n                if (!builder.addInner(range.from, range.to, range.value))\n                    spill.push(range);\n            }\n            else if (cur.rangeIndex == 1 && cur.chunkIndex < this.chunk.length &&\n                (i == add.length || this.chunkEnd(cur.chunkIndex) < add[i].from) &&\n                (!filter || filterFrom > this.chunkEnd(cur.chunkIndex) || filterTo < this.chunkPos[cur.chunkIndex]) &&\n                builder.addChunk(this.chunkPos[cur.chunkIndex], this.chunk[cur.chunkIndex])) {\n                cur.nextChunk();\n            }\n            else {\n                if (!filter || filterFrom > cur.to || filterTo < cur.from || filter(cur.from, cur.to, cur.value)) {\n                    if (!builder.addInner(cur.from, cur.to, cur.value))\n                        spill.push(new Range(cur.from, cur.to, cur.value));\n                }\n                cur.next();\n            }\n        }\n        return builder.finishInner(this.nextLayer == RangeSet.empty && !spill.length ? RangeSet.empty\n            : this.nextLayer.update({ add: spill, filter, filterFrom, filterTo }));\n    }\n    /**\n    Map this range set through a set of changes, return the new set.\n    */\n    map(changes) {\n        if (changes.length == 0 || this == RangeSet.empty)\n            return this;\n        let chunks = [], chunkPos = [], maxPoint = -1;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            let touch = changes.touchesRange(start, start + chunk.length);\n            if (touch === false) {\n                maxPoint = Math.max(maxPoint, chunk.maxPoint);\n                chunks.push(chunk);\n                chunkPos.push(changes.mapPos(start));\n            }\n            else if (touch === true) {\n                let { mapped, pos } = chunk.map(start, changes);\n                if (mapped) {\n                    maxPoint = Math.max(maxPoint, mapped.maxPoint);\n                    chunks.push(mapped);\n                    chunkPos.push(pos);\n                }\n            }\n        }\n        let next = this.nextLayer.map(changes);\n        return chunks.length == 0 ? next : new RangeSet(chunkPos, chunks, next, maxPoint);\n    }\n    /**\n    Iterate over the ranges that touch the region `from` to `to`,\n    calling `f` for each. There is no guarantee that the ranges will\n    be reported in any specific order. When the callback returns\n    `false`, iteration stops.\n    */\n    between(from, to, f) {\n        if (this == RangeSet.empty)\n            return;\n        for (let i = 0; i < this.chunk.length; i++) {\n            let start = this.chunkPos[i], chunk = this.chunk[i];\n            if (to >= start && from <= start + chunk.length &&\n                chunk.between(start, from - start, to - start, f) === false)\n                return;\n        }\n        this.nextLayer.between(from, to, f);\n    }\n    /**\n    Iterate over the ranges in this set, in order, including all\n    ranges that end at or after `from`.\n    */\n    iter(from = 0) {\n        return HeapCursor.from([this]).goto(from);\n    }\n    /**\n    Iterate over the ranges in a collection of sets, in order,\n    starting from `from`.\n    */\n    static iter(sets, from = 0) {\n        return HeapCursor.from(sets).goto(from);\n    }\n    /**\n    Iterate over two groups of sets, calling methods on `comparator`\n    to notify it of possible differences.\n    */\n    static compare(oldSets, newSets, \n    /**\n    This indicates how the underlying data changed between these\n    ranges, and is needed to synchronize the iteration. `from` and\n    `to` are coordinates in the _new_ space, after these changes.\n    */\n    textDiff, comparator, \n    /**\n    Can be used to ignore all non-point ranges, and points below\n    the given size. When -1, all ranges are compared.\n    */\n    minPointSize = -1) {\n        let a = oldSets.filter(set => set.maxPoint >= 500 /* BigPointSize */ ||\n            set != RangeSet.empty && newSets.indexOf(set) < 0 && set.maxPoint >= minPointSize);\n        let b = newSets.filter(set => set.maxPoint >= 500 /* BigPointSize */ ||\n            set != RangeSet.empty && oldSets.indexOf(set) < 0 && set.maxPoint >= minPointSize);\n        let sharedChunks = findSharedChunks(a, b);\n        let sideA = new SpanCursor(a, sharedChunks, minPointSize);\n        let sideB = new SpanCursor(b, sharedChunks, minPointSize);\n        textDiff.iterGaps((fromA, fromB, length) => compare(sideA, fromA, sideB, fromB, length, comparator));\n        if (textDiff.empty && textDiff.length == 0)\n            compare(sideA, 0, sideB, 0, 0, comparator);\n    }\n    /**\n    Iterate over a group of range sets at the same time, notifying\n    the iterator about the ranges covering every given piece of\n    content. Returns the open count (see\n    [`SpanIterator.span`](https://codemirror.net/6/docs/ref/#rangeset.SpanIterator.span)) at the end\n    of the iteration.\n    */\n    static spans(sets, from, to, iterator, \n    /**\n    When given and greater than -1, only points of at least this\n    size are taken into account.\n    */\n    minPointSize = -1) {\n        let cursor = new SpanCursor(sets, null, minPointSize).goto(from), pos = from;\n        let open = cursor.openStart;\n        for (;;) {\n            let curTo = Math.min(cursor.to, to);\n            if (cursor.point) {\n                iterator.point(pos, curTo, cursor.point, cursor.activeForPoint(cursor.to), open);\n                open = cursor.openEnd(curTo) + (cursor.to > curTo ? 1 : 0);\n            }\n            else if (curTo > pos) {\n                iterator.span(pos, curTo, cursor.active, open);\n                open = cursor.openEnd(curTo);\n            }\n            if (cursor.to > to)\n                break;\n            pos = cursor.to;\n            cursor.next();\n        }\n        return open;\n    }\n    /**\n    Create a range set for the given range or array of ranges. By\n    default, this expects the ranges to be _sorted_ (by start\n    position and, if two start at the same position,\n    `value.startSide`). You can pass `true` as second argument to\n    cause the method to sort them.\n    */\n    static of(ranges, sort = false) {\n        let build = new RangeSetBuilder();\n        for (let range of ranges instanceof Range ? [ranges] : sort ? ranges.slice().sort(cmpRange) : ranges)\n            build.add(range.from, range.to, range.value);\n        return build.finish();\n    }\n}\n/**\nThe empty set of ranges.\n*/\nRangeSet.empty = /*@__PURE__*/new RangeSet([], [], null, -1);\nRangeSet.empty.nextLayer = RangeSet.empty;\n/**\nA range set builder is a data structure that helps build up a\n[range set](https://codemirror.net/6/docs/ref/#rangeset.RangeSet) directly, without first allocating\nan array of [`Range`](https://codemirror.net/6/docs/ref/#rangeset.Range) objects.\n*/\nclass RangeSetBuilder {\n    /**\n    Create an empty builder.\n    */\n    constructor() {\n        this.chunks = [];\n        this.chunkPos = [];\n        this.chunkStart = -1;\n        this.last = null;\n        this.lastFrom = -1000000000 /* Far */;\n        this.lastTo = -1000000000 /* Far */;\n        this.from = [];\n        this.to = [];\n        this.value = [];\n        this.maxPoint = -1;\n        this.setMaxPoint = -1;\n        this.nextLayer = null;\n    }\n    finishChunk(newArrays) {\n        this.chunks.push(new Chunk(this.from, this.to, this.value, this.maxPoint));\n        this.chunkPos.push(this.chunkStart);\n        this.chunkStart = -1;\n        this.setMaxPoint = Math.max(this.setMaxPoint, this.maxPoint);\n        this.maxPoint = -1;\n        if (newArrays) {\n            this.from = [];\n            this.to = [];\n            this.value = [];\n        }\n    }\n    /**\n    Add a range. Ranges should be added in sorted (by `from` and\n    `value.startSide`) order.\n    */\n    add(from, to, value) {\n        if (!this.addInner(from, to, value))\n            (this.nextLayer || (this.nextLayer = new RangeSetBuilder)).add(from, to, value);\n    }\n    /**\n    @internal\n    */\n    addInner(from, to, value) {\n        let diff = from - this.lastTo || value.startSide - this.last.endSide;\n        if (diff <= 0 && (from - this.lastFrom || value.startSide - this.last.startSide) < 0)\n            throw new Error(\"Ranges must be added sorted by `from` position and `startSide`\");\n        if (diff < 0)\n            return false;\n        if (this.from.length == 250 /* ChunkSize */)\n            this.finishChunk(true);\n        if (this.chunkStart < 0)\n            this.chunkStart = from;\n        this.from.push(from - this.chunkStart);\n        this.to.push(to - this.chunkStart);\n        this.last = value;\n        this.lastFrom = from;\n        this.lastTo = to;\n        this.value.push(value);\n        if (value.point)\n            this.maxPoint = Math.max(this.maxPoint, to - from);\n        return true;\n    }\n    /**\n    @internal\n    */\n    addChunk(from, chunk) {\n        if ((from - this.lastTo || chunk.value[0].startSide - this.last.endSide) < 0)\n            return false;\n        if (this.from.length)\n            this.finishChunk(true);\n        this.setMaxPoint = Math.max(this.setMaxPoint, chunk.maxPoint);\n        this.chunks.push(chunk);\n        this.chunkPos.push(from);\n        let last = chunk.value.length - 1;\n        this.last = chunk.value[last];\n        this.lastFrom = chunk.from[last] + from;\n        this.lastTo = chunk.to[last] + from;\n        return true;\n    }\n    /**\n    Finish the range set. Returns the new set. The builder can't be\n    used anymore after this has been called.\n    */\n    finish() { return this.finishInner(RangeSet.empty); }\n    /**\n    @internal\n    */\n    finishInner(next) {\n        if (this.from.length)\n            this.finishChunk(false);\n        if (this.chunks.length == 0)\n            return next;\n        let result = new RangeSet(this.chunkPos, this.chunks, this.nextLayer ? this.nextLayer.finishInner(next) : next, this.setMaxPoint);\n        this.from = null; // Make sure further `add` calls produce errors\n        return result;\n    }\n}\nfunction findSharedChunks(a, b) {\n    let inA = new Map();\n    for (let set of a)\n        for (let i = 0; i < set.chunk.length; i++)\n            if (set.chunk[i].maxPoint < 500 /* BigPointSize */)\n                inA.set(set.chunk[i], set.chunkPos[i]);\n    let shared = new Set();\n    for (let set of b)\n        for (let i = 0; i < set.chunk.length; i++)\n            if (inA.get(set.chunk[i]) == set.chunkPos[i])\n                shared.add(set.chunk[i]);\n    return shared;\n}\nclass LayerCursor {\n    constructor(layer, skip, minPoint, rank = 0) {\n        this.layer = layer;\n        this.skip = skip;\n        this.minPoint = minPoint;\n        this.rank = rank;\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    get endSide() { return this.value ? this.value.endSide : 0; }\n    goto(pos, side = -1000000000 /* Far */) {\n        this.chunkIndex = this.rangeIndex = 0;\n        this.gotoInner(pos, side, false);\n        return this;\n    }\n    gotoInner(pos, side, forward) {\n        while (this.chunkIndex < this.layer.chunk.length) {\n            let next = this.layer.chunk[this.chunkIndex];\n            if (!(this.skip && this.skip.has(next) ||\n                this.layer.chunkEnd(this.chunkIndex) < pos ||\n                next.maxPoint < this.minPoint))\n                break;\n            this.chunkIndex++;\n            forward = false;\n        }\n        let rangeIndex = this.chunkIndex == this.layer.chunk.length ? 0\n            : this.layer.chunk[this.chunkIndex].findIndex(pos - this.layer.chunkPos[this.chunkIndex], -1, side);\n        if (!forward || this.rangeIndex < rangeIndex)\n            this.rangeIndex = rangeIndex;\n        this.next();\n    }\n    forward(pos, side) {\n        if ((this.to - pos || this.endSide - side) < 0)\n            this.gotoInner(pos, side, true);\n    }\n    next() {\n        for (;;) {\n            if (this.chunkIndex == this.layer.chunk.length) {\n                this.from = this.to = 1000000000 /* Far */;\n                this.value = null;\n                break;\n            }\n            else {\n                let chunkPos = this.layer.chunkPos[this.chunkIndex], chunk = this.layer.chunk[this.chunkIndex];\n                let from = chunkPos + chunk.from[this.rangeIndex];\n                this.from = from;\n                this.to = chunkPos + chunk.to[this.rangeIndex];\n                this.value = chunk.value[this.rangeIndex];\n                if (++this.rangeIndex == chunk.value.length) {\n                    this.chunkIndex++;\n                    if (this.skip) {\n                        while (this.chunkIndex < this.layer.chunk.length && this.skip.has(this.layer.chunk[this.chunkIndex]))\n                            this.chunkIndex++;\n                    }\n                    this.rangeIndex = 0;\n                }\n                if (this.minPoint < 0 || this.value.point && this.to - this.from >= this.minPoint)\n                    break;\n            }\n        }\n    }\n    nextChunk() {\n        this.chunkIndex++;\n        this.rangeIndex = 0;\n        this.next();\n    }\n    compare(other) {\n        return this.from - other.from || this.startSide - other.startSide || this.to - other.to || this.endSide - other.endSide;\n    }\n}\nclass HeapCursor {\n    constructor(heap) {\n        this.heap = heap;\n    }\n    static from(sets, skip = null, minPoint = -1) {\n        let heap = [];\n        for (let i = 0; i < sets.length; i++) {\n            for (let cur = sets[i]; cur != RangeSet.empty; cur = cur.nextLayer) {\n                if (cur.maxPoint >= minPoint)\n                    heap.push(new LayerCursor(cur, skip, minPoint, i));\n            }\n        }\n        return heap.length == 1 ? heap[0] : new HeapCursor(heap);\n    }\n    get startSide() { return this.value ? this.value.startSide : 0; }\n    goto(pos, side = -1000000000 /* Far */) {\n        for (let cur of this.heap)\n            cur.goto(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        for (let cur of this.heap)\n            cur.forward(pos, side);\n        for (let i = this.heap.length >> 1; i >= 0; i--)\n            heapBubble(this.heap, i);\n        if ((this.to - pos || this.value.endSide - side) < 0)\n            this.next();\n    }\n    next() {\n        if (this.heap.length == 0) {\n            this.from = this.to = 1000000000 /* Far */;\n            this.value = null;\n            this.rank = -1;\n        }\n        else {\n            let top = this.heap[0];\n            this.from = top.from;\n            this.to = top.to;\n            this.value = top.value;\n            this.rank = top.rank;\n            if (top.value)\n                top.next();\n            heapBubble(this.heap, 0);\n        }\n    }\n}\nfunction heapBubble(heap, index) {\n    for (let cur = heap[index];;) {\n        let childIndex = (index << 1) + 1;\n        if (childIndex >= heap.length)\n            break;\n        let child = heap[childIndex];\n        if (childIndex + 1 < heap.length && child.compare(heap[childIndex + 1]) >= 0) {\n            child = heap[childIndex + 1];\n            childIndex++;\n        }\n        if (cur.compare(child) < 0)\n            break;\n        heap[childIndex] = cur;\n        heap[index] = child;\n        index = childIndex;\n    }\n}\nclass SpanCursor {\n    constructor(sets, skip, minPoint) {\n        this.minPoint = minPoint;\n        this.active = [];\n        this.activeTo = [];\n        this.activeRank = [];\n        this.minActive = -1;\n        // A currently active point range, if any\n        this.point = null;\n        this.pointFrom = 0;\n        this.pointRank = 0;\n        this.to = -1000000000 /* Far */;\n        this.endSide = 0;\n        this.openStart = -1;\n        this.cursor = HeapCursor.from(sets, skip, minPoint);\n    }\n    goto(pos, side = -1000000000 /* Far */) {\n        this.cursor.goto(pos, side);\n        this.active.length = this.activeTo.length = this.activeRank.length = 0;\n        this.minActive = -1;\n        this.to = pos;\n        this.endSide = side;\n        this.openStart = -1;\n        this.next();\n        return this;\n    }\n    forward(pos, side) {\n        while (this.minActive > -1 && (this.activeTo[this.minActive] - pos || this.active[this.minActive].endSide - side) < 0)\n            this.removeActive(this.minActive);\n        this.cursor.forward(pos, side);\n    }\n    removeActive(index) {\n        remove(this.active, index);\n        remove(this.activeTo, index);\n        remove(this.activeRank, index);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    addActive(trackOpen) {\n        let i = 0, { value, to, rank } = this.cursor;\n        while (i < this.activeRank.length && this.activeRank[i] <= rank)\n            i++;\n        insert(this.active, i, value);\n        insert(this.activeTo, i, to);\n        insert(this.activeRank, i, rank);\n        if (trackOpen)\n            insert(trackOpen, i, this.cursor.from);\n        this.minActive = findMinIndex(this.active, this.activeTo);\n    }\n    // After calling this, if `this.point` != null, the next range is a\n    // point. Otherwise, it's a regular range, covered by `this.active`.\n    next() {\n        let from = this.to, wasPoint = this.point;\n        this.point = null;\n        let trackOpen = this.openStart < 0 ? [] : null, trackExtra = 0;\n        for (;;) {\n            let a = this.minActive;\n            if (a > -1 && (this.activeTo[a] - this.cursor.from || this.active[a].endSide - this.cursor.startSide) < 0) {\n                if (this.activeTo[a] > from) {\n                    this.to = this.activeTo[a];\n                    this.endSide = this.active[a].endSide;\n                    break;\n                }\n                this.removeActive(a);\n                if (trackOpen)\n                    remove(trackOpen, a);\n            }\n            else if (!this.cursor.value) {\n                this.to = this.endSide = 1000000000 /* Far */;\n                break;\n            }\n            else if (this.cursor.from > from) {\n                this.to = this.cursor.from;\n                this.endSide = this.cursor.startSide;\n                break;\n            }\n            else {\n                let nextVal = this.cursor.value;\n                if (!nextVal.point) { // Opening a range\n                    this.addActive(trackOpen);\n                    this.cursor.next();\n                }\n                else if (wasPoint && this.cursor.to == this.to && this.cursor.from < this.cursor.to && nextVal.endSide == this.endSide) {\n                    // Ignore any non-empty points that end precisely at the end of the prev point\n                    this.cursor.next();\n                }\n                else { // New point\n                    this.point = nextVal;\n                    this.pointFrom = this.cursor.from;\n                    this.pointRank = this.cursor.rank;\n                    this.to = this.cursor.to;\n                    this.endSide = nextVal.endSide;\n                    if (this.cursor.from < from)\n                        trackExtra = 1;\n                    this.cursor.next();\n                    if (this.to > from)\n                        this.forward(this.to, this.endSide);\n                    break;\n                }\n            }\n        }\n        if (trackOpen) {\n            let openStart = 0;\n            while (openStart < trackOpen.length && trackOpen[openStart] < from)\n                openStart++;\n            this.openStart = openStart + trackExtra;\n        }\n    }\n    activeForPoint(to) {\n        if (!this.active.length)\n            return this.active;\n        let active = [];\n        for (let i = 0; i < this.active.length; i++) {\n            if (this.activeRank[i] > this.pointRank)\n                break;\n            if (this.activeTo[i] > to || this.activeTo[i] == to && this.active[i].endSide > this.point.endSide)\n                active.push(this.active[i]);\n        }\n        return active;\n    }\n    openEnd(to) {\n        let open = 0;\n        while (open < this.activeTo.length && this.activeTo[open] > to)\n            open++;\n        return open;\n    }\n}\nfunction compare(a, startA, b, startB, length, comparator) {\n    a.goto(startA);\n    b.goto(startB);\n    let endB = startB + length;\n    let pos = startB, dPos = startB - startA;\n    for (;;) {\n        let diff = (a.to + dPos) - b.to || a.endSide - b.endSide;\n        let end = diff < 0 ? a.to + dPos : b.to, clipEnd = Math.min(end, endB);\n        if (a.point || b.point) {\n            if (!(a.point && b.point && (a.point == b.point || a.point.eq(b.point))))\n                comparator.comparePoint(pos, clipEnd, a.point, b.point);\n        }\n        else {\n            if (clipEnd > pos && !sameValues(a.active, b.active))\n                comparator.compareRange(pos, clipEnd, a.active, b.active);\n        }\n        if (end > endB)\n            break;\n        pos = end;\n        if (diff <= 0)\n            a.next();\n        if (diff >= 0)\n            b.next();\n    }\n}\nfunction sameValues(a, b) {\n    if (a.length != b.length)\n        return false;\n    for (let i = 0; i < a.length; i++)\n        if (a[i] != b[i] && !a[i].eq(b[i]))\n            return false;\n    return true;\n}\nfunction remove(array, index) {\n    for (let i = index, e = array.length - 1; i < e; i++)\n        array[i] = array[i + 1];\n    array.pop();\n}\nfunction insert(array, index, value) {\n    for (let i = array.length - 1; i >= index; i--)\n        array[i + 1] = array[i];\n    array[index] = value;\n}\nfunction findMinIndex(value, array) {\n    let found = -1, foundPos = 1000000000 /* Far */;\n    for (let i = 0; i < array.length; i++)\n        if ((array[i] - foundPos || value[i].endSide - value[found].endSide) < 0) {\n            found = i;\n            foundPos = array[i];\n        }\n    return found;\n}\n\nexport { Range, RangeSet, RangeSetBuilder, RangeValue };\n"]},"metadata":{},"sourceType":"module"}