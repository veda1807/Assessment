{"ast":null,"code":"import { ViewPlugin, Direction, EditorView, logException } from '@codemirror/view';\nimport { Facet, StateEffect, StateField, MapMode } from '@codemirror/state';\nconst ios = typeof navigator != \"undefined\" && !/Edge\\/(\\d+)/.exec(navigator.userAgent) && /Apple Computer/.test(navigator.vendor) && (/Mobile\\/\\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);\nconst Outside = \"-10000px\";\nconst tooltipPlugin = ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.view = view;\n    this.inView = true;\n    this.measureReq = {\n      read: this.readMeasure.bind(this),\n      write: this.writeMeasure.bind(this),\n      key: this\n    };\n    this.input = view.state.facet(showTooltip);\n    this.tooltips = this.input.filter(t => t);\n    this.tooltipViews = this.tooltips.map(tp => this.createTooltip(tp));\n  }\n\n  update(update) {\n    let input = update.state.facet(showTooltip);\n\n    if (input == this.input) {\n      for (let t of this.tooltipViews) if (t.update) t.update(update);\n    } else {\n      let tooltips = input.filter(x => x);\n      let views = [];\n\n      for (let i = 0; i < tooltips.length; i++) {\n        let tip = tooltips[i],\n            known = -1;\n        if (!tip) continue;\n\n        for (let i = 0; i < this.tooltips.length; i++) {\n          let other = this.tooltips[i];\n          if (other && other.create == tip.create) known = i;\n        }\n\n        if (known < 0) {\n          views[i] = this.createTooltip(tip);\n        } else {\n          let tooltipView = views[i] = this.tooltipViews[known];\n          if (tooltipView.update) tooltipView.update(update);\n        }\n      }\n\n      for (let t of this.tooltipViews) if (views.indexOf(t) < 0) t.dom.remove();\n\n      this.input = input;\n      this.tooltips = tooltips;\n      this.tooltipViews = views;\n      this.maybeMeasure();\n    }\n  }\n\n  createTooltip(tooltip) {\n    let tooltipView = tooltip.create(this.view);\n    tooltipView.dom.classList.add(\"cm-tooltip\"); // FIXME drop this on the next breaking release\n\n    if (tooltip.class) tooltipView.dom.classList.add(tooltip.class);\n    tooltipView.dom.style.top = Outside;\n    this.view.dom.appendChild(tooltipView.dom);\n    if (tooltipView.mount) tooltipView.mount(this.view);\n    return tooltipView;\n  }\n\n  destroy() {\n    for (let {\n      dom\n    } of this.tooltipViews) dom.remove();\n  }\n\n  readMeasure() {\n    return {\n      editor: this.view.dom.getBoundingClientRect(),\n      pos: this.tooltips.map(t => this.view.coordsAtPos(t.pos)),\n      size: this.tooltipViews.map(({\n        dom\n      }) => dom.getBoundingClientRect()),\n      innerWidth: window.innerWidth,\n      innerHeight: window.innerHeight\n    };\n  }\n\n  writeMeasure(measured) {\n    let {\n      editor\n    } = measured;\n\n    for (let i = 0; i < this.tooltipViews.length; i++) {\n      let tooltip = this.tooltips[i],\n          tView = this.tooltipViews[i],\n          {\n        dom\n      } = tView;\n      let pos = measured.pos[i],\n          size = measured.size[i]; // Hide tooltips that are outside of the editor.\n\n      if (!pos || pos.bottom <= editor.top || pos.top >= editor.bottom || pos.right <= editor.left || pos.left >= editor.right) {\n        dom.style.top = Outside;\n        continue;\n      }\n\n      let width = size.right - size.left,\n          height = size.bottom - size.top;\n      let left = this.view.textDirection == Direction.LTR ? Math.min(pos.left, measured.innerWidth - width) : Math.max(0, pos.left - width);\n      let above = !!tooltip.above;\n      if (!tooltip.strictSide && (above ? pos.top - (size.bottom - size.top) < 0 : pos.bottom + (size.bottom - size.top) > measured.innerHeight)) above = !above;\n\n      if (ios) {\n        dom.style.top = (above ? pos.top - height : pos.bottom) - editor.top + \"px\";\n        dom.style.left = left - editor.left + \"px\";\n        dom.style.position = \"absolute\";\n      } else {\n        dom.style.top = (above ? pos.top - height : pos.bottom) + \"px\";\n        dom.style.left = left + \"px\";\n      }\n\n      dom.classList.toggle(\"cm-tooltip-above\", above);\n      dom.classList.toggle(\"cm-tooltip-below\", !above);\n      if (tView.positioned) tView.positioned();\n    }\n  }\n\n  maybeMeasure() {\n    if (this.tooltips.length) {\n      if (this.view.inView || this.inView) this.view.requestMeasure(this.measureReq);\n      this.inView = this.view.inView;\n    }\n  }\n\n}, {\n  eventHandlers: {\n    scroll() {\n      this.maybeMeasure();\n    }\n\n  }\n});\nconst baseTheme = EditorView.baseTheme({\n  \".cm-tooltip\": {\n    position: \"fixed\",\n    zIndex: 100\n  },\n  \"&light .cm-tooltip\": {\n    border: \"1px solid #ddd\",\n    backgroundColor: \"#f5f5f5\"\n  },\n  \"&dark .cm-tooltip\": {\n    backgroundColor: \"#333338\",\n    color: \"white\"\n  }\n}); // FIXME backward-compat shim. Delete on next major version.\n\n/**\n@internal\n*/\n\nfunction tooltips() {\n  return [];\n}\n/**\nBehavior by which an extension can provide a tooltip to be shown.\n*/\n\n\nconst showTooltip = Facet.define({\n  enables: [tooltipPlugin, baseTheme]\n});\nconst HoverTime = 750,\n      HoverMaxDist = 6;\n\nclass HoverPlugin {\n  constructor(view, source, field, setHover) {\n    this.view = view;\n    this.source = source;\n    this.field = field;\n    this.setHover = setHover;\n    this.lastMouseMove = null;\n    this.hoverTimeout = -1;\n    this.restartTimeout = -1;\n    this.pending = null;\n    this.checkHover = this.checkHover.bind(this);\n    view.dom.addEventListener(\"mouseleave\", this.mouseleave = this.mouseleave.bind(this));\n    view.dom.addEventListener(\"mousemove\", this.mousemove = this.mousemove.bind(this));\n  }\n\n  update() {\n    if (this.pending) {\n      this.pending = null;\n      clearTimeout(this.restartTimeout);\n      this.restartTimeout = setTimeout(() => this.startHover(), 20);\n    }\n  }\n\n  get active() {\n    return this.view.state.field(this.field);\n  }\n\n  checkHover() {\n    this.hoverTimeout = -1;\n    if (this.active) return;\n    let now = Date.now(),\n        lastMove = this.lastMouseMove;\n    if (now - lastMove.timeStamp < HoverTime) this.hoverTimeout = setTimeout(this.checkHover, HoverTime - (now - lastMove.timeStamp));else this.startHover();\n  }\n\n  startHover() {\n    var _a;\n\n    clearTimeout(this.restartTimeout);\n    let lastMove = this.lastMouseMove;\n    let coords = {\n      x: lastMove.clientX,\n      y: lastMove.clientY\n    };\n    let pos = this.view.contentDOM.contains(lastMove.target) ? this.view.posAtCoords(coords) : null;\n    if (pos == null) return;\n    let posCoords = this.view.coordsAtPos(pos);\n    if (posCoords == null || coords.y < posCoords.top || coords.y > posCoords.bottom || coords.x < posCoords.left - this.view.defaultCharacterWidth || coords.x > posCoords.right + this.view.defaultCharacterWidth) return;\n    let bidi = this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find(s => s.from <= pos && s.to >= pos);\n    let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;\n    let open = this.source(this.view, pos, coords.x < posCoords.left ? -rtl : rtl);\n\n    if ((_a = open) === null || _a === void 0 ? void 0 : _a.then) {\n      let pending = this.pending = {\n        pos\n      };\n      open.then(result => {\n        if (this.pending == pending) {\n          this.pending = null;\n          if (result) this.view.dispatch({\n            effects: this.setHover.of(result)\n          });\n        }\n      }, e => logException(this.view.state, e, \"hover tooltip\"));\n    } else if (open) {\n      this.view.dispatch({\n        effects: this.setHover.of(open)\n      });\n    }\n  }\n\n  mousemove(event) {\n    var _a;\n\n    this.lastMouseMove = event;\n    if (this.hoverTimeout < 0) this.hoverTimeout = setTimeout(this.checkHover, HoverTime);\n    let tooltip = this.active;\n\n    if (tooltip && !isInTooltip(event.target) || this.pending) {\n      let {\n        pos\n      } = tooltip || this.pending,\n          end = (_a = tooltip === null || tooltip === void 0 ? void 0 : tooltip.end) !== null && _a !== void 0 ? _a : pos;\n\n      if (pos == end ? this.view.posAtCoords({\n        x: event.clientX,\n        y: event.clientY\n      }) != pos : !isOverRange(this.view, pos, end, event.clientX, event.clientY, HoverMaxDist)) {\n        this.view.dispatch({\n          effects: this.setHover.of(null)\n        });\n        this.pending = null;\n      }\n    }\n  }\n\n  mouseleave() {\n    clearTimeout(this.hoverTimeout);\n    this.hoverTimeout = -1;\n    if (this.active) this.view.dispatch({\n      effects: this.setHover.of(null)\n    });\n  }\n\n  destroy() {\n    clearTimeout(this.hoverTimeout);\n    this.view.dom.removeEventListener(\"mouseleave\", this.mouseleave);\n    this.view.dom.removeEventListener(\"mousemove\", this.mousemove);\n  }\n\n}\n\nfunction isInTooltip(elt) {\n  for (let cur = elt; cur; cur = cur.parentNode) if (cur.nodeType == 1 && cur.classList.contains(\"cm-tooltip\")) return true;\n\n  return false;\n}\n\nfunction isOverRange(view, from, to, x, y, margin) {\n  let range = document.createRange();\n  let fromDOM = view.domAtPos(from),\n      toDOM = view.domAtPos(to);\n  range.setEnd(toDOM.node, toDOM.offset);\n  range.setStart(fromDOM.node, fromDOM.offset);\n  let rects = range.getClientRects();\n  range.detach();\n\n  for (let i = 0; i < rects.length; i++) {\n    let rect = rects[i];\n    let dist = Math.max(rect.top - y, y - rect.bottom, rect.left - x, x - rect.right);\n    if (dist <= margin) return true;\n  }\n\n  return false;\n}\n/**\nEnable a hover tooltip, which shows up when the pointer hovers\nover ranges of text. The callback is called when the mouse hovers\nover the document text. It should, if there is a tooltip\nassociated with position `pos` return the tooltip description\n(either directly or in a promise). The `side` argument indicates\non which side of the position the pointer is—it will be -1 if the\npointer is before the position, 1 if after the position.\n*/\n\n\nfunction hoverTooltip(source, options = {}) {\n  const setHover = StateEffect.define();\n  const hoverState = StateField.define({\n    create() {\n      return null;\n    },\n\n    update(value, tr) {\n      if (value && options.hideOnChange && (tr.docChanged || tr.selection)) return null;\n\n      for (let effect of tr.effects) if (effect.is(setHover)) return effect.value;\n\n      if (value && tr.docChanged) {\n        let newPos = tr.changes.mapPos(value.pos, -1, MapMode.TrackDel);\n        if (newPos == null) return null;\n        let copy = Object.assign(Object.create(null), value);\n        copy.pos = newPos;\n        if (value.end != null) copy.end = tr.changes.mapPos(value.end);\n        return copy;\n      }\n\n      return value;\n    },\n\n    provide: f => showTooltip.from(f)\n  });\n  return [hoverState, ViewPlugin.define(view => new HoverPlugin(view, source, hoverState, setHover))];\n}\n\nexport { hoverTooltip, showTooltip, tooltips };","map":{"version":3,"sources":["D:/MSIT/Practicum - iLMS/AssessmentsSystem/node_modules/@codemirror/tooltip/dist/index.js"],"names":["ViewPlugin","Direction","EditorView","logException","Facet","StateEffect","StateField","MapMode","ios","navigator","exec","userAgent","test","vendor","maxTouchPoints","Outside","tooltipPlugin","fromClass","constructor","view","inView","measureReq","read","readMeasure","bind","write","writeMeasure","key","input","state","facet","showTooltip","tooltips","filter","t","tooltipViews","map","tp","createTooltip","update","x","views","i","length","tip","known","other","create","tooltipView","indexOf","dom","remove","maybeMeasure","tooltip","classList","add","class","style","top","appendChild","mount","destroy","editor","getBoundingClientRect","pos","coordsAtPos","size","innerWidth","window","innerHeight","measured","tView","bottom","right","left","width","height","textDirection","LTR","Math","min","max","above","strictSide","position","toggle","positioned","requestMeasure","eventHandlers","scroll","baseTheme","zIndex","border","backgroundColor","color","define","enables","HoverTime","HoverMaxDist","HoverPlugin","source","field","setHover","lastMouseMove","hoverTimeout","restartTimeout","pending","checkHover","addEventListener","mouseleave","mousemove","clearTimeout","setTimeout","startHover","active","now","Date","lastMove","timeStamp","_a","coords","clientX","y","clientY","contentDOM","contains","target","posAtCoords","posCoords","defaultCharacterWidth","bidi","bidiSpans","doc","lineAt","find","s","from","to","rtl","dir","RTL","open","then","result","dispatch","effects","of","e","event","isInTooltip","end","isOverRange","removeEventListener","elt","cur","parentNode","nodeType","margin","range","document","createRange","fromDOM","domAtPos","toDOM","setEnd","node","offset","setStart","rects","getClientRects","detach","rect","dist","hoverTooltip","options","hoverState","value","tr","hideOnChange","docChanged","selection","effect","is","newPos","changes","mapPos","TrackDel","copy","Object","assign","provide","f"],"mappings":"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","sourcesContent":["import { ViewPlugin, Direction, EditorView, logException } from '@codemirror/view';\nimport { Facet, StateEffect, StateField, MapMode } from '@codemirror/state';\n\nconst ios = typeof navigator != \"undefined\" &&\n    !/Edge\\/(\\d+)/.exec(navigator.userAgent) && /Apple Computer/.test(navigator.vendor) &&\n    (/Mobile\\/\\w+/.test(navigator.userAgent) || navigator.maxTouchPoints > 2);\nconst Outside = \"-10000px\";\nconst tooltipPlugin = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.inView = true;\n        this.measureReq = { read: this.readMeasure.bind(this), write: this.writeMeasure.bind(this), key: this };\n        this.input = view.state.facet(showTooltip);\n        this.tooltips = this.input.filter(t => t);\n        this.tooltipViews = this.tooltips.map(tp => this.createTooltip(tp));\n    }\n    update(update) {\n        let input = update.state.facet(showTooltip);\n        if (input == this.input) {\n            for (let t of this.tooltipViews)\n                if (t.update)\n                    t.update(update);\n        }\n        else {\n            let tooltips = input.filter(x => x);\n            let views = [];\n            for (let i = 0; i < tooltips.length; i++) {\n                let tip = tooltips[i], known = -1;\n                if (!tip)\n                    continue;\n                for (let i = 0; i < this.tooltips.length; i++) {\n                    let other = this.tooltips[i];\n                    if (other && other.create == tip.create)\n                        known = i;\n                }\n                if (known < 0) {\n                    views[i] = this.createTooltip(tip);\n                }\n                else {\n                    let tooltipView = views[i] = this.tooltipViews[known];\n                    if (tooltipView.update)\n                        tooltipView.update(update);\n                }\n            }\n            for (let t of this.tooltipViews)\n                if (views.indexOf(t) < 0)\n                    t.dom.remove();\n            this.input = input;\n            this.tooltips = tooltips;\n            this.tooltipViews = views;\n            this.maybeMeasure();\n        }\n    }\n    createTooltip(tooltip) {\n        let tooltipView = tooltip.create(this.view);\n        tooltipView.dom.classList.add(\"cm-tooltip\");\n        // FIXME drop this on the next breaking release\n        if (tooltip.class)\n            tooltipView.dom.classList.add(tooltip.class);\n        tooltipView.dom.style.top = Outside;\n        this.view.dom.appendChild(tooltipView.dom);\n        if (tooltipView.mount)\n            tooltipView.mount(this.view);\n        return tooltipView;\n    }\n    destroy() {\n        for (let { dom } of this.tooltipViews)\n            dom.remove();\n    }\n    readMeasure() {\n        return {\n            editor: this.view.dom.getBoundingClientRect(),\n            pos: this.tooltips.map(t => this.view.coordsAtPos(t.pos)),\n            size: this.tooltipViews.map(({ dom }) => dom.getBoundingClientRect()),\n            innerWidth: window.innerWidth,\n            innerHeight: window.innerHeight\n        };\n    }\n    writeMeasure(measured) {\n        let { editor } = measured;\n        for (let i = 0; i < this.tooltipViews.length; i++) {\n            let tooltip = this.tooltips[i], tView = this.tooltipViews[i], { dom } = tView;\n            let pos = measured.pos[i], size = measured.size[i];\n            // Hide tooltips that are outside of the editor.\n            if (!pos || pos.bottom <= editor.top || pos.top >= editor.bottom || pos.right <= editor.left || pos.left >= editor.right) {\n                dom.style.top = Outside;\n                continue;\n            }\n            let width = size.right - size.left, height = size.bottom - size.top;\n            let left = this.view.textDirection == Direction.LTR ? Math.min(pos.left, measured.innerWidth - width)\n                : Math.max(0, pos.left - width);\n            let above = !!tooltip.above;\n            if (!tooltip.strictSide &&\n                (above ? pos.top - (size.bottom - size.top) < 0 : pos.bottom + (size.bottom - size.top) > measured.innerHeight))\n                above = !above;\n            if (ios) {\n                dom.style.top = ((above ? pos.top - height : pos.bottom) - editor.top) + \"px\";\n                dom.style.left = (left - editor.left) + \"px\";\n                dom.style.position = \"absolute\";\n            }\n            else {\n                dom.style.top = (above ? pos.top - height : pos.bottom) + \"px\";\n                dom.style.left = left + \"px\";\n            }\n            dom.classList.toggle(\"cm-tooltip-above\", above);\n            dom.classList.toggle(\"cm-tooltip-below\", !above);\n            if (tView.positioned)\n                tView.positioned();\n        }\n    }\n    maybeMeasure() {\n        if (this.tooltips.length) {\n            if (this.view.inView || this.inView)\n                this.view.requestMeasure(this.measureReq);\n            this.inView = this.view.inView;\n        }\n    }\n}, {\n    eventHandlers: {\n        scroll() { this.maybeMeasure(); }\n    }\n});\nconst baseTheme = EditorView.baseTheme({\n    \".cm-tooltip\": {\n        position: \"fixed\",\n        zIndex: 100\n    },\n    \"&light .cm-tooltip\": {\n        border: \"1px solid #ddd\",\n        backgroundColor: \"#f5f5f5\"\n    },\n    \"&dark .cm-tooltip\": {\n        backgroundColor: \"#333338\",\n        color: \"white\"\n    }\n});\n// FIXME backward-compat shim. Delete on next major version.\n/**\n@internal\n*/\nfunction tooltips() {\n    return [];\n}\n/**\nBehavior by which an extension can provide a tooltip to be shown.\n*/\nconst showTooltip = Facet.define({\n    enables: [tooltipPlugin, baseTheme]\n});\nconst HoverTime = 750, HoverMaxDist = 6;\nclass HoverPlugin {\n    constructor(view, source, field, setHover) {\n        this.view = view;\n        this.source = source;\n        this.field = field;\n        this.setHover = setHover;\n        this.lastMouseMove = null;\n        this.hoverTimeout = -1;\n        this.restartTimeout = -1;\n        this.pending = null;\n        this.checkHover = this.checkHover.bind(this);\n        view.dom.addEventListener(\"mouseleave\", this.mouseleave = this.mouseleave.bind(this));\n        view.dom.addEventListener(\"mousemove\", this.mousemove = this.mousemove.bind(this));\n    }\n    update() {\n        if (this.pending) {\n            this.pending = null;\n            clearTimeout(this.restartTimeout);\n            this.restartTimeout = setTimeout(() => this.startHover(), 20);\n        }\n    }\n    get active() {\n        return this.view.state.field(this.field);\n    }\n    checkHover() {\n        this.hoverTimeout = -1;\n        if (this.active)\n            return;\n        let now = Date.now(), lastMove = this.lastMouseMove;\n        if (now - lastMove.timeStamp < HoverTime)\n            this.hoverTimeout = setTimeout(this.checkHover, HoverTime - (now - lastMove.timeStamp));\n        else\n            this.startHover();\n    }\n    startHover() {\n        var _a;\n        clearTimeout(this.restartTimeout);\n        let lastMove = this.lastMouseMove;\n        let coords = { x: lastMove.clientX, y: lastMove.clientY };\n        let pos = this.view.contentDOM.contains(lastMove.target)\n            ? this.view.posAtCoords(coords) : null;\n        if (pos == null)\n            return;\n        let posCoords = this.view.coordsAtPos(pos);\n        if (posCoords == null || coords.y < posCoords.top || coords.y > posCoords.bottom ||\n            coords.x < posCoords.left - this.view.defaultCharacterWidth ||\n            coords.x > posCoords.right + this.view.defaultCharacterWidth)\n            return;\n        let bidi = this.view.bidiSpans(this.view.state.doc.lineAt(pos)).find(s => s.from <= pos && s.to >= pos);\n        let rtl = bidi && bidi.dir == Direction.RTL ? -1 : 1;\n        let open = this.source(this.view, pos, (coords.x < posCoords.left ? -rtl : rtl));\n        if ((_a = open) === null || _a === void 0 ? void 0 : _a.then) {\n            let pending = this.pending = { pos };\n            open.then(result => {\n                if (this.pending == pending) {\n                    this.pending = null;\n                    if (result)\n                        this.view.dispatch({ effects: this.setHover.of(result) });\n                }\n            }, e => logException(this.view.state, e, \"hover tooltip\"));\n        }\n        else if (open) {\n            this.view.dispatch({ effects: this.setHover.of(open) });\n        }\n    }\n    mousemove(event) {\n        var _a;\n        this.lastMouseMove = event;\n        if (this.hoverTimeout < 0)\n            this.hoverTimeout = setTimeout(this.checkHover, HoverTime);\n        let tooltip = this.active;\n        if (tooltip && !isInTooltip(event.target) || this.pending) {\n            let { pos } = tooltip || this.pending, end = (_a = tooltip === null || tooltip === void 0 ? void 0 : tooltip.end) !== null && _a !== void 0 ? _a : pos;\n            if ((pos == end ? this.view.posAtCoords({ x: event.clientX, y: event.clientY }) != pos\n                : !isOverRange(this.view, pos, end, event.clientX, event.clientY, HoverMaxDist))) {\n                this.view.dispatch({ effects: this.setHover.of(null) });\n                this.pending = null;\n            }\n        }\n    }\n    mouseleave() {\n        clearTimeout(this.hoverTimeout);\n        this.hoverTimeout = -1;\n        if (this.active)\n            this.view.dispatch({ effects: this.setHover.of(null) });\n    }\n    destroy() {\n        clearTimeout(this.hoverTimeout);\n        this.view.dom.removeEventListener(\"mouseleave\", this.mouseleave);\n        this.view.dom.removeEventListener(\"mousemove\", this.mousemove);\n    }\n}\nfunction isInTooltip(elt) {\n    for (let cur = elt; cur; cur = cur.parentNode)\n        if (cur.nodeType == 1 && cur.classList.contains(\"cm-tooltip\"))\n            return true;\n    return false;\n}\nfunction isOverRange(view, from, to, x, y, margin) {\n    let range = document.createRange();\n    let fromDOM = view.domAtPos(from), toDOM = view.domAtPos(to);\n    range.setEnd(toDOM.node, toDOM.offset);\n    range.setStart(fromDOM.node, fromDOM.offset);\n    let rects = range.getClientRects();\n    range.detach();\n    for (let i = 0; i < rects.length; i++) {\n        let rect = rects[i];\n        let dist = Math.max(rect.top - y, y - rect.bottom, rect.left - x, x - rect.right);\n        if (dist <= margin)\n            return true;\n    }\n    return false;\n}\n/**\nEnable a hover tooltip, which shows up when the pointer hovers\nover ranges of text. The callback is called when the mouse hovers\nover the document text. It should, if there is a tooltip\nassociated with position `pos` return the tooltip description\n(either directly or in a promise). The `side` argument indicates\non which side of the position the pointer is—it will be -1 if the\npointer is before the position, 1 if after the position.\n*/\nfunction hoverTooltip(source, options = {}) {\n    const setHover = StateEffect.define();\n    const hoverState = StateField.define({\n        create() { return null; },\n        update(value, tr) {\n            if (value && (options.hideOnChange && (tr.docChanged || tr.selection)))\n                return null;\n            for (let effect of tr.effects)\n                if (effect.is(setHover))\n                    return effect.value;\n            if (value && tr.docChanged) {\n                let newPos = tr.changes.mapPos(value.pos, -1, MapMode.TrackDel);\n                if (newPos == null)\n                    return null;\n                let copy = Object.assign(Object.create(null), value);\n                copy.pos = newPos;\n                if (value.end != null)\n                    copy.end = tr.changes.mapPos(value.end);\n                return copy;\n            }\n            return value;\n        },\n        provide: f => showTooltip.from(f)\n    });\n    return [\n        hoverState,\n        ViewPlugin.define(view => new HoverPlugin(view, source, hoverState, setHover))\n    ];\n}\n\nexport { hoverTooltip, showTooltip, tooltips };\n"]},"metadata":{},"sourceType":"module"}