{"ast":null,"code":"import { NodeProp, NodeType } from 'lezer-tree';\nimport { StyleModule } from 'style-mod';\nimport { EditorView, ViewPlugin, Decoration } from '@codemirror/view';\nimport { Facet, Prec } from '@codemirror/state';\nimport { syntaxTree } from '@codemirror/language';\nimport { RangeSetBuilder } from '@codemirror/rangeset';\nlet nextTagID = 0; /// Highlighting tags are markers that denote a highlighting category.\n/// They are [associated](#highlight.styleTags) with parts of a syntax\n/// tree by a language mode, and then mapped to an actual CSS style by\n/// a [highlight style](#highlight.HighlightStyle).\n///\n/// Because syntax tree node types and highlight styles have to be\n/// able to talk the same language, CodeMirror uses a mostly _closed_\n/// [vocabulary](#highlight.tags) of syntax tags (as opposed to\n/// traditional open string-based systems, which make it hard for\n/// highlighting themes to cover all the tokens produced by the\n/// various languages).\n///\n/// It _is_ possible to [define](#highlight.Tag^define) your own\n/// highlighting tags for system-internal use (where you control both\n/// the language package and the highlighter), but such tags will not\n/// be picked up by regular highlighters (though you can derive them\n/// from standard tags to allow highlighters to fall back to those).\n\nclass Tag {\n  /// @internal\n  constructor( /// The set of tags that match this tag, starting with this one\n  /// itself, sorted in order of decreasing specificity. @internal\n  set, /// The base unmodified tag that this one is based on, if it's\n  /// modified @internal\n  base, /// The modifiers applied to this.base @internal\n  modified) {\n    this.set = set;\n    this.base = base;\n    this.modified = modified; /// @internal\n\n    this.id = nextTagID++;\n  } /// Define a new tag. If `parent` is given, the tag is treated as a\n  /// sub-tag of that parent, and [highlight\n  /// styles](#highlight.HighlightStyle) that don't mention this tag\n  /// will try to fall back to the parent tag (or grandparent tag,\n  /// etc).\n\n\n  static define(parent) {\n    if (parent === null || parent === void 0 ? void 0 : parent.base) throw new Error(\"Can not derive from a modified tag\");\n    let tag = new Tag([], null, []);\n    tag.set.push(tag);\n    if (parent) for (let t of parent.set) tag.set.push(t);\n    return tag;\n  } /// Define a tag _modifier_, which is a function that, given a tag,\n  /// will return a tag that is a subtag of the original. Applying the\n  /// same modifier to a twice tag will return the same value (`m1(t1)\n  /// == m1(t1)`) and applying multiple modifiers will, regardless or\n  /// order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n  ///\n  /// When multiple modifiers are applied to a given base tag, each\n  /// smaller set of modifiers is registered as a parent, so that for\n  /// example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n  /// `m1(m3(t1)`, and so on.\n\n\n  static defineModifier() {\n    let mod = new Modifier();\n    return tag => {\n      if (tag.modified.indexOf(mod) > -1) return tag;\n      return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));\n    };\n  }\n\n}\n\nlet nextModifierID = 0;\n\nclass Modifier {\n  constructor() {\n    this.instances = [];\n    this.id = nextModifierID++;\n  }\n\n  static get(base, mods) {\n    if (!mods.length) return base;\n    let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));\n    if (exists) return exists;\n    let set = [],\n        tag = new Tag(set, base, mods);\n\n    for (let m of mods) m.instances.push(tag);\n\n    let configs = permute(mods);\n\n    for (let parent of base.set) for (let config of configs) set.push(Modifier.get(parent, config));\n\n    return tag;\n  }\n\n}\n\nfunction sameArray(a, b) {\n  return a.length == b.length && a.every((x, i) => x == b[i]);\n}\n\nfunction permute(array) {\n  let result = [array];\n\n  for (let i = 0; i < array.length; i++) {\n    for (let a of permute(array.slice(0, i).concat(array.slice(i + 1)))) result.push(a);\n  }\n\n  return result;\n} /// This function is used to add a set of tags to a language syntax\n/// via\n/// [`Parser.configure`](https://lezer.codemirror.net/docs/ref#lezer.Parser.configure).\n///\n/// The argument object maps node selectors to [highlighting\n/// tags](#highlight.Tag) or arrays of tags.\n///\n/// Node selectors may hold one or more (space-separated) node paths.\n/// Such a path can be a [node\n/// name](https://lezer.codemirror.net/docs/ref#tree.NodeType.name),\n/// or multiple node names (or `*` wildcards) separated by slash\n/// characters, as in `\"Block/Declaration/VariableName\"`. Such a path\n/// matches the final node but only if its direct parent nodes are the\n/// other nodes mentioned. A `*` in such a path matches any parent,\n/// but only a single levelâ€”wildcards that match multiple parents\n/// aren't supported, both for efficiency reasons and because Lezer\n/// trees make it rather hard to reason about what they would match.)\n///\n/// A path can be ended with `/...` to indicate that the tag assigned\n/// to the node should also apply to all child nodes, even if they\n/// match their own style (by default, only the innermost style is\n/// used).\n///\n/// When a path ends in `!`, as in `Attribute!`, no further matching\n/// happens for the node's child nodes, and the entire node gets the\n/// given style.\n///\n/// In this notation, node names that contain `/`, `!`, `*`, or `...`\n/// must be quoted as JSON strings.\n///\n/// For example:\n///\n/// ```javascript\n/// parser.withProps(\n///   styleTags({\n///     // Style Number and BigNumber nodes\n///     \"Number BigNumber\": tags.number,\n///     // Style Escape nodes whose parent is String\n///     \"String/Escape\": tags.escape,\n///     // Style anything inside Attributes nodes\n///     \"Attributes!\": tags.meta,\n///     // Add a style to all content inside Italic nodes\n///     \"Italic/...\": tags.emphasis,\n///     // Style InvalidString nodes as both `string` and `invalid`\n///     \"InvalidString\": [tags.string, tags.invalid],\n///     // Style the node named \"/\" as punctuation\n///     '\"/\"': tags.punctuation\n///   })\n/// )\n/// ```\n\n\nfunction styleTags(spec) {\n  let byName = Object.create(null);\n\n  for (let prop in spec) {\n    let tags = spec[prop];\n    if (!Array.isArray(tags)) tags = [tags];\n\n    for (let part of prop.split(\" \")) if (part) {\n      let pieces = [],\n          mode = 2\n      /* Normal */\n      ,\n          rest = part;\n\n      for (let pos = 0;;) {\n        if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n          mode = 1\n          /* Inherit */\n          ;\n          break;\n        }\n\n        let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n        if (!m) throw new RangeError(\"Invalid path: \" + part);\n        pieces.push(m[0] == \"*\" ? null : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n        pos += m[0].length;\n        if (pos == part.length) break;\n        let next = part[pos++];\n\n        if (pos == part.length && next == \"!\") {\n          mode = 0\n          /* Opaque */\n          ;\n          break;\n        }\n\n        if (next != \"/\") throw new RangeError(\"Invalid path: \" + part);\n        rest = part.slice(pos);\n      }\n\n      let last = pieces.length - 1,\n          inner = pieces[last];\n      if (!inner) throw new RangeError(\"Invalid path: \" + part);\n      let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n      byName[inner] = rule.sort(byName[inner]);\n    }\n  }\n\n  return ruleNodeProp.add(byName);\n}\n\nconst ruleNodeProp = new NodeProp();\nconst highlightStyle = Facet.define({\n  combine(stylings) {\n    return stylings.length ? HighlightStyle.combinedMatch(stylings) : null;\n  }\n\n});\nconst fallbackHighlightStyle = Facet.define({\n  combine(values) {\n    return values.length ? values[0].match : null;\n  }\n\n});\n\nfunction noHighlight() {\n  return null;\n}\n\nfunction getHighlightStyle(state) {\n  return state.facet(highlightStyle) || state.facet(fallbackHighlightStyle) || noHighlight;\n}\n\nclass Rule {\n  constructor(tags, mode, context, next) {\n    this.tags = tags;\n    this.mode = mode;\n    this.context = context;\n    this.next = next;\n  }\n\n  sort(other) {\n    if (!other || other.depth < this.depth) {\n      this.next = other;\n      return this;\n    }\n\n    other.next = this.sort(other.next);\n    return other;\n  }\n\n  get depth() {\n    return this.context ? this.context.length : 0;\n  }\n\n} /// A highlight style associates CSS styles with higlighting\n/// [tags](#highlight.Tag).\n\n\nclass HighlightStyle {\n  constructor(spec, options) {\n    this.map = Object.create(null);\n    let modSpec;\n\n    function def(spec) {\n      let cls = StyleModule.newName();\n      (modSpec || (modSpec = Object.create(null)))[\".\" + cls] = spec;\n      return cls;\n    }\n\n    this.all = typeof options.all == \"string\" ? options.all : options.all ? def(options.all) : null;\n\n    for (let style of spec) {\n      let cls = (style.class || def(Object.assign({}, style, {\n        tag: null\n      }))) + (this.all ? \" \" + this.all : \"\");\n      let tags = style.tag;\n      if (!Array.isArray(tags)) this.map[tags.id] = cls;else for (let tag of tags) this.map[tag.id] = cls;\n    }\n\n    this.module = modSpec ? new StyleModule(modSpec) : null;\n    this.scope = options.scope || null;\n    this.match = this.match.bind(this);\n    let ext = [treeHighlighter];\n    if (this.module) ext.push(EditorView.styleModule.of(this.module));\n    this.extension = ext.concat(highlightStyle.of(this));\n    this.fallback = ext.concat(fallbackHighlightStyle.of(this));\n  } /// Returns the CSS class associated with the given tag, if any.\n  /// This method is bound to the instance by the constructor.\n\n\n  match(tag, scope) {\n    if (this.scope && scope != this.scope) return null;\n\n    for (let t of tag.set) {\n      let match = this.map[t.id];\n\n      if (match !== undefined) {\n        if (t != tag) this.map[tag.id] = match;\n        return match;\n      }\n    }\n\n    return this.map[tag.id] = this.all;\n  } /// Combines an array of highlight styles into a single match\n  /// function that returns all of the classes assigned by the styles\n  /// for a given tag.\n\n\n  static combinedMatch(styles) {\n    if (styles.length == 1) return styles[0].match;\n    let cache = styles.some(s => s.scope) ? undefined : Object.create(null);\n    return (tag, scope) => {\n      let cached = cache && cache[tag.id];\n      if (cached !== undefined) return cached;\n      let result = null;\n\n      for (let style of styles) {\n        let value = style.match(tag, scope);\n        if (value) result = result ? result + \" \" + value : value;\n      }\n\n      if (cache) cache[tag.id] = result;\n      return result;\n    };\n  } /// Create a highlighter style that associates the given styles to\n  /// the given tags. The spec must be objects that hold a style tag\n  /// or array of tags in their `tag` property, and either a single\n  /// `class` property providing a static CSS class (for highlighters\n  /// like [`classHighlightStyle`](#highlight.classHighlightStyle)\n  /// that rely on external styling), or a\n  /// [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style\n  /// set of CSS properties (which define the styling for those tags).\n  ///\n  /// The CSS rules created for a highlighter will be emitted in the\n  /// order of the spec's properties. That means that for elements that\n  /// have multiple tags associated with them, styles defined further\n  /// down in the list will have a higher CSS precedence than styles\n  /// defined earlier.\n\n\n  static define(specs, options) {\n    return new HighlightStyle(specs, options || {});\n  } /// Returns the CSS classes (if any) that the highlight styles\n  /// active in the given state would assign to the given a style\n  /// [tag](#highlight.Tag) and (optional) language\n  /// [scope](#highlight.HighlightStyle^define^options.scope).\n\n\n  static get(state, tag, scope) {\n    return getHighlightStyle(state)(tag, scope || NodeType.none);\n  }\n\n} /// Given a string of code and a language, parse the code in that\n/// language and run the tree highlighter over the resulting syntax\n/// tree.\n\n\nfunction highlightTree(tree, /// Get the CSS classes used to style a given [tag](#highlight.Tag),\n/// or `null` if it isn't styled. (You'll often want to pass a\n/// highlight style's [`match`](#highlight.HighlightStyle.match)\n/// method here.)\ngetStyle, /// Assign styling to a region of the text. Will be called, in order\n/// of position, for any ranges where more than zero classes apply.\n/// `classes` is a space separated string of CSS classes.\nputStyle) {\n  highlightTreeRange(tree, 0, tree.length, getStyle, putStyle);\n}\n\nclass TreeHighlighter {\n  constructor(view) {\n    this.markCache = Object.create(null);\n    this.tree = syntaxTree(view.state);\n    this.decorations = this.buildDeco(view, getHighlightStyle(view.state));\n  }\n\n  update(update) {\n    let tree = syntaxTree(update.state),\n        style = getHighlightStyle(update.state);\n    let styleChange = style != update.startState.facet(highlightStyle);\n\n    if (tree.length < update.view.viewport.to && !styleChange) {\n      this.decorations = this.decorations.map(update.changes);\n    } else if (tree != this.tree || update.viewportChanged || styleChange) {\n      this.tree = tree;\n      this.decorations = this.buildDeco(update.view, style);\n    }\n  }\n\n  buildDeco(view, match) {\n    if (match == noHighlight || !this.tree.length) return Decoration.none;\n    let builder = new RangeSetBuilder();\n\n    for (let {\n      from,\n      to\n    } of view.visibleRanges) {\n      highlightTreeRange(this.tree, from, to, match, (from, to, style) => {\n        builder.add(from, to, this.markCache[style] || (this.markCache[style] = Decoration.mark({\n          class: style\n        })));\n      });\n    }\n\n    return builder.finish();\n  }\n\n} // This extension installs a highlighter that highlights based on the\n// syntax tree and highlight style.\n\n\nconst treeHighlighter = Prec.fallback(ViewPlugin.fromClass(TreeHighlighter, {\n  decorations: v => v.decorations\n}));\nconst nodeStack = [\"\"];\n\nfunction highlightTreeRange(tree, from, to, style, span) {\n  let spanStart = from,\n      spanClass = \"\";\n  let cursor = tree.topNode.cursor;\n\n  function node(inheritedClass, depth, scope) {\n    let {\n      type,\n      from: start,\n      to: end\n    } = cursor;\n    if (start >= to || end <= from) return;\n    nodeStack[depth] = type.name;\n    if (type.isTop) scope = type;\n    let cls = inheritedClass;\n    let rule = type.prop(ruleNodeProp),\n        opaque = false;\n\n    while (rule) {\n      if (!rule.context || matchContext(rule.context, nodeStack, depth)) {\n        for (let tag of rule.tags) {\n          let st = style(tag, scope);\n\n          if (st) {\n            if (cls) cls += \" \";\n            cls += st;\n            if (rule.mode == 1\n            /* Inherit */\n            ) inheritedClass += (inheritedClass ? \" \" : \"\") + st;else if (rule.mode == 0\n            /* Opaque */\n            ) opaque = true;\n          }\n        }\n\n        break;\n      }\n\n      rule = rule.next;\n    }\n\n    if (cls != spanClass) {\n      if (start > spanStart && spanClass) span(spanStart, cursor.from, spanClass);\n      spanStart = start;\n      spanClass = cls;\n    }\n\n    if (!opaque && cursor.firstChild()) {\n      do {\n        let end = cursor.to;\n        node(inheritedClass, depth + 1, scope);\n\n        if (spanClass != cls) {\n          let pos = Math.min(to, end);\n          if (pos > spanStart && spanClass) span(spanStart, pos, spanClass);\n          spanStart = pos;\n          spanClass = cls;\n        }\n      } while (cursor.nextSibling());\n\n      cursor.parent();\n    }\n  }\n\n  node(\"\", 0, tree.type);\n}\n\nfunction matchContext(context, stack, depth) {\n  if (context.length > depth - 1) return false;\n\n  for (let d = depth - 1, i = context.length - 1; i >= 0; i--, d--) {\n    let check = context[i];\n    if (check && check != stack[d]) return false;\n  }\n\n  return true;\n}\n\nconst t = Tag.define;\nconst comment = t(),\n      name = t(),\n      typeName = t(name),\n      literal = t(),\n      string = t(literal),\n      number = t(literal),\n      content = t(),\n      heading = t(content),\n      keyword = t(),\n      operator = t(),\n      punctuation = t(),\n      bracket = t(punctuation),\n      meta = t(); /// The default set of highlighting [tags](#highlight.Tag^define) used\n/// by regular language packages and themes.\n///\n/// This collection is heavily biased towards programming languages,\n/// and necessarily incomplete. A full ontology of syntactic\n/// constructs would fill a stack of books, and be impractical to\n/// write themes for. So try to make do with this set. If all else\n/// fails, [open an\n/// issue](https://github.com/codemirror/codemirror.next) to propose a\n/// new tag, or [define](#highlight.Tag^define) a local custom tag for\n/// your use case.\n///\n/// Note that it is not obligatory to always attach the most specific\n/// tag possible to an elementâ€”if your grammar can't easily\n/// distinguish a certain type of element (such as a local variable),\n/// it is okay to style it as its more general variant (a variable).\n/// \n/// For tags that extend some parent tag, the documentation links to\n/// the parent.\n\nconst tags = {\n  /// A comment.\n  comment,\n  /// A line [comment](#highlight.tags.comment).\n  lineComment: t(comment),\n  /// A block [comment](#highlight.tags.comment).\n  blockComment: t(comment),\n  /// A documentation [comment](#highlight.tags.comment).\n  docComment: t(comment),\n  /// Any kind of identifier.\n  name,\n  /// The [name](#highlight.tags.name) of a variable.\n  variableName: t(name),\n  /// A type [name](#highlight.tags.name).\n  typeName: typeName,\n  /// A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n  tagName: t(typeName),\n  /// A property, field, or attribute [name](#highlight.tags.name).\n  propertyName: t(name),\n  /// The [name](#highlight.tags.name) of a class.\n  className: t(name),\n  /// A label [name](#highlight.tags.name).\n  labelName: t(name),\n  /// A namespace [name](#highlight.tags.name).\n  namespace: t(name),\n  /// The [name](#highlight.tags.name) of a macro.\n  macroName: t(name),\n  /// A literal value.\n  literal,\n  /// A string [literal](#highlight.tags.literal).\n  string,\n  /// A documentation [string](#highlight.tags.string).\n  docString: t(string),\n  /// A character literal (subtag of [string](#highlight.tags.string)).\n  character: t(string),\n  /// A number [literal](#highlight.tags.literal).\n  number,\n  /// An integer [number](#highlight.tags.number) literal.\n  integer: t(number),\n  /// A floating-point [number](#highlight.tags.number) literal.\n  float: t(number),\n  /// A boolean [literal](#highlight.tags.literal).\n  bool: t(literal),\n  /// Regular expression [literal](#highlight.tags.literal).\n  regexp: t(literal),\n  /// An escape [literal](#highlight.tags.literal), for example a\n  /// backslash escape in a string.\n  escape: t(literal),\n  /// A color [literal](#highlight.tags.literal).\n  color: t(literal),\n  /// A URL [literal](#highlight.tags.literal).\n  url: t(literal),\n  /// A language keyword.\n  keyword,\n  /// The [keyword](#highlight.tags.keyword) for the self or this\n  /// object.\n  self: t(keyword),\n  /// The [keyword](#highlight.tags.keyword) for null.\n  null: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) denoting some atomic value.\n  atom: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) that represents a unit.\n  unit: t(keyword),\n  /// A modifier [keyword](#highlight.tags.keyword).\n  modifier: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) that acts as an operator.\n  operatorKeyword: t(keyword),\n  /// A control-flow related [keyword](#highlight.tags.keyword).\n  controlKeyword: t(keyword),\n  /// A [keyword](#highlight.tags.keyword) that defines something.\n  definitionKeyword: t(keyword),\n  /// An operator.\n  operator,\n  /// An [operator](#highlight.tags.operator) that defines something.\n  derefOperator: t(operator),\n  /// Arithmetic-related [operator](#highlight.tags.operator).\n  arithmeticOperator: t(operator),\n  /// Logical [operator](#highlight.tags.operator).\n  logicOperator: t(operator),\n  /// Bit [operator](#highlight.tags.operator).\n  bitwiseOperator: t(operator),\n  /// Comparison [operator](#highlight.tags.operator).\n  compareOperator: t(operator),\n  /// [Operator](#highlight.tags.operator) that updates its operand.\n  updateOperator: t(operator),\n  /// [Operator](#highlight.tags.operator) that defines something.\n  definitionOperator: t(operator),\n  /// Type-related [operator](#highlight.tags.operator).\n  typeOperator: t(operator),\n  /// Control-flow [operator](#highlight.tags.operator).\n  controlOperator: t(operator),\n  /// Program or markup punctuation.\n  punctuation,\n  /// [Punctuation](#highlight.tags.punctuation) that separates\n  /// things.\n  separator: t(punctuation),\n  /// Bracket-style [punctuation](#highlight.tags.punctuation).\n  bracket,\n  /// Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n  /// tokens).\n  angleBracket: t(bracket),\n  /// Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n  /// tokens).\n  squareBracket: t(bracket),\n  /// Parentheses (usually `(` and `)` tokens). Subtag of\n  /// [bracket](#highlight.tags.bracket).\n  paren: t(bracket),\n  /// Braces (usually `{` and `}` tokens). Subtag of\n  /// [bracket](#highlight.tags.bracket).\n  brace: t(bracket),\n  /// Content, for example plain text in XML or markup documents.\n  content,\n  /// [Content](#highlight.tags.content) that represents a heading.\n  heading,\n  /// A level 1 [heading](#highlight.tags.heading).\n  heading1: t(heading),\n  /// A level 2 [heading](#highlight.tags.heading).\n  heading2: t(heading),\n  /// A level 3 [heading](#highlight.tags.heading).\n  heading3: t(heading),\n  /// A level 4 [heading](#highlight.tags.heading).\n  heading4: t(heading),\n  /// A level 5 [heading](#highlight.tags.heading).\n  heading5: t(heading),\n  /// A level 6 [heading](#highlight.tags.heading).\n  heading6: t(heading),\n  /// A prose separator (such as a horizontal rule).\n  contentSeparator: t(content),\n  /// [Content](#highlight.tags.content) that represents a list.\n  list: t(content),\n  /// [Content](#highlight.tags.content) that represents a quote.\n  quote: t(content),\n  /// [Content](#highlight.tags.content) that is emphasized.\n  emphasis: t(content),\n  /// [Content](#highlight.tags.content) that is styled strong.\n  strong: t(content),\n  /// [Content](#highlight.tags.content) that is part of a link.\n  link: t(content),\n  /// [Content](#highlight.tags.content) that is styled as code or\n  /// monospace.\n  monospace: t(content),\n  /// Inserted text in a change-tracking format.\n  inserted: t(),\n  /// Deleted text.\n  deleted: t(),\n  /// Changed text.\n  changed: t(),\n  /// An invalid or unsyntactic element.\n  invalid: t(),\n  /// Metadata or meta-instruction.\n  meta,\n  /// [Metadata](#highlight.tags.meta) that applies to the entire\n  /// document.\n  documentMeta: t(meta),\n  /// [Metadata](#highlight.tags.meta) that annotates or adds\n  /// attributes to a given syntactic element.\n  annotation: t(meta),\n  /// Processing instruction or preprocessor directive. Subtag of\n  /// [meta](#highlight.tags.meta).\n  processingInstruction: t(meta),\n  /// [Modifier](#highlight.Tag^defineModifier) that indicates that a\n  /// given element is being defined. Expected to be used with the\n  /// various [name](#highlight.tags.name) tags.\n  definition: Tag.defineModifier(),\n  /// [Modifier](#highlight.Tag^defineModifier) that indicates that\n  /// something is constant. Mostly expected to be used with\n  /// [variable names](#highlight.tags.variableName).\n  constant: Tag.defineModifier(),\n  /// [Modifier](#highlight.Tag^defineModifier) used to indicate that\n  /// a [variable](#highlight.tags.variableName) or [property\n  /// name](#highlight.tags.propertyName) is being called or defined\n  /// as a function.\n  function: Tag.defineModifier(),\n  /// [Modifier](#highlight.Tag^defineModifier) that can be applied to\n  /// [names](#highlight.tags.name) to indicate that they belong to\n  /// the language's standard environment.\n  standard: Tag.defineModifier(),\n  /// [Modifier](#highlight.Tag^defineModifier) that indicates a given\n  /// [names](#highlight.tags.name) is local to some scope.\n  local: Tag.defineModifier(),\n  /// A generic variant [modifier](#highlight.Tag^defineModifier) that\n  /// can be used to tag language-specific alternative variants of\n  /// some common tag. It is recommended for themes to define special\n  /// forms of at least the [string](#highlight.tags.string) and\n  /// [variable name](#highlight.tags.variableName) tags, since those\n  /// come up a lot.\n  special: Tag.defineModifier()\n}; /// A default highlight style (works well with light themes).\n\nconst defaultHighlightStyle = HighlightStyle.define([{\n  tag: tags.link,\n  textDecoration: \"underline\"\n}, {\n  tag: tags.heading,\n  textDecoration: \"underline\",\n  fontWeight: \"bold\"\n}, {\n  tag: tags.emphasis,\n  fontStyle: \"italic\"\n}, {\n  tag: tags.strong,\n  fontWeight: \"bold\"\n}, {\n  tag: tags.keyword,\n  color: \"#708\"\n}, {\n  tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],\n  color: \"#219\"\n}, {\n  tag: [tags.literal, tags.inserted],\n  color: \"#164\"\n}, {\n  tag: [tags.string, tags.deleted],\n  color: \"#a11\"\n}, {\n  tag: [tags.regexp, tags.escape, tags.special(tags.string)],\n  color: \"#e40\"\n}, {\n  tag: tags.definition(tags.variableName),\n  color: \"#00f\"\n}, {\n  tag: tags.local(tags.variableName),\n  color: \"#30a\"\n}, {\n  tag: [tags.typeName, tags.namespace],\n  color: \"#085\"\n}, {\n  tag: tags.className,\n  color: \"#167\"\n}, {\n  tag: [tags.special(tags.variableName), tags.macroName],\n  color: \"#256\"\n}, {\n  tag: tags.definition(tags.propertyName),\n  color: \"#00c\"\n}, {\n  tag: tags.comment,\n  color: \"#940\"\n}, {\n  tag: tags.meta,\n  color: \"#7a757a\"\n}, {\n  tag: tags.invalid,\n  color: \"#f00\"\n}]); /// This is a highlight style that adds stable, predictable classes to\n/// tokens, for styling with external CSS.\n///\n/// These tags are mapped to their name prefixed with `\"cmt-\"` (for\n/// example `\"cmt-comment\"`):\n///\n/// * [`link`](#highlight.tags.link)\n/// * [`heading`](#highlight.tags.heading)\n/// * [`emphasis`](#highlight.tags.emphasis)\n/// * [`strong`](#highlight.tags.strong)\n/// * [`keyword`](#highlight.tags.keyword)\n/// * [`atom`](#highlight.tags.atom) [`bool`](#highlight.tags.bool)\n/// * [`url`](#highlight.tags.url)\n/// * [`labelName`](#highlight.tags.labelName)\n/// * [`inserted`](#highlight.tags.inserted)\n/// * [`deleted`](#highlight.tags.deleted)\n/// * [`literal`](#highlight.tags.literal)\n/// * [`string`](#highlight.tags.string)\n/// * [`number`](#highlight.tags.number)\n/// * [`variableName`](#highlight.tags.variableName)\n/// * [`typeName`](#highlight.tags.typeName)\n/// * [`namespace`](#highlight.tags.namespace)\n/// * [`macroName`](#highlight.tags.macroName)\n/// * [`propertyName`](#highlight.tags.propertyName)\n/// * [`operator`](#highlight.tags.operator)\n/// * [`comment`](#highlight.tags.comment)\n/// * [`meta`](#highlight.tags.meta)\n/// * [`punctuation`](#highlight.tags.puncutation)\n/// * [`invalid`](#highlight.tags.invalid)\n///\n/// In addition, these mappings are provided:\n///\n/// * [`regexp`](#highlight.tags.regexp),\n///   [`escape`](#highlight.tags.escape), and\n///   [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n///   are mapped to `\"cmt-string2\"`\n/// * [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"cmt-variableName2\"`\n/// * [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"cmt-variableName cmt-local\"`\n/// * [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"cmt-variableName cmt-definition\"`\n\nconst classHighlightStyle = HighlightStyle.define([{\n  tag: tags.link,\n  class: \"cmt-link\"\n}, {\n  tag: tags.heading,\n  class: \"cmt-heading\"\n}, {\n  tag: tags.emphasis,\n  class: \"cmt-emphasis\"\n}, {\n  tag: tags.strong,\n  class: \"cmt-strong\"\n}, {\n  tag: tags.keyword,\n  class: \"cmt-keyword\"\n}, {\n  tag: tags.atom,\n  class: \"cmt-atom\"\n}, {\n  tag: tags.bool,\n  class: \"cmt-bool\"\n}, {\n  tag: tags.url,\n  class: \"cmt-url\"\n}, {\n  tag: tags.labelName,\n  class: \"cmt-labelName\"\n}, {\n  tag: tags.inserted,\n  class: \"cmt-inserted\"\n}, {\n  tag: tags.deleted,\n  class: \"cmt-deleted\"\n}, {\n  tag: tags.literal,\n  class: \"cmt-literal\"\n}, {\n  tag: tags.string,\n  class: \"cmt-string\"\n}, {\n  tag: tags.number,\n  class: \"cmt-number\"\n}, {\n  tag: [tags.regexp, tags.escape, tags.special(tags.string)],\n  class: \"cmt-string2\"\n}, {\n  tag: tags.variableName,\n  class: \"cmt-variableName\"\n}, {\n  tag: tags.local(tags.variableName),\n  class: \"cmt-variableName cmt-local\"\n}, {\n  tag: tags.definition(tags.variableName),\n  class: \"cmt-variableName cmt-definition\"\n}, {\n  tag: tags.special(tags.variableName),\n  class: \"cmt-variableName2\"\n}, {\n  tag: tags.typeName,\n  class: \"cmt-typeName\"\n}, {\n  tag: tags.namespace,\n  class: \"cmt-namespace\"\n}, {\n  tag: tags.macroName,\n  class: \"cmt-macroName\"\n}, {\n  tag: tags.propertyName,\n  class: \"cmt-propertyName\"\n}, {\n  tag: tags.operator,\n  class: \"cmt-operator\"\n}, {\n  tag: tags.comment,\n  class: \"cmt-comment\"\n}, {\n  tag: tags.meta,\n  class: \"cmt-meta\"\n}, {\n  tag: tags.invalid,\n  class: \"cmt-invalid\"\n}, {\n  tag: tags.punctuation,\n  class: \"cmt-punctuation\"\n}]);\nexport { HighlightStyle, Tag, classHighlightStyle, defaultHighlightStyle, highlightTree, styleTags, tags };","map":{"version":3,"sources":["D:/MSIT/Practicum - iLMS/AssessmentsSystem/node_modules/@codemirror/highlight/dist/index.js"],"names":["NodeProp","NodeType","StyleModule","EditorView","ViewPlugin","Decoration","Facet","Prec","syntaxTree","RangeSetBuilder","nextTagID","Tag","constructor","set","base","modified","id","define","parent","Error","tag","push","t","defineModifier","mod","Modifier","indexOf","get","concat","sort","a","b","nextModifierID","instances","mods","length","exists","find","sameArray","m","configs","permute","config","every","x","i","array","result","slice","styleTags","spec","byName","Object","create","prop","tags","Array","isArray","part","split","pieces","mode","rest","pos","exec","RangeError","JSON","parse","next","last","inner","rule","Rule","ruleNodeProp","add","highlightStyle","combine","stylings","HighlightStyle","combinedMatch","fallbackHighlightStyle","values","match","noHighlight","getHighlightStyle","state","facet","context","other","depth","options","map","modSpec","def","cls","newName","all","style","class","assign","module","scope","bind","ext","treeHighlighter","styleModule","of","extension","fallback","undefined","styles","cache","some","s","cached","value","specs","none","highlightTree","tree","getStyle","putStyle","highlightTreeRange","TreeHighlighter","view","markCache","decorations","buildDeco","update","styleChange","startState","viewport","to","changes","viewportChanged","builder","from","visibleRanges","mark","finish","fromClass","v","nodeStack","span","spanStart","spanClass","cursor","topNode","node","inheritedClass","type","start","end","name","isTop","opaque","matchContext","st","firstChild","Math","min","nextSibling","stack","d","check","comment","typeName","literal","string","number","content","heading","keyword","operator","punctuation","bracket","meta","lineComment","blockComment","docComment","variableName","tagName","propertyName","className","labelName","namespace","macroName","docString","character","integer","float","bool","regexp","escape","color","url","self","null","atom","unit","modifier","operatorKeyword","controlKeyword","definitionKeyword","derefOperator","arithmeticOperator","logicOperator","bitwiseOperator","compareOperator","updateOperator","definitionOperator","typeOperator","controlOperator","separator","angleBracket","squareBracket","paren","brace","heading1","heading2","heading3","heading4","heading5","heading6","contentSeparator","list","quote","emphasis","strong","link","monospace","inserted","deleted","changed","invalid","documentMeta","annotation","processingInstruction","definition","constant","function","standard","local","special","defaultHighlightStyle","textDecoration","fontWeight","fontStyle","classHighlightStyle"],"mappings":"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","sourcesContent":["import { NodeProp, NodeType } from 'lezer-tree';\nimport { StyleModule } from 'style-mod';\nimport { EditorView, ViewPlugin, Decoration } from '@codemirror/view';\nimport { Facet, Prec } from '@codemirror/state';\nimport { syntaxTree } from '@codemirror/language';\nimport { RangeSetBuilder } from '@codemirror/rangeset';\n\nlet nextTagID = 0;\n/// Highlighting tags are markers that denote a highlighting category.\n/// They are [associated](#highlight.styleTags) with parts of a syntax\n/// tree by a language mode, and then mapped to an actual CSS style by\n/// a [highlight style](#highlight.HighlightStyle).\n///\n/// Because syntax tree node types and highlight styles have to be\n/// able to talk the same language, CodeMirror uses a mostly _closed_\n/// [vocabulary](#highlight.tags) of syntax tags (as opposed to\n/// traditional open string-based systems, which make it hard for\n/// highlighting themes to cover all the tokens produced by the\n/// various languages).\n///\n/// It _is_ possible to [define](#highlight.Tag^define) your own\n/// highlighting tags for system-internal use (where you control both\n/// the language package and the highlighter), but such tags will not\n/// be picked up by regular highlighters (though you can derive them\n/// from standard tags to allow highlighters to fall back to those).\nclass Tag {\n    /// @internal\n    constructor(\n    /// The set of tags that match this tag, starting with this one\n    /// itself, sorted in order of decreasing specificity. @internal\n    set, \n    /// The base unmodified tag that this one is based on, if it's\n    /// modified @internal\n    base, \n    /// The modifiers applied to this.base @internal\n    modified) {\n        this.set = set;\n        this.base = base;\n        this.modified = modified;\n        /// @internal\n        this.id = nextTagID++;\n    }\n    /// Define a new tag. If `parent` is given, the tag is treated as a\n    /// sub-tag of that parent, and [highlight\n    /// styles](#highlight.HighlightStyle) that don't mention this tag\n    /// will try to fall back to the parent tag (or grandparent tag,\n    /// etc).\n    static define(parent) {\n        if (parent === null || parent === void 0 ? void 0 : parent.base)\n            throw new Error(\"Can not derive from a modified tag\");\n        let tag = new Tag([], null, []);\n        tag.set.push(tag);\n        if (parent)\n            for (let t of parent.set)\n                tag.set.push(t);\n        return tag;\n    }\n    /// Define a tag _modifier_, which is a function that, given a tag,\n    /// will return a tag that is a subtag of the original. Applying the\n    /// same modifier to a twice tag will return the same value (`m1(t1)\n    /// == m1(t1)`) and applying multiple modifiers will, regardless or\n    /// order, produce the same tag (`m1(m2(t1)) == m2(m1(t1))`).\n    ///\n    /// When multiple modifiers are applied to a given base tag, each\n    /// smaller set of modifiers is registered as a parent, so that for\n    /// example `m1(m2(m3(t1)))` is a subtype of `m1(m2(t1))`,\n    /// `m1(m3(t1)`, and so on.\n    static defineModifier() {\n        let mod = new Modifier;\n        return (tag) => {\n            if (tag.modified.indexOf(mod) > -1)\n                return tag;\n            return Modifier.get(tag.base || tag, tag.modified.concat(mod).sort((a, b) => a.id - b.id));\n        };\n    }\n}\nlet nextModifierID = 0;\nclass Modifier {\n    constructor() {\n        this.instances = [];\n        this.id = nextModifierID++;\n    }\n    static get(base, mods) {\n        if (!mods.length)\n            return base;\n        let exists = mods[0].instances.find(t => t.base == base && sameArray(mods, t.modified));\n        if (exists)\n            return exists;\n        let set = [], tag = new Tag(set, base, mods);\n        for (let m of mods)\n            m.instances.push(tag);\n        let configs = permute(mods);\n        for (let parent of base.set)\n            for (let config of configs)\n                set.push(Modifier.get(parent, config));\n        return tag;\n    }\n}\nfunction sameArray(a, b) {\n    return a.length == b.length && a.every((x, i) => x == b[i]);\n}\nfunction permute(array) {\n    let result = [array];\n    for (let i = 0; i < array.length; i++) {\n        for (let a of permute(array.slice(0, i).concat(array.slice(i + 1))))\n            result.push(a);\n    }\n    return result;\n}\n/// This function is used to add a set of tags to a language syntax\n/// via\n/// [`Parser.configure`](https://lezer.codemirror.net/docs/ref#lezer.Parser.configure).\n///\n/// The argument object maps node selectors to [highlighting\n/// tags](#highlight.Tag) or arrays of tags.\n///\n/// Node selectors may hold one or more (space-separated) node paths.\n/// Such a path can be a [node\n/// name](https://lezer.codemirror.net/docs/ref#tree.NodeType.name),\n/// or multiple node names (or `*` wildcards) separated by slash\n/// characters, as in `\"Block/Declaration/VariableName\"`. Such a path\n/// matches the final node but only if its direct parent nodes are the\n/// other nodes mentioned. A `*` in such a path matches any parent,\n/// but only a single levelâ€”wildcards that match multiple parents\n/// aren't supported, both for efficiency reasons and because Lezer\n/// trees make it rather hard to reason about what they would match.)\n///\n/// A path can be ended with `/...` to indicate that the tag assigned\n/// to the node should also apply to all child nodes, even if they\n/// match their own style (by default, only the innermost style is\n/// used).\n///\n/// When a path ends in `!`, as in `Attribute!`, no further matching\n/// happens for the node's child nodes, and the entire node gets the\n/// given style.\n///\n/// In this notation, node names that contain `/`, `!`, `*`, or `...`\n/// must be quoted as JSON strings.\n///\n/// For example:\n///\n/// ```javascript\n/// parser.withProps(\n///   styleTags({\n///     // Style Number and BigNumber nodes\n///     \"Number BigNumber\": tags.number,\n///     // Style Escape nodes whose parent is String\n///     \"String/Escape\": tags.escape,\n///     // Style anything inside Attributes nodes\n///     \"Attributes!\": tags.meta,\n///     // Add a style to all content inside Italic nodes\n///     \"Italic/...\": tags.emphasis,\n///     // Style InvalidString nodes as both `string` and `invalid`\n///     \"InvalidString\": [tags.string, tags.invalid],\n///     // Style the node named \"/\" as punctuation\n///     '\"/\"': tags.punctuation\n///   })\n/// )\n/// ```\nfunction styleTags(spec) {\n    let byName = Object.create(null);\n    for (let prop in spec) {\n        let tags = spec[prop];\n        if (!Array.isArray(tags))\n            tags = [tags];\n        for (let part of prop.split(\" \"))\n            if (part) {\n                let pieces = [], mode = 2 /* Normal */, rest = part;\n                for (let pos = 0;;) {\n                    if (rest == \"...\" && pos > 0 && pos + 3 == part.length) {\n                        mode = 1 /* Inherit */;\n                        break;\n                    }\n                    let m = /^\"(?:[^\"\\\\]|\\\\.)*?\"|[^\\/!]+/.exec(rest);\n                    if (!m)\n                        throw new RangeError(\"Invalid path: \" + part);\n                    pieces.push(m[0] == \"*\" ? null : m[0][0] == '\"' ? JSON.parse(m[0]) : m[0]);\n                    pos += m[0].length;\n                    if (pos == part.length)\n                        break;\n                    let next = part[pos++];\n                    if (pos == part.length && next == \"!\") {\n                        mode = 0 /* Opaque */;\n                        break;\n                    }\n                    if (next != \"/\")\n                        throw new RangeError(\"Invalid path: \" + part);\n                    rest = part.slice(pos);\n                }\n                let last = pieces.length - 1, inner = pieces[last];\n                if (!inner)\n                    throw new RangeError(\"Invalid path: \" + part);\n                let rule = new Rule(tags, mode, last > 0 ? pieces.slice(0, last) : null);\n                byName[inner] = rule.sort(byName[inner]);\n            }\n    }\n    return ruleNodeProp.add(byName);\n}\nconst ruleNodeProp = new NodeProp();\nconst highlightStyle = Facet.define({\n    combine(stylings) { return stylings.length ? HighlightStyle.combinedMatch(stylings) : null; }\n});\nconst fallbackHighlightStyle = Facet.define({\n    combine(values) { return values.length ? values[0].match : null; }\n});\nfunction noHighlight() { return null; }\nfunction getHighlightStyle(state) {\n    return state.facet(highlightStyle) || state.facet(fallbackHighlightStyle) || noHighlight;\n}\nclass Rule {\n    constructor(tags, mode, context, next) {\n        this.tags = tags;\n        this.mode = mode;\n        this.context = context;\n        this.next = next;\n    }\n    sort(other) {\n        if (!other || other.depth < this.depth) {\n            this.next = other;\n            return this;\n        }\n        other.next = this.sort(other.next);\n        return other;\n    }\n    get depth() { return this.context ? this.context.length : 0; }\n}\n/// A highlight style associates CSS styles with higlighting\n/// [tags](#highlight.Tag).\nclass HighlightStyle {\n    constructor(spec, options) {\n        this.map = Object.create(null);\n        let modSpec;\n        function def(spec) {\n            let cls = StyleModule.newName();\n            (modSpec || (modSpec = Object.create(null)))[\".\" + cls] = spec;\n            return cls;\n        }\n        this.all = typeof options.all == \"string\" ? options.all : options.all ? def(options.all) : null;\n        for (let style of spec) {\n            let cls = (style.class || def(Object.assign({}, style, { tag: null }))) +\n                (this.all ? \" \" + this.all : \"\");\n            let tags = style.tag;\n            if (!Array.isArray(tags))\n                this.map[tags.id] = cls;\n            else\n                for (let tag of tags)\n                    this.map[tag.id] = cls;\n        }\n        this.module = modSpec ? new StyleModule(modSpec) : null;\n        this.scope = options.scope || null;\n        this.match = this.match.bind(this);\n        let ext = [treeHighlighter];\n        if (this.module)\n            ext.push(EditorView.styleModule.of(this.module));\n        this.extension = ext.concat(highlightStyle.of(this));\n        this.fallback = ext.concat(fallbackHighlightStyle.of(this));\n    }\n    /// Returns the CSS class associated with the given tag, if any.\n    /// This method is bound to the instance by the constructor.\n    match(tag, scope) {\n        if (this.scope && scope != this.scope)\n            return null;\n        for (let t of tag.set) {\n            let match = this.map[t.id];\n            if (match !== undefined) {\n                if (t != tag)\n                    this.map[tag.id] = match;\n                return match;\n            }\n        }\n        return this.map[tag.id] = this.all;\n    }\n    /// Combines an array of highlight styles into a single match\n    /// function that returns all of the classes assigned by the styles\n    /// for a given tag.\n    static combinedMatch(styles) {\n        if (styles.length == 1)\n            return styles[0].match;\n        let cache = styles.some(s => s.scope) ? undefined : Object.create(null);\n        return (tag, scope) => {\n            let cached = cache && cache[tag.id];\n            if (cached !== undefined)\n                return cached;\n            let result = null;\n            for (let style of styles) {\n                let value = style.match(tag, scope);\n                if (value)\n                    result = result ? result + \" \" + value : value;\n            }\n            if (cache)\n                cache[tag.id] = result;\n            return result;\n        };\n    }\n    /// Create a highlighter style that associates the given styles to\n    /// the given tags. The spec must be objects that hold a style tag\n    /// or array of tags in their `tag` property, and either a single\n    /// `class` property providing a static CSS class (for highlighters\n    /// like [`classHighlightStyle`](#highlight.classHighlightStyle)\n    /// that rely on external styling), or a\n    /// [`style-mod`](https://github.com/marijnh/style-mod#documentation)-style\n    /// set of CSS properties (which define the styling for those tags).\n    ///\n    /// The CSS rules created for a highlighter will be emitted in the\n    /// order of the spec's properties. That means that for elements that\n    /// have multiple tags associated with them, styles defined further\n    /// down in the list will have a higher CSS precedence than styles\n    /// defined earlier.\n    static define(specs, options) {\n        return new HighlightStyle(specs, options || {});\n    }\n    /// Returns the CSS classes (if any) that the highlight styles\n    /// active in the given state would assign to the given a style\n    /// [tag](#highlight.Tag) and (optional) language\n    /// [scope](#highlight.HighlightStyle^define^options.scope).\n    static get(state, tag, scope) {\n        return getHighlightStyle(state)(tag, scope || NodeType.none);\n    }\n}\n/// Given a string of code and a language, parse the code in that\n/// language and run the tree highlighter over the resulting syntax\n/// tree.\nfunction highlightTree(tree, \n/// Get the CSS classes used to style a given [tag](#highlight.Tag),\n/// or `null` if it isn't styled. (You'll often want to pass a\n/// highlight style's [`match`](#highlight.HighlightStyle.match)\n/// method here.)\ngetStyle, \n/// Assign styling to a region of the text. Will be called, in order\n/// of position, for any ranges where more than zero classes apply.\n/// `classes` is a space separated string of CSS classes.\nputStyle) {\n    highlightTreeRange(tree, 0, tree.length, getStyle, putStyle);\n}\nclass TreeHighlighter {\n    constructor(view) {\n        this.markCache = Object.create(null);\n        this.tree = syntaxTree(view.state);\n        this.decorations = this.buildDeco(view, getHighlightStyle(view.state));\n    }\n    update(update) {\n        let tree = syntaxTree(update.state), style = getHighlightStyle(update.state);\n        let styleChange = style != update.startState.facet(highlightStyle);\n        if (tree.length < update.view.viewport.to && !styleChange) {\n            this.decorations = this.decorations.map(update.changes);\n        }\n        else if (tree != this.tree || update.viewportChanged || styleChange) {\n            this.tree = tree;\n            this.decorations = this.buildDeco(update.view, style);\n        }\n    }\n    buildDeco(view, match) {\n        if (match == noHighlight || !this.tree.length)\n            return Decoration.none;\n        let builder = new RangeSetBuilder();\n        for (let { from, to } of view.visibleRanges) {\n            highlightTreeRange(this.tree, from, to, match, (from, to, style) => {\n                builder.add(from, to, this.markCache[style] || (this.markCache[style] = Decoration.mark({ class: style })));\n            });\n        }\n        return builder.finish();\n    }\n}\n// This extension installs a highlighter that highlights based on the\n// syntax tree and highlight style.\nconst treeHighlighter = Prec.fallback(ViewPlugin.fromClass(TreeHighlighter, {\n    decorations: v => v.decorations\n}));\nconst nodeStack = [\"\"];\nfunction highlightTreeRange(tree, from, to, style, span) {\n    let spanStart = from, spanClass = \"\";\n    let cursor = tree.topNode.cursor;\n    function node(inheritedClass, depth, scope) {\n        let { type, from: start, to: end } = cursor;\n        if (start >= to || end <= from)\n            return;\n        nodeStack[depth] = type.name;\n        if (type.isTop)\n            scope = type;\n        let cls = inheritedClass;\n        let rule = type.prop(ruleNodeProp), opaque = false;\n        while (rule) {\n            if (!rule.context || matchContext(rule.context, nodeStack, depth)) {\n                for (let tag of rule.tags) {\n                    let st = style(tag, scope);\n                    if (st) {\n                        if (cls)\n                            cls += \" \";\n                        cls += st;\n                        if (rule.mode == 1 /* Inherit */)\n                            inheritedClass += (inheritedClass ? \" \" : \"\") + st;\n                        else if (rule.mode == 0 /* Opaque */)\n                            opaque = true;\n                    }\n                }\n                break;\n            }\n            rule = rule.next;\n        }\n        if (cls != spanClass) {\n            if (start > spanStart && spanClass)\n                span(spanStart, cursor.from, spanClass);\n            spanStart = start;\n            spanClass = cls;\n        }\n        if (!opaque && cursor.firstChild()) {\n            do {\n                let end = cursor.to;\n                node(inheritedClass, depth + 1, scope);\n                if (spanClass != cls) {\n                    let pos = Math.min(to, end);\n                    if (pos > spanStart && spanClass)\n                        span(spanStart, pos, spanClass);\n                    spanStart = pos;\n                    spanClass = cls;\n                }\n            } while (cursor.nextSibling());\n            cursor.parent();\n        }\n    }\n    node(\"\", 0, tree.type);\n}\nfunction matchContext(context, stack, depth) {\n    if (context.length > depth - 1)\n        return false;\n    for (let d = depth - 1, i = context.length - 1; i >= 0; i--, d--) {\n        let check = context[i];\n        if (check && check != stack[d])\n            return false;\n    }\n    return true;\n}\nconst t = Tag.define;\nconst comment = t(), name = t(), typeName = t(name), literal = t(), string = t(literal), number = t(literal), content = t(), heading = t(content), keyword = t(), operator = t(), punctuation = t(), bracket = t(punctuation), meta = t();\n/// The default set of highlighting [tags](#highlight.Tag^define) used\n/// by regular language packages and themes.\n///\n/// This collection is heavily biased towards programming languages,\n/// and necessarily incomplete. A full ontology of syntactic\n/// constructs would fill a stack of books, and be impractical to\n/// write themes for. So try to make do with this set. If all else\n/// fails, [open an\n/// issue](https://github.com/codemirror/codemirror.next) to propose a\n/// new tag, or [define](#highlight.Tag^define) a local custom tag for\n/// your use case.\n///\n/// Note that it is not obligatory to always attach the most specific\n/// tag possible to an elementâ€”if your grammar can't easily\n/// distinguish a certain type of element (such as a local variable),\n/// it is okay to style it as its more general variant (a variable).\n/// \n/// For tags that extend some parent tag, the documentation links to\n/// the parent.\nconst tags = {\n    /// A comment.\n    comment,\n    /// A line [comment](#highlight.tags.comment).\n    lineComment: t(comment),\n    /// A block [comment](#highlight.tags.comment).\n    blockComment: t(comment),\n    /// A documentation [comment](#highlight.tags.comment).\n    docComment: t(comment),\n    /// Any kind of identifier.\n    name,\n    /// The [name](#highlight.tags.name) of a variable.\n    variableName: t(name),\n    /// A type [name](#highlight.tags.name).\n    typeName: typeName,\n    /// A tag name (subtag of [`typeName`](#highlight.tags.typeName)).\n    tagName: t(typeName),\n    /// A property, field, or attribute [name](#highlight.tags.name).\n    propertyName: t(name),\n    /// The [name](#highlight.tags.name) of a class.\n    className: t(name),\n    /// A label [name](#highlight.tags.name).\n    labelName: t(name),\n    /// A namespace [name](#highlight.tags.name).\n    namespace: t(name),\n    /// The [name](#highlight.tags.name) of a macro.\n    macroName: t(name),\n    /// A literal value.\n    literal,\n    /// A string [literal](#highlight.tags.literal).\n    string,\n    /// A documentation [string](#highlight.tags.string).\n    docString: t(string),\n    /// A character literal (subtag of [string](#highlight.tags.string)).\n    character: t(string),\n    /// A number [literal](#highlight.tags.literal).\n    number,\n    /// An integer [number](#highlight.tags.number) literal.\n    integer: t(number),\n    /// A floating-point [number](#highlight.tags.number) literal.\n    float: t(number),\n    /// A boolean [literal](#highlight.tags.literal).\n    bool: t(literal),\n    /// Regular expression [literal](#highlight.tags.literal).\n    regexp: t(literal),\n    /// An escape [literal](#highlight.tags.literal), for example a\n    /// backslash escape in a string.\n    escape: t(literal),\n    /// A color [literal](#highlight.tags.literal).\n    color: t(literal),\n    /// A URL [literal](#highlight.tags.literal).\n    url: t(literal),\n    /// A language keyword.\n    keyword,\n    /// The [keyword](#highlight.tags.keyword) for the self or this\n    /// object.\n    self: t(keyword),\n    /// The [keyword](#highlight.tags.keyword) for null.\n    null: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) denoting some atomic value.\n    atom: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) that represents a unit.\n    unit: t(keyword),\n    /// A modifier [keyword](#highlight.tags.keyword).\n    modifier: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) that acts as an operator.\n    operatorKeyword: t(keyword),\n    /// A control-flow related [keyword](#highlight.tags.keyword).\n    controlKeyword: t(keyword),\n    /// A [keyword](#highlight.tags.keyword) that defines something.\n    definitionKeyword: t(keyword),\n    /// An operator.\n    operator,\n    /// An [operator](#highlight.tags.operator) that defines something.\n    derefOperator: t(operator),\n    /// Arithmetic-related [operator](#highlight.tags.operator).\n    arithmeticOperator: t(operator),\n    /// Logical [operator](#highlight.tags.operator).\n    logicOperator: t(operator),\n    /// Bit [operator](#highlight.tags.operator).\n    bitwiseOperator: t(operator),\n    /// Comparison [operator](#highlight.tags.operator).\n    compareOperator: t(operator),\n    /// [Operator](#highlight.tags.operator) that updates its operand.\n    updateOperator: t(operator),\n    /// [Operator](#highlight.tags.operator) that defines something.\n    definitionOperator: t(operator),\n    /// Type-related [operator](#highlight.tags.operator).\n    typeOperator: t(operator),\n    /// Control-flow [operator](#highlight.tags.operator).\n    controlOperator: t(operator),\n    /// Program or markup punctuation.\n    punctuation,\n    /// [Punctuation](#highlight.tags.punctuation) that separates\n    /// things.\n    separator: t(punctuation),\n    /// Bracket-style [punctuation](#highlight.tags.punctuation).\n    bracket,\n    /// Angle [brackets](#highlight.tags.bracket) (usually `<` and `>`\n    /// tokens).\n    angleBracket: t(bracket),\n    /// Square [brackets](#highlight.tags.bracket) (usually `[` and `]`\n    /// tokens).\n    squareBracket: t(bracket),\n    /// Parentheses (usually `(` and `)` tokens). Subtag of\n    /// [bracket](#highlight.tags.bracket).\n    paren: t(bracket),\n    /// Braces (usually `{` and `}` tokens). Subtag of\n    /// [bracket](#highlight.tags.bracket).\n    brace: t(bracket),\n    /// Content, for example plain text in XML or markup documents.\n    content,\n    /// [Content](#highlight.tags.content) that represents a heading.\n    heading,\n    /// A level 1 [heading](#highlight.tags.heading).\n    heading1: t(heading),\n    /// A level 2 [heading](#highlight.tags.heading).\n    heading2: t(heading),\n    /// A level 3 [heading](#highlight.tags.heading).\n    heading3: t(heading),\n    /// A level 4 [heading](#highlight.tags.heading).\n    heading4: t(heading),\n    /// A level 5 [heading](#highlight.tags.heading).\n    heading5: t(heading),\n    /// A level 6 [heading](#highlight.tags.heading).\n    heading6: t(heading),\n    /// A prose separator (such as a horizontal rule).\n    contentSeparator: t(content),\n    /// [Content](#highlight.tags.content) that represents a list.\n    list: t(content),\n    /// [Content](#highlight.tags.content) that represents a quote.\n    quote: t(content),\n    /// [Content](#highlight.tags.content) that is emphasized.\n    emphasis: t(content),\n    /// [Content](#highlight.tags.content) that is styled strong.\n    strong: t(content),\n    /// [Content](#highlight.tags.content) that is part of a link.\n    link: t(content),\n    /// [Content](#highlight.tags.content) that is styled as code or\n    /// monospace.\n    monospace: t(content),\n    /// Inserted text in a change-tracking format.\n    inserted: t(),\n    /// Deleted text.\n    deleted: t(),\n    /// Changed text.\n    changed: t(),\n    /// An invalid or unsyntactic element.\n    invalid: t(),\n    /// Metadata or meta-instruction.\n    meta,\n    /// [Metadata](#highlight.tags.meta) that applies to the entire\n    /// document.\n    documentMeta: t(meta),\n    /// [Metadata](#highlight.tags.meta) that annotates or adds\n    /// attributes to a given syntactic element.\n    annotation: t(meta),\n    /// Processing instruction or preprocessor directive. Subtag of\n    /// [meta](#highlight.tags.meta).\n    processingInstruction: t(meta),\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates that a\n    /// given element is being defined. Expected to be used with the\n    /// various [name](#highlight.tags.name) tags.\n    definition: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates that\n    /// something is constant. Mostly expected to be used with\n    /// [variable names](#highlight.tags.variableName).\n    constant: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) used to indicate that\n    /// a [variable](#highlight.tags.variableName) or [property\n    /// name](#highlight.tags.propertyName) is being called or defined\n    /// as a function.\n    function: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) that can be applied to\n    /// [names](#highlight.tags.name) to indicate that they belong to\n    /// the language's standard environment.\n    standard: Tag.defineModifier(),\n    /// [Modifier](#highlight.Tag^defineModifier) that indicates a given\n    /// [names](#highlight.tags.name) is local to some scope.\n    local: Tag.defineModifier(),\n    /// A generic variant [modifier](#highlight.Tag^defineModifier) that\n    /// can be used to tag language-specific alternative variants of\n    /// some common tag. It is recommended for themes to define special\n    /// forms of at least the [string](#highlight.tags.string) and\n    /// [variable name](#highlight.tags.variableName) tags, since those\n    /// come up a lot.\n    special: Tag.defineModifier()\n};\n/// A default highlight style (works well with light themes).\nconst defaultHighlightStyle = HighlightStyle.define([\n    { tag: tags.link,\n        textDecoration: \"underline\" },\n    { tag: tags.heading,\n        textDecoration: \"underline\",\n        fontWeight: \"bold\" },\n    { tag: tags.emphasis,\n        fontStyle: \"italic\" },\n    { tag: tags.strong,\n        fontWeight: \"bold\" },\n    { tag: tags.keyword,\n        color: \"#708\" },\n    { tag: [tags.atom, tags.bool, tags.url, tags.contentSeparator, tags.labelName],\n        color: \"#219\" },\n    { tag: [tags.literal, tags.inserted],\n        color: \"#164\" },\n    { tag: [tags.string, tags.deleted],\n        color: \"#a11\" },\n    { tag: [tags.regexp, tags.escape, tags.special(tags.string)],\n        color: \"#e40\" },\n    { tag: tags.definition(tags.variableName),\n        color: \"#00f\" },\n    { tag: tags.local(tags.variableName),\n        color: \"#30a\" },\n    { tag: [tags.typeName, tags.namespace],\n        color: \"#085\" },\n    { tag: tags.className,\n        color: \"#167\" },\n    { tag: [tags.special(tags.variableName), tags.macroName],\n        color: \"#256\" },\n    { tag: tags.definition(tags.propertyName),\n        color: \"#00c\" },\n    { tag: tags.comment,\n        color: \"#940\" },\n    { tag: tags.meta,\n        color: \"#7a757a\" },\n    { tag: tags.invalid,\n        color: \"#f00\" }\n]);\n/// This is a highlight style that adds stable, predictable classes to\n/// tokens, for styling with external CSS.\n///\n/// These tags are mapped to their name prefixed with `\"cmt-\"` (for\n/// example `\"cmt-comment\"`):\n///\n/// * [`link`](#highlight.tags.link)\n/// * [`heading`](#highlight.tags.heading)\n/// * [`emphasis`](#highlight.tags.emphasis)\n/// * [`strong`](#highlight.tags.strong)\n/// * [`keyword`](#highlight.tags.keyword)\n/// * [`atom`](#highlight.tags.atom) [`bool`](#highlight.tags.bool)\n/// * [`url`](#highlight.tags.url)\n/// * [`labelName`](#highlight.tags.labelName)\n/// * [`inserted`](#highlight.tags.inserted)\n/// * [`deleted`](#highlight.tags.deleted)\n/// * [`literal`](#highlight.tags.literal)\n/// * [`string`](#highlight.tags.string)\n/// * [`number`](#highlight.tags.number)\n/// * [`variableName`](#highlight.tags.variableName)\n/// * [`typeName`](#highlight.tags.typeName)\n/// * [`namespace`](#highlight.tags.namespace)\n/// * [`macroName`](#highlight.tags.macroName)\n/// * [`propertyName`](#highlight.tags.propertyName)\n/// * [`operator`](#highlight.tags.operator)\n/// * [`comment`](#highlight.tags.comment)\n/// * [`meta`](#highlight.tags.meta)\n/// * [`punctuation`](#highlight.tags.puncutation)\n/// * [`invalid`](#highlight.tags.invalid)\n///\n/// In addition, these mappings are provided:\n///\n/// * [`regexp`](#highlight.tags.regexp),\n///   [`escape`](#highlight.tags.escape), and\n///   [`special`](#highlight.tags.special)[`(string)`](#highlight.tags.string)\n///   are mapped to `\"cmt-string2\"`\n/// * [`special`](#highlight.tags.special)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"cmt-variableName2\"`\n/// * [`local`](#highlight.tags.local)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"cmt-variableName cmt-local\"`\n/// * [`definition`](#highlight.tags.definition)[`(variableName)`](#highlight.tags.variableName)\n///   to `\"cmt-variableName cmt-definition\"`\nconst classHighlightStyle = HighlightStyle.define([\n    { tag: tags.link, class: \"cmt-link\" },\n    { tag: tags.heading, class: \"cmt-heading\" },\n    { tag: tags.emphasis, class: \"cmt-emphasis\" },\n    { tag: tags.strong, class: \"cmt-strong\" },\n    { tag: tags.keyword, class: \"cmt-keyword\" },\n    { tag: tags.atom, class: \"cmt-atom\" },\n    { tag: tags.bool, class: \"cmt-bool\" },\n    { tag: tags.url, class: \"cmt-url\" },\n    { tag: tags.labelName, class: \"cmt-labelName\" },\n    { tag: tags.inserted, class: \"cmt-inserted\" },\n    { tag: tags.deleted, class: \"cmt-deleted\" },\n    { tag: tags.literal, class: \"cmt-literal\" },\n    { tag: tags.string, class: \"cmt-string\" },\n    { tag: tags.number, class: \"cmt-number\" },\n    { tag: [tags.regexp, tags.escape, tags.special(tags.string)], class: \"cmt-string2\" },\n    { tag: tags.variableName, class: \"cmt-variableName\" },\n    { tag: tags.local(tags.variableName), class: \"cmt-variableName cmt-local\" },\n    { tag: tags.definition(tags.variableName), class: \"cmt-variableName cmt-definition\" },\n    { tag: tags.special(tags.variableName), class: \"cmt-variableName2\" },\n    { tag: tags.typeName, class: \"cmt-typeName\" },\n    { tag: tags.namespace, class: \"cmt-namespace\" },\n    { tag: tags.macroName, class: \"cmt-macroName\" },\n    { tag: tags.propertyName, class: \"cmt-propertyName\" },\n    { tag: tags.operator, class: \"cmt-operator\" },\n    { tag: tags.comment, class: \"cmt-comment\" },\n    { tag: tags.meta, class: \"cmt-meta\" },\n    { tag: tags.invalid, class: \"cmt-invalid\" },\n    { tag: tags.punctuation, class: \"cmt-punctuation\" }\n]);\n\nexport { HighlightStyle, Tag, classHighlightStyle, defaultHighlightStyle, highlightTree, styleTags, tags };\n"]},"metadata":{},"sourceType":"module"}