{"ast":null,"code":"import { EditorView, Decoration, ViewPlugin, runScopeHandlers } from '@codemirror/view';\nimport { StateEffect, StateField, EditorSelection, Facet, combineConfig, CharCategory, Prec } from '@codemirror/state';\nimport { showPanel, getPanel } from '@codemirror/panel';\nimport { RangeSetBuilder } from '@codemirror/rangeset';\nimport elt from 'crelt';\nimport { codePointAt, fromCodePoint, codePointSize, findClusterBreak } from '@codemirror/text';\nconst basicNormalize = typeof String.prototype.normalize == \"function\" ? x => x.normalize(\"NFKD\") : x => x;\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/\n\nclass SearchCursor {\n  /**\n  Create a text cursor. The query is the search string, `from` to\n  `to` provides the region to search.\n  \n  When `normalize` is given, it will be called, on both the query\n  string and the content it is matched against, before comparing.\n  You can, for example, create a case-insensitive search by\n  passing `s => s.toLowerCase()`.\n  \n  Text is always normalized with\n  [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n  (when supported).\n  */\n  constructor(text, query, from = 0, to = text.length, normalize) {\n    /**\n    The current match (only holds a meaningful value after\n    [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n    `done` is false).\n    */\n    this.value = {\n      from: 0,\n      to: 0\n    };\n    /**\n    Whether the end of the iterated region has been reached.\n    */\n\n    this.done = false;\n    this.matches = [];\n    this.buffer = \"\";\n    this.bufferPos = 0;\n    this.iter = text.iterRange(from, to);\n    this.bufferStart = from;\n    this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;\n    this.query = this.normalize(query);\n  }\n\n  peek() {\n    if (this.bufferPos == this.buffer.length) {\n      this.bufferStart += this.buffer.length;\n      this.iter.next();\n      if (this.iter.done) return -1;\n      this.bufferPos = 0;\n      this.buffer = this.iter.value;\n    }\n\n    return codePointAt(this.buffer, this.bufferPos);\n  }\n  /**\n  Look for the next match. Updates the iterator's\n  [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n  [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n  at least once before using the cursor.\n  */\n\n\n  next() {\n    while (this.matches.length) this.matches.pop();\n\n    return this.nextOverlapping();\n  }\n  /**\n  The `next` method will ignore matches that partially overlap a\n  previous match. This method behaves like `next`, but includes\n  such matches.\n  */\n\n\n  nextOverlapping() {\n    for (;;) {\n      let next = this.peek();\n\n      if (next < 0) {\n        this.done = true;\n        return this;\n      }\n\n      let str = fromCodePoint(next),\n          start = this.bufferStart + this.bufferPos;\n      this.bufferPos += codePointSize(next);\n      let norm = this.normalize(str);\n\n      for (let i = 0, pos = start;; i++) {\n        let code = norm.charCodeAt(i);\n        let match = this.match(code, pos);\n\n        if (match) {\n          this.value = match;\n          return this;\n        }\n\n        if (i == norm.length - 1) break;\n        if (pos == start && i < str.length && str.charCodeAt(i) == code) pos++;\n      }\n    }\n  }\n\n  match(code, pos) {\n    let match = null;\n\n    for (let i = 0; i < this.matches.length; i += 2) {\n      let index = this.matches[i],\n          keep = false;\n\n      if (this.query.charCodeAt(index) == code) {\n        if (index == this.query.length - 1) {\n          match = {\n            from: this.matches[i + 1],\n            to: pos + 1\n          };\n        } else {\n          this.matches[i]++;\n          keep = true;\n        }\n      }\n\n      if (!keep) {\n        this.matches.splice(i, 2);\n        i -= 2;\n      }\n    }\n\n    if (this.query.charCodeAt(0) == code) {\n      if (this.query.length == 1) match = {\n        from: pos,\n        to: pos + 1\n      };else this.matches.push(1, pos);\n    }\n\n    return match;\n  }\n\n}\n\nconst empty = {\n  from: -1,\n  to: -1,\n  match: /.*/.exec(\"\")\n};\nconst baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\n\nclass RegExpCursor {\n  constructor(text, query, options, from = 0, to = text.length) {\n    this.to = to;\n    this.curLine = \"\";\n    this.done = false;\n    this.value = empty;\n    if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query)) return new MultilineRegExpCursor(text, query, options, from, to);\n    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n    this.iter = text.iter();\n    let startLine = text.lineAt(from);\n    this.curLineStart = startLine.from;\n    this.matchPos = from;\n    this.getLine(this.curLineStart);\n  }\n\n  getLine(skip) {\n    this.iter.next(skip);\n\n    if (this.iter.lineBreak) {\n      this.curLine = \"\";\n    } else {\n      this.curLine = this.iter.value;\n      if (this.curLineStart + this.curLine.length > this.to) this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n      this.iter.next();\n    }\n  }\n\n  nextLine() {\n    this.curLineStart = this.curLineStart + this.curLine.length + 1;\n    if (this.curLineStart > this.to) this.curLine = \"\";else this.getLine(0);\n  }\n\n  next() {\n    for (let off = this.matchPos - this.curLineStart;;) {\n      this.re.lastIndex = off;\n      let match = this.matchPos <= this.to && this.re.exec(this.curLine);\n\n      if (match) {\n        let from = this.curLineStart + match.index,\n            to = from + match[0].length;\n        this.matchPos = to + (from == to ? 1 : 0);\n        if (from == this.curLine.length) this.nextLine();\n\n        if (from < to || from > this.value.to) {\n          this.value = {\n            from,\n            to,\n            match\n          };\n          return this;\n        }\n\n        off = this.matchPos - this.curLineStart;\n      } else if (this.curLineStart + this.curLine.length < this.to) {\n        this.nextLine();\n        off = 0;\n      } else {\n        this.done = true;\n        return this;\n      }\n    }\n  }\n\n}\n\nconst flattened = new WeakMap(); // Reusable (partially) flattened document strings\n\nclass FlattenedDoc {\n  constructor(from, text) {\n    this.from = from;\n    this.text = text;\n  }\n\n  get to() {\n    return this.from + this.text.length;\n  }\n\n  static get(doc, from, to) {\n    let cached = flattened.get(doc);\n\n    if (!cached || cached.from >= to || cached.to <= from) {\n      let flat = new FlattenedDoc(from, doc.sliceString(from, to));\n      flattened.set(doc, flat);\n      return flat;\n    }\n\n    if (cached.from == from && cached.to == to) return cached;\n    let {\n      text,\n      from: cachedFrom\n    } = cached;\n\n    if (cachedFrom > from) {\n      text = doc.sliceString(from, cachedFrom) + text;\n      cachedFrom = from;\n    }\n\n    if (cached.to < to) text += doc.sliceString(cached.to, to);\n    flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n    return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n  }\n\n}\n\nclass MultilineRegExpCursor {\n  constructor(text, query, options, from, to) {\n    this.text = text;\n    this.to = to;\n    this.done = false;\n    this.value = empty;\n    this.matchPos = from;\n    this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n    this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000\n    /* Base */\n    ));\n  }\n\n  chunkEnd(pos) {\n    return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n  }\n\n  next() {\n    for (;;) {\n      let off = this.re.lastIndex = this.matchPos - this.flat.from;\n      let match = this.re.exec(this.flat.text); // Skip empty matches directly after the last match\n\n      if (match && !match[0] && match.index == off) {\n        this.re.lastIndex = off + 1;\n        match = this.re.exec(this.flat.text);\n      } // If a match goes almost to the end of a noncomplete chunk, try\n      // again, since it'll likely be able to match more\n\n\n      if (match && this.flat.to < this.to && match.index + match[0].length > this.flat.text.length - 10) match = null;\n\n      if (match) {\n        let from = this.flat.from + match.index,\n            to = from + match[0].length;\n        this.value = {\n          from,\n          to,\n          match\n        };\n        this.matchPos = to + (from == to ? 1 : 0);\n        return this;\n      } else {\n        if (this.flat.to == this.to) {\n          this.done = true;\n          return this;\n        } // Grow the flattened doc\n\n\n        this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n      }\n    }\n  }\n\n}\n\nfunction validRegExp(source) {\n  try {\n    new RegExp(source, baseFlags);\n    return true;\n  } catch (_a) {\n    return false;\n  }\n}\n\nfunction createLineDialog(view) {\n  let input = elt(\"input\", {\n    class: \"cm-textfield\",\n    name: \"line\"\n  });\n  let dom = elt(\"form\", {\n    class: \"cm-gotoLine\",\n    onkeydown: event => {\n      if (event.keyCode == 27) {\n        // Escape\n        event.preventDefault();\n        view.dispatch({\n          effects: dialogEffect.of(false)\n        });\n        view.focus();\n      } else if (event.keyCode == 13) {\n        // Enter\n        event.preventDefault();\n        go();\n      }\n    },\n    onsubmit: event => {\n      event.preventDefault();\n      go();\n    }\n  }, elt(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", elt(\"button\", {\n    class: \"cm-button\",\n    type: \"submit\"\n  }, view.state.phrase(\"go\")));\n\n  function go() {\n    let match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n    if (!match) return;\n    let {\n      state\n    } = view,\n        startLine = state.doc.lineAt(state.selection.main.head);\n    let [, sign, ln, cl, percent] = match;\n    let col = cl ? +cl.slice(1) : 0;\n    let line = ln ? +ln : startLine.number;\n\n    if (ln && percent) {\n      let pc = line / 100;\n      if (sign) pc = pc * (sign == \"-\" ? -1 : 1) + startLine.number / state.doc.lines;\n      line = Math.round(state.doc.lines * pc);\n    } else if (ln && sign) {\n      line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n    }\n\n    let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n    view.dispatch({\n      effects: dialogEffect.of(false),\n      selection: EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),\n      scrollIntoView: true\n    });\n    view.focus();\n  }\n\n  return {\n    dom,\n    pos: -10\n  };\n}\n\nconst dialogEffect = StateEffect.define();\nconst dialogField = StateField.define({\n  create() {\n    return true;\n  },\n\n  update(value, tr) {\n    for (let e of tr.effects) if (e.is(dialogEffect)) value = e.value;\n\n    return value;\n  },\n\n  provide: f => showPanel.from(f, val => val ? createLineDialog : null)\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n\nThe dialog can be styled with the `panel.gotoLine` theme\nselector.\n*/\n\nconst gotoLine = view => {\n  let panel = getPanel(view, createLineDialog);\n\n  if (!panel) {\n    let effects = [dialogEffect.of(true)];\n    if (view.state.field(dialogField, false) == null) effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));\n    view.dispatch({\n      effects\n    });\n    panel = getPanel(view, createLineDialog);\n  }\n\n  if (panel) panel.dom.querySelector(\"input\").focus();\n  return true;\n};\n\nconst baseTheme$1 = EditorView.baseTheme({\n  \".cm-panel.cm-gotoLine\": {\n    padding: \"2px 6px 4px\",\n    \"& label\": {\n      fontSize: \"80%\"\n    }\n  }\n});\nconst defaultHighlightOptions = {\n  highlightWordAroundCursor: false,\n  minSelectionLength: 1,\n  maxMatches: 100\n};\nconst highlightConfig = Facet.define({\n  combine(options) {\n    return combineConfig(options, defaultHighlightOptions, {\n      highlightWordAroundCursor: (a, b) => a || b,\n      minSelectionLength: Math.min,\n      maxMatches: Math.min\n    });\n  }\n\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/\n\nfunction highlightSelectionMatches(options) {\n  let ext = [defaultTheme, matchHighlighter];\n  if (options) ext.push(highlightConfig.of(options));\n  return ext;\n}\n\nfunction wordAt(doc, pos, check) {\n  let line = doc.lineAt(pos);\n  let from = pos - line.from,\n      to = pos - line.from;\n\n  while (from > 0) {\n    let prev = findClusterBreak(line.text, from, false);\n    if (check(line.text.slice(prev, from)) != CharCategory.Word) break;\n    from = prev;\n  }\n\n  while (to < line.length) {\n    let next = findClusterBreak(line.text, to);\n    if (check(line.text.slice(to, next)) != CharCategory.Word) break;\n    to = next;\n  }\n\n  return from == to ? null : line.text.slice(from, to);\n}\n\nconst matchDeco = Decoration.mark({\n  class: \"cm-selectionMatch\"\n});\nconst mainMatchDeco = Decoration.mark({\n  class: \"cm-selectionMatch cm-selectionMatch-main\"\n});\nconst matchHighlighter = ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.decorations = this.getDeco(view);\n  }\n\n  update(update) {\n    if (update.selectionSet || update.docChanged || update.viewportChanged) this.decorations = this.getDeco(update.view);\n  }\n\n  getDeco(view) {\n    let conf = view.state.facet(highlightConfig);\n    let {\n      state\n    } = view,\n        sel = state.selection;\n    if (sel.ranges.length > 1) return Decoration.none;\n    let range = sel.main,\n        query,\n        check = null;\n\n    if (range.empty) {\n      if (!conf.highlightWordAroundCursor) return Decoration.none;\n      check = state.charCategorizer(range.head);\n      query = wordAt(state.doc, range.head, check);\n      if (!query) return Decoration.none;\n    } else {\n      let len = range.to - range.from;\n      if (len < conf.minSelectionLength || len > 200) return Decoration.none;\n      query = state.sliceDoc(range.from, range.to).trim();\n      if (!query) return Decoration.none;\n    }\n\n    let deco = [];\n\n    for (let part of view.visibleRanges) {\n      let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n\n      while (!cursor.nextOverlapping().done) {\n        let {\n          from,\n          to\n        } = cursor.value;\n\n        if (!check || (from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) && (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word)) {\n          if (check && from <= range.from && to >= range.to) deco.push(mainMatchDeco.range(from, to));else if (from >= range.to || to <= range.from) deco.push(matchDeco.range(from, to));\n          if (deco.length > conf.maxMatches) return Decoration.none;\n        }\n      }\n    }\n\n    return Decoration.set(deco);\n  }\n\n}, {\n  decorations: v => v.decorations\n});\nconst defaultTheme = EditorView.baseTheme({\n  \".cm-selectionMatch\": {\n    backgroundColor: \"#99ff7780\"\n  },\n  \".cm-searchMatch .cm-selectionMatch\": {\n    backgroundColor: \"transparent\"\n  }\n});\n\nclass Query {\n  constructor(search, replace, caseInsensitive) {\n    this.search = search;\n    this.replace = replace;\n    this.caseInsensitive = caseInsensitive;\n  }\n\n  eq(other) {\n    return this.search == other.search && this.replace == other.replace && this.caseInsensitive == other.caseInsensitive && this.constructor == other.constructor;\n  }\n\n}\n\nclass StringQuery extends Query {\n  constructor(search, replace, caseInsensitive) {\n    super(search, replace, caseInsensitive);\n    this.unquoted = search.replace(/\\\\([nrt\\\\])/g, (_, ch) => ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\\t\" : \"\\\\\");\n  }\n\n  cursor(doc, from = 0, to = doc.length) {\n    return new SearchCursor(doc, this.unquoted, from, to, this.caseInsensitive ? x => x.toLowerCase() : undefined);\n  }\n\n  nextMatch(doc, curFrom, curTo) {\n    let cursor = this.cursor(doc, curTo).nextOverlapping();\n    if (cursor.done) cursor = this.cursor(doc, 0, curFrom).nextOverlapping();\n    return cursor.done ? null : cursor.value;\n  } // Searching in reverse is, rather than implementing inverted search\n  // cursor, done by scanning chunk after chunk forward.\n\n\n  prevMatchInRange(doc, from, to) {\n    for (let pos = to;;) {\n      let start = Math.max(from, pos - 10000\n      /* ChunkSize */\n      - this.unquoted.length);\n      let cursor = this.cursor(doc, start, pos),\n          range = null;\n\n      while (!cursor.nextOverlapping().done) range = cursor.value;\n\n      if (range) return range;\n      if (start == from) return null;\n      pos -= 10000\n      /* ChunkSize */\n      ;\n    }\n  }\n\n  prevMatch(doc, curFrom, curTo) {\n    return this.prevMatchInRange(doc, 0, curFrom) || this.prevMatchInRange(doc, curTo, doc.length);\n  }\n\n  getReplacement(_result) {\n    return this.replace;\n  }\n\n  matchAll(doc, limit) {\n    let cursor = this.cursor(doc),\n        ranges = [];\n\n    while (!cursor.next().done) {\n      if (ranges.length >= limit) return null;\n      ranges.push(cursor.value);\n    }\n\n    return ranges;\n  }\n\n  highlight(doc, from, to, add) {\n    let cursor = this.cursor(doc, Math.max(0, from - this.unquoted.length), Math.min(to + this.unquoted.length, doc.length));\n\n    while (!cursor.next().done) add(cursor.value.from, cursor.value.to);\n  }\n\n  get valid() {\n    return !!this.search;\n  }\n\n}\n\nclass RegExpQuery extends Query {\n  constructor(search, replace, caseInsensitive) {\n    super(search, replace, caseInsensitive);\n    this.valid = !!search && validRegExp(search);\n  }\n\n  cursor(doc, from = 0, to = doc.length) {\n    return new RegExpCursor(doc, this.search, this.caseInsensitive ? {\n      ignoreCase: true\n    } : undefined, from, to);\n  }\n\n  nextMatch(doc, curFrom, curTo) {\n    let cursor = this.cursor(doc, curTo).next();\n    if (cursor.done) cursor = this.cursor(doc, 0, curFrom).next();\n    return cursor.done ? null : cursor.value;\n  }\n\n  prevMatchInRange(doc, from, to) {\n    for (let size = 1;; size++) {\n      let start = Math.max(from, to - size * 10000\n      /* ChunkSize */\n      );\n      let cursor = this.cursor(doc, start, to),\n          range = null;\n\n      while (!cursor.next().done) range = cursor.value;\n\n      if (range && (start == from || range.from > start + 10)) return range;\n      if (start == from) return null;\n    }\n  }\n\n  prevMatch(doc, curFrom, curTo) {\n    return this.prevMatchInRange(doc, 0, curFrom) || this.prevMatchInRange(doc, curTo, doc.length);\n  }\n\n  getReplacement(result) {\n    return this.replace.replace(/\\$([$&\\d+])/g, (m, i) => i == \"$\" ? \"$\" : i == \"&\" ? result.match[0] : i != \"0\" && +i < result.match.length ? result.match[i] : m);\n  }\n\n  matchAll(doc, limit) {\n    let cursor = this.cursor(doc),\n        ranges = [];\n\n    while (!cursor.next().done) {\n      if (ranges.length >= limit) return null;\n      ranges.push(cursor.value);\n    }\n\n    return ranges;\n  }\n\n  highlight(doc, from, to, add) {\n    let cursor = this.cursor(doc, Math.max(0, from - 250\n    /* HighlightMargin */\n    ), Math.min(to + 250\n    /* HighlightMargin */\n    , doc.length));\n\n    while (!cursor.next().done) add(cursor.value.from, cursor.value.to);\n  }\n\n}\n\nconst setQuery = StateEffect.define();\nconst togglePanel = StateEffect.define();\nconst searchState = StateField.define({\n  create() {\n    return new SearchState(new StringQuery(\"\", \"\", false), null);\n  },\n\n  update(value, tr) {\n    for (let effect of tr.effects) {\n      if (effect.is(setQuery)) value = new SearchState(effect.value, value.panel);else if (effect.is(togglePanel)) value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n    }\n\n    return value;\n  },\n\n  provide: f => showPanel.from(f, val => val.panel)\n});\n\nclass SearchState {\n  constructor(query, panel) {\n    this.query = query;\n    this.panel = panel;\n  }\n\n}\n\nconst matchMark = Decoration.mark({\n  class: \"cm-searchMatch\"\n}),\n      selectedMatchMark = Decoration.mark({\n  class: \"cm-searchMatch cm-searchMatch-selected\"\n});\nconst searchHighlighter = ViewPlugin.fromClass(class {\n  constructor(view) {\n    this.view = view;\n    this.decorations = this.highlight(view.state.field(searchState));\n  }\n\n  update(update) {\n    let state = update.state.field(searchState);\n    if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet) this.decorations = this.highlight(state);\n  }\n\n  highlight({\n    query,\n    panel\n  }) {\n    if (!panel || !query.valid) return Decoration.none;\n    let {\n      view\n    } = this;\n    let builder = new RangeSetBuilder();\n\n    for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n      let {\n        from,\n        to\n      } = ranges[i];\n\n      while (i < l - 1 && to > ranges[i + 1].from - 2 * 250\n      /* HighlightMargin */\n      ) to = ranges[++i].to;\n\n      query.highlight(view.state.doc, from, to, (from, to) => {\n        let selected = view.state.selection.ranges.some(r => r.from == from && r.to == to);\n        builder.add(from, to, selected ? selectedMatchMark : matchMark);\n      });\n    }\n\n    return builder.finish();\n  }\n\n}, {\n  decorations: v => v.decorations\n});\n\nfunction searchCommand(f) {\n  return view => {\n    let state = view.state.field(searchState, false);\n    return state && state.query.valid ? f(view, state) : openSearchPanel(view);\n  };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/\n\n\nconst findNext = searchCommand((view, {\n  query\n}) => {\n  let {\n    from,\n    to\n  } = view.state.selection.main;\n  let next = query.nextMatch(view.state.doc, from, to);\n  if (!next || next.from == from && next.to == to) return false;\n  view.dispatch({\n    selection: {\n      anchor: next.from,\n      head: next.to\n    },\n    scrollIntoView: true,\n    effects: announceMatch(view, next)\n  });\n  return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/\n\nconst findPrevious = searchCommand((view, {\n  query\n}) => {\n  let {\n    state\n  } = view,\n      {\n    from,\n    to\n  } = state.selection.main;\n  let range = query.prevMatch(state.doc, from, to);\n  if (!range) return false;\n  view.dispatch({\n    selection: {\n      anchor: range.from,\n      head: range.to\n    },\n    scrollIntoView: true,\n    effects: announceMatch(view, range)\n  });\n  return true;\n});\n/**\nSelect all instances of the search query.\n*/\n\nconst selectMatches = searchCommand((view, {\n  query\n}) => {\n  let ranges = query.matchAll(view.state.doc, 1000);\n  if (!ranges || !ranges.length) return false;\n  view.dispatch({\n    selection: EditorSelection.create(ranges.map(r => EditorSelection.range(r.from, r.to)))\n  });\n  return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/\n\nconst selectSelectionMatches = ({\n  state,\n  dispatch\n}) => {\n  let sel = state.selection;\n  if (sel.ranges.length > 1 || sel.main.empty) return false;\n  let {\n    from,\n    to\n  } = sel.main;\n  let ranges = [],\n      main = 0;\n\n  for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {\n    if (ranges.length > 1000) return false;\n    if (cur.value.from == from) main = ranges.length;\n    ranges.push(EditorSelection.range(cur.value.from, cur.value.to));\n  }\n\n  dispatch(state.update({\n    selection: EditorSelection.create(ranges, main)\n  }));\n  return true;\n};\n/**\nReplace the current match of the search query.\n*/\n\n\nconst replaceNext = searchCommand((view, {\n  query\n}) => {\n  let {\n    state\n  } = view,\n      {\n    from,\n    to\n  } = state.selection.main;\n  let next = query.nextMatch(state.doc, from, from);\n  if (!next) return false;\n  let changes = [],\n      selection,\n      replacement;\n\n  if (next.from == from && next.to == to) {\n    replacement = state.toText(query.getReplacement(next));\n    changes.push({\n      from: next.from,\n      to: next.to,\n      insert: replacement\n    });\n    next = query.nextMatch(state.doc, next.from, next.to);\n  }\n\n  if (next) {\n    let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;\n    selection = {\n      anchor: next.from - off,\n      head: next.to - off\n    };\n  }\n\n  view.dispatch({\n    changes,\n    selection,\n    scrollIntoView: !!selection,\n    effects: next ? announceMatch(view, next) : undefined\n  });\n  return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/\n\nconst replaceAll = searchCommand((view, {\n  query\n}) => {\n  let changes = query.matchAll(view.state.doc, 1e9).map(match => {\n    let {\n      from,\n      to\n    } = match;\n    return {\n      from,\n      to,\n      insert: query.getReplacement(match)\n    };\n  });\n  if (!changes.length) return false;\n  view.dispatch({\n    changes\n  });\n  return true;\n});\n\nfunction createSearchPanel(view) {\n  let {\n    query\n  } = view.state.field(searchState);\n  return {\n    dom: buildPanel({\n      view,\n      query,\n\n      updateQuery(q) {\n        if (!query.eq(q)) {\n          query = q;\n          view.dispatch({\n            effects: setQuery.of(query)\n          });\n        }\n      }\n\n    }),\n\n    mount() {\n      this.dom.querySelector(\"[name=search]\").select();\n    },\n\n    pos: 80\n  };\n}\n/**\nMake sure the search panel is open and focused.\n*/\n\n\nconst openSearchPanel = view => {\n  let state = view.state.field(searchState, false);\n\n  if (state && state.panel) {\n    let panel = getPanel(view, createSearchPanel);\n    if (!panel) return false;\n    panel.dom.querySelector(\"[name=search]\").focus();\n  } else {\n    view.dispatch({\n      effects: [togglePanel.of(true), ...(state ? [] : [StateEffect.appendConfig.of(searchExtensions)])]\n    });\n  }\n\n  return true;\n};\n/**\nClose the search panel.\n*/\n\n\nconst closeSearchPanel = view => {\n  let state = view.state.field(searchState, false);\n  if (!state || !state.panel) return false;\n  let panel = getPanel(view, createSearchPanel);\n  if (panel && panel.dom.contains(view.root.activeElement)) view.focus();\n  view.dispatch({\n    effects: togglePanel.of(false)\n  });\n  return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n*/\n\n\nconst searchKeymap = [{\n  key: \"Mod-f\",\n  run: openSearchPanel,\n  scope: \"editor search-panel\"\n}, {\n  key: \"F3\",\n  run: findNext,\n  shift: findPrevious,\n  scope: \"editor search-panel\"\n}, {\n  key: \"Mod-g\",\n  run: findNext,\n  shift: findPrevious,\n  scope: \"editor search-panel\"\n}, {\n  key: \"Escape\",\n  run: closeSearchPanel,\n  scope: \"editor search-panel\"\n}, {\n  key: \"Mod-Shift-l\",\n  run: selectSelectionMatches\n}, {\n  key: \"Alt-g\",\n  run: gotoLine\n}];\n\nfunction buildPanel(conf) {\n  function phrase(phrase) {\n    return conf.view.state.phrase(phrase);\n  }\n\n  let searchField = elt(\"input\", {\n    value: conf.query.search,\n    placeholder: phrase(\"Find\"),\n    \"aria-label\": phrase(\"Find\"),\n    class: \"cm-textfield\",\n    name: \"search\",\n    onchange: update,\n    onkeyup: update\n  });\n  let replaceField = elt(\"input\", {\n    value: conf.query.replace,\n    placeholder: phrase(\"Replace\"),\n    \"aria-label\": phrase(\"Replace\"),\n    class: \"cm-textfield\",\n    name: \"replace\",\n    onchange: update,\n    onkeyup: update\n  });\n  let caseField = elt(\"input\", {\n    type: \"checkbox\",\n    name: \"case\",\n    checked: !conf.query.caseInsensitive,\n    onchange: update\n  });\n  let reField = elt(\"input\", {\n    type: \"checkbox\",\n    name: \"re\",\n    checked: conf.query instanceof RegExpQuery,\n    onchange: update\n  });\n\n  function update() {\n    conf.updateQuery(new (reField.checked ? RegExpQuery : StringQuery)(searchField.value, replaceField.value, !caseField.checked));\n  }\n\n  function keydown(e) {\n    if (runScopeHandlers(conf.view, e, \"search-panel\")) {\n      e.preventDefault();\n    } else if (e.keyCode == 13 && e.target == searchField) {\n      e.preventDefault();\n      (e.shiftKey ? findPrevious : findNext)(conf.view);\n    } else if (e.keyCode == 13 && e.target == replaceField) {\n      e.preventDefault();\n      replaceNext(conf.view);\n    }\n  }\n\n  function button(name, onclick, content) {\n    return elt(\"button\", {\n      class: \"cm-button\",\n      name,\n      onclick\n    }, content);\n  }\n\n  let panel = elt(\"div\", {\n    onkeydown: keydown,\n    class: \"cm-search\"\n  }, [searchField, button(\"next\", () => findNext(conf.view), [phrase(\"next\")]), button(\"prev\", () => findPrevious(conf.view), [phrase(\"previous\")]), button(\"select\", () => selectMatches(conf.view), [phrase(\"all\")]), elt(\"label\", null, [caseField, phrase(\"match case\")]), elt(\"label\", null, [reField, phrase(\"regexp\")]), elt(\"br\"), replaceField, button(\"replace\", () => replaceNext(conf.view), [phrase(\"replace\")]), button(\"replaceAll\", () => replaceAll(conf.view), [phrase(\"replace all\")]), elt(\"button\", {\n    name: \"close\",\n    onclick: () => closeSearchPanel(conf.view),\n    \"aria-label\": phrase(\"close\")\n  }, [\"Ã—\"])]);\n  return panel;\n}\n\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\n\nfunction announceMatch(view, {\n  from,\n  to\n}) {\n  let lineStart = view.state.doc.lineAt(from).from,\n      lineEnd = view.state.doc.lineAt(to).to;\n  let start = Math.max(lineStart, from - AnnounceMargin),\n      end = Math.min(lineEnd, to + AnnounceMargin);\n  let text = view.state.sliceDoc(start, end);\n\n  if (start != lineStart) {\n    for (let i = 0; i < AnnounceMargin; i++) if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n      text = text.slice(i);\n      break;\n    }\n  }\n\n  if (end != lineEnd) {\n    for (let i = text.length - 1; i > text.length - AnnounceMargin; i--) if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n      text = text.slice(0, i);\n      break;\n    }\n  }\n\n  return EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${view.state.doc.lineAt(from).number}`);\n}\n\nconst baseTheme = EditorView.baseTheme({\n  \".cm-panel.cm-search\": {\n    padding: \"2px 6px 4px\",\n    position: \"relative\",\n    \"& [name=close]\": {\n      position: \"absolute\",\n      top: \"0\",\n      right: \"4px\",\n      backgroundColor: \"inherit\",\n      border: \"none\",\n      font: \"inherit\",\n      padding: 0,\n      margin: 0\n    },\n    \"& input, & button, & label\": {\n      margin: \".2em .6em .2em 0\"\n    },\n    \"& input[type=checkbox]\": {\n      marginRight: \".2em\"\n    },\n    \"& label\": {\n      fontSize: \"80%\"\n    }\n  },\n  \"&light .cm-searchMatch\": {\n    backgroundColor: \"#ffff0054\"\n  },\n  \"&dark .cm-searchMatch\": {\n    backgroundColor: \"#00ffff8a\"\n  },\n  \"&light .cm-searchMatch-selected\": {\n    backgroundColor: \"#ff6a0054\"\n  },\n  \"&dark .cm-searchMatch-selected\": {\n    backgroundColor: \"#ff00ff8a\"\n  }\n});\nconst searchExtensions = [searchState, Prec.override(searchHighlighter), baseTheme];\nexport { RegExpCursor, SearchCursor, closeSearchPanel, findNext, findPrevious, gotoLine, highlightSelectionMatches, openSearchPanel, replaceAll, replaceNext, searchKeymap, selectMatches, selectSelectionMatches };","map":{"version":3,"sources":["D:/MSIT/Practicum - iLMS/AssessmentsSystem/node_modules/@codemirror/search/dist/index.js"],"names":["EditorView","Decoration","ViewPlugin","runScopeHandlers","StateEffect","StateField","EditorSelection","Facet","combineConfig","CharCategory","Prec","showPanel","getPanel","RangeSetBuilder","elt","codePointAt","fromCodePoint","codePointSize","findClusterBreak","basicNormalize","String","prototype","normalize","x","SearchCursor","constructor","text","query","from","to","length","value","done","matches","buffer","bufferPos","iter","iterRange","bufferStart","peek","next","pop","nextOverlapping","str","start","norm","i","pos","code","charCodeAt","match","index","keep","splice","push","empty","exec","baseFlags","unicode","RegExpCursor","options","curLine","test","MultilineRegExpCursor","re","RegExp","ignoreCase","startLine","lineAt","curLineStart","matchPos","getLine","skip","lineBreak","slice","nextLine","off","lastIndex","flattened","WeakMap","FlattenedDoc","get","doc","cached","flat","sliceString","set","cachedFrom","chunkEnd","validRegExp","source","_a","createLineDialog","view","input","class","name","dom","onkeydown","event","keyCode","preventDefault","dispatch","effects","dialogEffect","of","focus","go","onsubmit","state","phrase","type","selection","main","head","sign","ln","cl","percent","col","line","number","pc","lines","Math","round","docLine","max","min","cursor","scrollIntoView","define","dialogField","create","update","tr","e","is","provide","f","val","gotoLine","panel","field","appendConfig","baseTheme$1","querySelector","baseTheme","padding","fontSize","defaultHighlightOptions","highlightWordAroundCursor","minSelectionLength","maxMatches","highlightConfig","combine","a","b","highlightSelectionMatches","ext","defaultTheme","matchHighlighter","wordAt","check","prev","Word","matchDeco","mark","mainMatchDeco","fromClass","decorations","getDeco","selectionSet","docChanged","viewportChanged","conf","facet","sel","ranges","none","range","charCategorizer","len","sliceDoc","trim","deco","part","visibleRanges","v","backgroundColor","Query","search","replace","caseInsensitive","eq","other","StringQuery","unquoted","_","ch","toLowerCase","undefined","nextMatch","curFrom","curTo","prevMatchInRange","prevMatch","getReplacement","_result","matchAll","limit","highlight","add","valid","RegExpQuery","size","result","m","setQuery","togglePanel","searchState","SearchState","effect","createSearchPanel","matchMark","selectedMatchMark","searchHighlighter","startState","builder","l","selected","some","r","finish","searchCommand","openSearchPanel","findNext","anchor","announceMatch","findPrevious","selectMatches","map","selectSelectionMatches","cur","replaceNext","changes","replacement","toText","insert","replaceAll","buildPanel","updateQuery","q","mount","select","searchExtensions","closeSearchPanel","contains","root","activeElement","searchKeymap","key","run","scope","shift","searchField","placeholder","onchange","onkeyup","replaceField","caseField","checked","reField","keydown","target","shiftKey","button","onclick","content","AnnounceMargin","Break","lineStart","lineEnd","end","announce","position","top","right","border","font","margin","marginRight","override"],"mappings":"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","sourcesContent":["import { EditorView, Decoration, ViewPlugin, runScopeHandlers } from '@codemirror/view';\nimport { StateEffect, StateField, EditorSelection, Facet, combineConfig, CharCategory, Prec } from '@codemirror/state';\nimport { showPanel, getPanel } from '@codemirror/panel';\nimport { RangeSetBuilder } from '@codemirror/rangeset';\nimport elt from 'crelt';\nimport { codePointAt, fromCodePoint, codePointSize, findClusterBreak } from '@codemirror/text';\n\nconst basicNormalize = typeof String.prototype.normalize == \"function\"\n    ? x => x.normalize(\"NFKD\") : x => x;\n/**\nA search cursor provides an iterator over text matches in a\ndocument.\n*/\nclass SearchCursor {\n    /**\n    Create a text cursor. The query is the search string, `from` to\n    `to` provides the region to search.\n    \n    When `normalize` is given, it will be called, on both the query\n    string and the content it is matched against, before comparing.\n    You can, for example, create a case-insensitive search by\n    passing `s => s.toLowerCase()`.\n    \n    Text is always normalized with\n    [`.normalize(\"NFKD\")`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/normalize)\n    (when supported).\n    */\n    constructor(text, query, from = 0, to = text.length, normalize) {\n        /**\n        The current match (only holds a meaningful value after\n        [`next`](https://codemirror.net/6/docs/ref/#search.SearchCursor.next) has been called and when\n        `done` is false).\n        */\n        this.value = { from: 0, to: 0 };\n        /**\n        Whether the end of the iterated region has been reached.\n        */\n        this.done = false;\n        this.matches = [];\n        this.buffer = \"\";\n        this.bufferPos = 0;\n        this.iter = text.iterRange(from, to);\n        this.bufferStart = from;\n        this.normalize = normalize ? x => normalize(basicNormalize(x)) : basicNormalize;\n        this.query = this.normalize(query);\n    }\n    peek() {\n        if (this.bufferPos == this.buffer.length) {\n            this.bufferStart += this.buffer.length;\n            this.iter.next();\n            if (this.iter.done)\n                return -1;\n            this.bufferPos = 0;\n            this.buffer = this.iter.value;\n        }\n        return codePointAt(this.buffer, this.bufferPos);\n    }\n    /**\n    Look for the next match. Updates the iterator's\n    [`value`](https://codemirror.net/6/docs/ref/#search.SearchCursor.value) and\n    [`done`](https://codemirror.net/6/docs/ref/#search.SearchCursor.done) properties. Should be called\n    at least once before using the cursor.\n    */\n    next() {\n        while (this.matches.length)\n            this.matches.pop();\n        return this.nextOverlapping();\n    }\n    /**\n    The `next` method will ignore matches that partially overlap a\n    previous match. This method behaves like `next`, but includes\n    such matches.\n    */\n    nextOverlapping() {\n        for (;;) {\n            let next = this.peek();\n            if (next < 0) {\n                this.done = true;\n                return this;\n            }\n            let str = fromCodePoint(next), start = this.bufferStart + this.bufferPos;\n            this.bufferPos += codePointSize(next);\n            let norm = this.normalize(str);\n            for (let i = 0, pos = start;; i++) {\n                let code = norm.charCodeAt(i);\n                let match = this.match(code, pos);\n                if (match) {\n                    this.value = match;\n                    return this;\n                }\n                if (i == norm.length - 1)\n                    break;\n                if (pos == start && i < str.length && str.charCodeAt(i) == code)\n                    pos++;\n            }\n        }\n    }\n    match(code, pos) {\n        let match = null;\n        for (let i = 0; i < this.matches.length; i += 2) {\n            let index = this.matches[i], keep = false;\n            if (this.query.charCodeAt(index) == code) {\n                if (index == this.query.length - 1) {\n                    match = { from: this.matches[i + 1], to: pos + 1 };\n                }\n                else {\n                    this.matches[i]++;\n                    keep = true;\n                }\n            }\n            if (!keep) {\n                this.matches.splice(i, 2);\n                i -= 2;\n            }\n        }\n        if (this.query.charCodeAt(0) == code) {\n            if (this.query.length == 1)\n                match = { from: pos, to: pos + 1 };\n            else\n                this.matches.push(1, pos);\n        }\n        return match;\n    }\n}\n\nconst empty = { from: -1, to: -1, match: /.*/.exec(\"\") };\nconst baseFlags = \"gm\" + (/x/.unicode == null ? \"\" : \"u\");\nclass RegExpCursor {\n    constructor(text, query, options, from = 0, to = text.length) {\n        this.to = to;\n        this.curLine = \"\";\n        this.done = false;\n        this.value = empty;\n        if (/\\\\[sWDnr]|\\n|\\r|\\[\\^/.test(query))\n            return new MultilineRegExpCursor(text, query, options, from, to);\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.iter = text.iter();\n        let startLine = text.lineAt(from);\n        this.curLineStart = startLine.from;\n        this.matchPos = from;\n        this.getLine(this.curLineStart);\n    }\n    getLine(skip) {\n        this.iter.next(skip);\n        if (this.iter.lineBreak) {\n            this.curLine = \"\";\n        }\n        else {\n            this.curLine = this.iter.value;\n            if (this.curLineStart + this.curLine.length > this.to)\n                this.curLine = this.curLine.slice(0, this.to - this.curLineStart);\n            this.iter.next();\n        }\n    }\n    nextLine() {\n        this.curLineStart = this.curLineStart + this.curLine.length + 1;\n        if (this.curLineStart > this.to)\n            this.curLine = \"\";\n        else\n            this.getLine(0);\n    }\n    next() {\n        for (let off = this.matchPos - this.curLineStart;;) {\n            this.re.lastIndex = off;\n            let match = this.matchPos <= this.to && this.re.exec(this.curLine);\n            if (match) {\n                let from = this.curLineStart + match.index, to = from + match[0].length;\n                this.matchPos = to + (from == to ? 1 : 0);\n                if (from == this.curLine.length)\n                    this.nextLine();\n                if (from < to || from > this.value.to) {\n                    this.value = { from, to, match };\n                    return this;\n                }\n                off = this.matchPos - this.curLineStart;\n            }\n            else if (this.curLineStart + this.curLine.length < this.to) {\n                this.nextLine();\n                off = 0;\n            }\n            else {\n                this.done = true;\n                return this;\n            }\n        }\n    }\n}\nconst flattened = new WeakMap();\n// Reusable (partially) flattened document strings\nclass FlattenedDoc {\n    constructor(from, text) {\n        this.from = from;\n        this.text = text;\n    }\n    get to() { return this.from + this.text.length; }\n    static get(doc, from, to) {\n        let cached = flattened.get(doc);\n        if (!cached || cached.from >= to || cached.to <= from) {\n            let flat = new FlattenedDoc(from, doc.sliceString(from, to));\n            flattened.set(doc, flat);\n            return flat;\n        }\n        if (cached.from == from && cached.to == to)\n            return cached;\n        let { text, from: cachedFrom } = cached;\n        if (cachedFrom > from) {\n            text = doc.sliceString(from, cachedFrom) + text;\n            cachedFrom = from;\n        }\n        if (cached.to < to)\n            text += doc.sliceString(cached.to, to);\n        flattened.set(doc, new FlattenedDoc(cachedFrom, text));\n        return new FlattenedDoc(from, text.slice(from - cachedFrom, to - cachedFrom));\n    }\n}\nclass MultilineRegExpCursor {\n    constructor(text, query, options, from, to) {\n        this.text = text;\n        this.to = to;\n        this.done = false;\n        this.value = empty;\n        this.matchPos = from;\n        this.re = new RegExp(query, baseFlags + ((options === null || options === void 0 ? void 0 : options.ignoreCase) ? \"i\" : \"\"));\n        this.flat = FlattenedDoc.get(text, from, this.chunkEnd(from + 5000 /* Base */));\n    }\n    chunkEnd(pos) {\n        return pos >= this.to ? this.to : this.text.lineAt(pos).to;\n    }\n    next() {\n        for (;;) {\n            let off = this.re.lastIndex = this.matchPos - this.flat.from;\n            let match = this.re.exec(this.flat.text);\n            // Skip empty matches directly after the last match\n            if (match && !match[0] && match.index == off) {\n                this.re.lastIndex = off + 1;\n                match = this.re.exec(this.flat.text);\n            }\n            // If a match goes almost to the end of a noncomplete chunk, try\n            // again, since it'll likely be able to match more\n            if (match && this.flat.to < this.to && match.index + match[0].length > this.flat.text.length - 10)\n                match = null;\n            if (match) {\n                let from = this.flat.from + match.index, to = from + match[0].length;\n                this.value = { from, to, match };\n                this.matchPos = to + (from == to ? 1 : 0);\n                return this;\n            }\n            else {\n                if (this.flat.to == this.to) {\n                    this.done = true;\n                    return this;\n                }\n                // Grow the flattened doc\n                this.flat = FlattenedDoc.get(this.text, this.flat.from, this.chunkEnd(this.flat.from + this.flat.text.length * 2));\n            }\n        }\n    }\n}\nfunction validRegExp(source) {\n    try {\n        new RegExp(source, baseFlags);\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\n\nfunction createLineDialog(view) {\n    let input = elt(\"input\", { class: \"cm-textfield\", name: \"line\" });\n    let dom = elt(\"form\", {\n        class: \"cm-gotoLine\",\n        onkeydown: (event) => {\n            if (event.keyCode == 27) { // Escape\n                event.preventDefault();\n                view.dispatch({ effects: dialogEffect.of(false) });\n                view.focus();\n            }\n            else if (event.keyCode == 13) { // Enter\n                event.preventDefault();\n                go();\n            }\n        },\n        onsubmit: (event) => {\n            event.preventDefault();\n            go();\n        }\n    }, elt(\"label\", view.state.phrase(\"Go to line\"), \": \", input), \" \", elt(\"button\", { class: \"cm-button\", type: \"submit\" }, view.state.phrase(\"go\")));\n    function go() {\n        let match = /^([+-])?(\\d+)?(:\\d+)?(%)?$/.exec(input.value);\n        if (!match)\n            return;\n        let { state } = view, startLine = state.doc.lineAt(state.selection.main.head);\n        let [, sign, ln, cl, percent] = match;\n        let col = cl ? +cl.slice(1) : 0;\n        let line = ln ? +ln : startLine.number;\n        if (ln && percent) {\n            let pc = line / 100;\n            if (sign)\n                pc = pc * (sign == \"-\" ? -1 : 1) + (startLine.number / state.doc.lines);\n            line = Math.round(state.doc.lines * pc);\n        }\n        else if (ln && sign) {\n            line = line * (sign == \"-\" ? -1 : 1) + startLine.number;\n        }\n        let docLine = state.doc.line(Math.max(1, Math.min(state.doc.lines, line)));\n        view.dispatch({\n            effects: dialogEffect.of(false),\n            selection: EditorSelection.cursor(docLine.from + Math.max(0, Math.min(col, docLine.length))),\n            scrollIntoView: true\n        });\n        view.focus();\n    }\n    return { dom, pos: -10 };\n}\nconst dialogEffect = StateEffect.define();\nconst dialogField = StateField.define({\n    create() { return true; },\n    update(value, tr) {\n        for (let e of tr.effects)\n            if (e.is(dialogEffect))\n                value = e.value;\n        return value;\n    },\n    provide: f => showPanel.from(f, val => val ? createLineDialog : null)\n});\n/**\nCommand that shows a dialog asking the user for a line number, and\nwhen a valid position is provided, moves the cursor to that line.\n\nSupports line numbers, relative line offsets prefixed with `+` or\n`-`, document percentages suffixed with `%`, and an optional\ncolumn position by adding `:` and a second number after the line\nnumber.\n\nThe dialog can be styled with the `panel.gotoLine` theme\nselector.\n*/\nconst gotoLine = view => {\n    let panel = getPanel(view, createLineDialog);\n    if (!panel) {\n        let effects = [dialogEffect.of(true)];\n        if (view.state.field(dialogField, false) == null)\n            effects.push(StateEffect.appendConfig.of([dialogField, baseTheme$1]));\n        view.dispatch({ effects });\n        panel = getPanel(view, createLineDialog);\n    }\n    if (panel)\n        panel.dom.querySelector(\"input\").focus();\n    return true;\n};\nconst baseTheme$1 = EditorView.baseTheme({\n    \".cm-panel.cm-gotoLine\": {\n        padding: \"2px 6px 4px\",\n        \"& label\": { fontSize: \"80%\" }\n    }\n});\n\nconst defaultHighlightOptions = {\n    highlightWordAroundCursor: false,\n    minSelectionLength: 1,\n    maxMatches: 100\n};\nconst highlightConfig = Facet.define({\n    combine(options) {\n        return combineConfig(options, defaultHighlightOptions, {\n            highlightWordAroundCursor: (a, b) => a || b,\n            minSelectionLength: Math.min,\n            maxMatches: Math.min\n        });\n    }\n});\n/**\nThis extension highlights text that matches the selection. It uses\nthe `\"cm-selectionMatch\"` class for the highlighting. When\n`highlightWordAroundCursor` is enabled, the word at the cursor\nitself will be highlighted with `\"cm-selectionMatch-main\"`.\n*/\nfunction highlightSelectionMatches(options) {\n    let ext = [defaultTheme, matchHighlighter];\n    if (options)\n        ext.push(highlightConfig.of(options));\n    return ext;\n}\nfunction wordAt(doc, pos, check) {\n    let line = doc.lineAt(pos);\n    let from = pos - line.from, to = pos - line.from;\n    while (from > 0) {\n        let prev = findClusterBreak(line.text, from, false);\n        if (check(line.text.slice(prev, from)) != CharCategory.Word)\n            break;\n        from = prev;\n    }\n    while (to < line.length) {\n        let next = findClusterBreak(line.text, to);\n        if (check(line.text.slice(to, next)) != CharCategory.Word)\n            break;\n        to = next;\n    }\n    return from == to ? null : line.text.slice(from, to);\n}\nconst matchDeco = Decoration.mark({ class: \"cm-selectionMatch\" });\nconst mainMatchDeco = Decoration.mark({ class: \"cm-selectionMatch cm-selectionMatch-main\" });\nconst matchHighlighter = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.decorations = this.getDeco(view);\n    }\n    update(update) {\n        if (update.selectionSet || update.docChanged || update.viewportChanged)\n            this.decorations = this.getDeco(update.view);\n    }\n    getDeco(view) {\n        let conf = view.state.facet(highlightConfig);\n        let { state } = view, sel = state.selection;\n        if (sel.ranges.length > 1)\n            return Decoration.none;\n        let range = sel.main, query, check = null;\n        if (range.empty) {\n            if (!conf.highlightWordAroundCursor)\n                return Decoration.none;\n            check = state.charCategorizer(range.head);\n            query = wordAt(state.doc, range.head, check);\n            if (!query)\n                return Decoration.none;\n        }\n        else {\n            let len = range.to - range.from;\n            if (len < conf.minSelectionLength || len > 200)\n                return Decoration.none;\n            query = state.sliceDoc(range.from, range.to).trim();\n            if (!query)\n                return Decoration.none;\n        }\n        let deco = [];\n        for (let part of view.visibleRanges) {\n            let cursor = new SearchCursor(state.doc, query, part.from, part.to);\n            while (!cursor.nextOverlapping().done) {\n                let { from, to } = cursor.value;\n                if (!check || ((from == 0 || check(state.sliceDoc(from - 1, from)) != CharCategory.Word) &&\n                    (to == state.doc.length || check(state.sliceDoc(to, to + 1)) != CharCategory.Word))) {\n                    if (check && from <= range.from && to >= range.to)\n                        deco.push(mainMatchDeco.range(from, to));\n                    else if (from >= range.to || to <= range.from)\n                        deco.push(matchDeco.range(from, to));\n                    if (deco.length > conf.maxMatches)\n                        return Decoration.none;\n                }\n            }\n        }\n        return Decoration.set(deco);\n    }\n}, {\n    decorations: v => v.decorations\n});\nconst defaultTheme = EditorView.baseTheme({\n    \".cm-selectionMatch\": { backgroundColor: \"#99ff7780\" },\n    \".cm-searchMatch .cm-selectionMatch\": { backgroundColor: \"transparent\" }\n});\n\nclass Query {\n    constructor(search, replace, caseInsensitive) {\n        this.search = search;\n        this.replace = replace;\n        this.caseInsensitive = caseInsensitive;\n    }\n    eq(other) {\n        return this.search == other.search && this.replace == other.replace &&\n            this.caseInsensitive == other.caseInsensitive && this.constructor == other.constructor;\n    }\n}\nclass StringQuery extends Query {\n    constructor(search, replace, caseInsensitive) {\n        super(search, replace, caseInsensitive);\n        this.unquoted = search.replace(/\\\\([nrt\\\\])/g, (_, ch) => ch == \"n\" ? \"\\n\" : ch == \"r\" ? \"\\r\" : ch == \"t\" ? \"\\t\" : \"\\\\\");\n    }\n    cursor(doc, from = 0, to = doc.length) {\n        return new SearchCursor(doc, this.unquoted, from, to, this.caseInsensitive ? x => x.toLowerCase() : undefined);\n    }\n    nextMatch(doc, curFrom, curTo) {\n        let cursor = this.cursor(doc, curTo).nextOverlapping();\n        if (cursor.done)\n            cursor = this.cursor(doc, 0, curFrom).nextOverlapping();\n        return cursor.done ? null : cursor.value;\n    }\n    // Searching in reverse is, rather than implementing inverted search\n    // cursor, done by scanning chunk after chunk forward.\n    prevMatchInRange(doc, from, to) {\n        for (let pos = to;;) {\n            let start = Math.max(from, pos - 10000 /* ChunkSize */ - this.unquoted.length);\n            let cursor = this.cursor(doc, start, pos), range = null;\n            while (!cursor.nextOverlapping().done)\n                range = cursor.value;\n            if (range)\n                return range;\n            if (start == from)\n                return null;\n            pos -= 10000 /* ChunkSize */;\n        }\n    }\n    prevMatch(doc, curFrom, curTo) {\n        return this.prevMatchInRange(doc, 0, curFrom) ||\n            this.prevMatchInRange(doc, curTo, doc.length);\n    }\n    getReplacement(_result) { return this.replace; }\n    matchAll(doc, limit) {\n        let cursor = this.cursor(doc), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(doc, from, to, add) {\n        let cursor = this.cursor(doc, Math.max(0, from - this.unquoted.length), Math.min(to + this.unquoted.length, doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n    get valid() { return !!this.search; }\n}\nclass RegExpQuery extends Query {\n    constructor(search, replace, caseInsensitive) {\n        super(search, replace, caseInsensitive);\n        this.valid = !!search && validRegExp(search);\n    }\n    cursor(doc, from = 0, to = doc.length) {\n        return new RegExpCursor(doc, this.search, this.caseInsensitive ? { ignoreCase: true } : undefined, from, to);\n    }\n    nextMatch(doc, curFrom, curTo) {\n        let cursor = this.cursor(doc, curTo).next();\n        if (cursor.done)\n            cursor = this.cursor(doc, 0, curFrom).next();\n        return cursor.done ? null : cursor.value;\n    }\n    prevMatchInRange(doc, from, to) {\n        for (let size = 1;; size++) {\n            let start = Math.max(from, to - size * 10000 /* ChunkSize */);\n            let cursor = this.cursor(doc, start, to), range = null;\n            while (!cursor.next().done)\n                range = cursor.value;\n            if (range && (start == from || range.from > start + 10))\n                return range;\n            if (start == from)\n                return null;\n        }\n    }\n    prevMatch(doc, curFrom, curTo) {\n        return this.prevMatchInRange(doc, 0, curFrom) ||\n            this.prevMatchInRange(doc, curTo, doc.length);\n    }\n    getReplacement(result) {\n        return this.replace.replace(/\\$([$&\\d+])/g, (m, i) => i == \"$\" ? \"$\"\n            : i == \"&\" ? result.match[0]\n                : i != \"0\" && +i < result.match.length ? result.match[i]\n                    : m);\n    }\n    matchAll(doc, limit) {\n        let cursor = this.cursor(doc), ranges = [];\n        while (!cursor.next().done) {\n            if (ranges.length >= limit)\n                return null;\n            ranges.push(cursor.value);\n        }\n        return ranges;\n    }\n    highlight(doc, from, to, add) {\n        let cursor = this.cursor(doc, Math.max(0, from - 250 /* HighlightMargin */), Math.min(to + 250 /* HighlightMargin */, doc.length));\n        while (!cursor.next().done)\n            add(cursor.value.from, cursor.value.to);\n    }\n}\nconst setQuery = StateEffect.define();\nconst togglePanel = StateEffect.define();\nconst searchState = StateField.define({\n    create() {\n        return new SearchState(new StringQuery(\"\", \"\", false), null);\n    },\n    update(value, tr) {\n        for (let effect of tr.effects) {\n            if (effect.is(setQuery))\n                value = new SearchState(effect.value, value.panel);\n            else if (effect.is(togglePanel))\n                value = new SearchState(value.query, effect.value ? createSearchPanel : null);\n        }\n        return value;\n    },\n    provide: f => showPanel.from(f, val => val.panel)\n});\nclass SearchState {\n    constructor(query, panel) {\n        this.query = query;\n        this.panel = panel;\n    }\n}\nconst matchMark = Decoration.mark({ class: \"cm-searchMatch\" }), selectedMatchMark = Decoration.mark({ class: \"cm-searchMatch cm-searchMatch-selected\" });\nconst searchHighlighter = ViewPlugin.fromClass(class {\n    constructor(view) {\n        this.view = view;\n        this.decorations = this.highlight(view.state.field(searchState));\n    }\n    update(update) {\n        let state = update.state.field(searchState);\n        if (state != update.startState.field(searchState) || update.docChanged || update.selectionSet)\n            this.decorations = this.highlight(state);\n    }\n    highlight({ query, panel }) {\n        if (!panel || !query.valid)\n            return Decoration.none;\n        let { view } = this;\n        let builder = new RangeSetBuilder();\n        for (let i = 0, ranges = view.visibleRanges, l = ranges.length; i < l; i++) {\n            let { from, to } = ranges[i];\n            while (i < l - 1 && to > ranges[i + 1].from - 2 * 250 /* HighlightMargin */)\n                to = ranges[++i].to;\n            query.highlight(view.state.doc, from, to, (from, to) => {\n                let selected = view.state.selection.ranges.some(r => r.from == from && r.to == to);\n                builder.add(from, to, selected ? selectedMatchMark : matchMark);\n            });\n        }\n        return builder.finish();\n    }\n}, {\n    decorations: v => v.decorations\n});\nfunction searchCommand(f) {\n    return view => {\n        let state = view.state.field(searchState, false);\n        return state && state.query.valid ? f(view, state) : openSearchPanel(view);\n    };\n}\n/**\nOpen the search panel if it isn't already open, and move the\nselection to the first match after the current main selection.\nWill wrap around to the start of the document when it reaches the\nend.\n*/\nconst findNext = searchCommand((view, { query }) => {\n    let { from, to } = view.state.selection.main;\n    let next = query.nextMatch(view.state.doc, from, to);\n    if (!next || next.from == from && next.to == to)\n        return false;\n    view.dispatch({\n        selection: { anchor: next.from, head: next.to },\n        scrollIntoView: true,\n        effects: announceMatch(view, next)\n    });\n    return true;\n});\n/**\nMove the selection to the previous instance of the search query,\nbefore the current main selection. Will wrap past the start\nof the document to start searching at the end again.\n*/\nconst findPrevious = searchCommand((view, { query }) => {\n    let { state } = view, { from, to } = state.selection.main;\n    let range = query.prevMatch(state.doc, from, to);\n    if (!range)\n        return false;\n    view.dispatch({\n        selection: { anchor: range.from, head: range.to },\n        scrollIntoView: true,\n        effects: announceMatch(view, range)\n    });\n    return true;\n});\n/**\nSelect all instances of the search query.\n*/\nconst selectMatches = searchCommand((view, { query }) => {\n    let ranges = query.matchAll(view.state.doc, 1000);\n    if (!ranges || !ranges.length)\n        return false;\n    view.dispatch({\n        selection: EditorSelection.create(ranges.map(r => EditorSelection.range(r.from, r.to)))\n    });\n    return true;\n});\n/**\nSelect all instances of the currently selected text.\n*/\nconst selectSelectionMatches = ({ state, dispatch }) => {\n    let sel = state.selection;\n    if (sel.ranges.length > 1 || sel.main.empty)\n        return false;\n    let { from, to } = sel.main;\n    let ranges = [], main = 0;\n    for (let cur = new SearchCursor(state.doc, state.sliceDoc(from, to)); !cur.next().done;) {\n        if (ranges.length > 1000)\n            return false;\n        if (cur.value.from == from)\n            main = ranges.length;\n        ranges.push(EditorSelection.range(cur.value.from, cur.value.to));\n    }\n    dispatch(state.update({ selection: EditorSelection.create(ranges, main) }));\n    return true;\n};\n/**\nReplace the current match of the search query.\n*/\nconst replaceNext = searchCommand((view, { query }) => {\n    let { state } = view, { from, to } = state.selection.main;\n    let next = query.nextMatch(state.doc, from, from);\n    if (!next)\n        return false;\n    let changes = [], selection, replacement;\n    if (next.from == from && next.to == to) {\n        replacement = state.toText(query.getReplacement(next));\n        changes.push({ from: next.from, to: next.to, insert: replacement });\n        next = query.nextMatch(state.doc, next.from, next.to);\n    }\n    if (next) {\n        let off = changes.length == 0 || changes[0].from >= next.to ? 0 : next.to - next.from - replacement.length;\n        selection = { anchor: next.from - off, head: next.to - off };\n    }\n    view.dispatch({\n        changes, selection,\n        scrollIntoView: !!selection,\n        effects: next ? announceMatch(view, next) : undefined\n    });\n    return true;\n});\n/**\nReplace all instances of the search query with the given\nreplacement.\n*/\nconst replaceAll = searchCommand((view, { query }) => {\n    let changes = query.matchAll(view.state.doc, 1e9).map(match => {\n        let { from, to } = match;\n        return { from, to, insert: query.getReplacement(match) };\n    });\n    if (!changes.length)\n        return false;\n    view.dispatch({ changes });\n    return true;\n});\nfunction createSearchPanel(view) {\n    let { query } = view.state.field(searchState);\n    return {\n        dom: buildPanel({\n            view,\n            query,\n            updateQuery(q) {\n                if (!query.eq(q)) {\n                    query = q;\n                    view.dispatch({ effects: setQuery.of(query) });\n                }\n            }\n        }),\n        mount() {\n            this.dom.querySelector(\"[name=search]\").select();\n        },\n        pos: 80\n    };\n}\n/**\nMake sure the search panel is open and focused.\n*/\nconst openSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (state && state.panel) {\n        let panel = getPanel(view, createSearchPanel);\n        if (!panel)\n            return false;\n        panel.dom.querySelector(\"[name=search]\").focus();\n    }\n    else {\n        view.dispatch({ effects: [togglePanel.of(true), ...state ? [] : [StateEffect.appendConfig.of(searchExtensions)]] });\n    }\n    return true;\n};\n/**\nClose the search panel.\n*/\nconst closeSearchPanel = view => {\n    let state = view.state.field(searchState, false);\n    if (!state || !state.panel)\n        return false;\n    let panel = getPanel(view, createSearchPanel);\n    if (panel && panel.dom.contains(view.root.activeElement))\n        view.focus();\n    view.dispatch({ effects: togglePanel.of(false) });\n    return true;\n};\n/**\nDefault search-related key bindings.\n\n - Mod-f: [`openSearchPanel`](https://codemirror.net/6/docs/ref/#search.openSearchPanel)\n - F3, Mod-g: [`findNext`](https://codemirror.net/6/docs/ref/#search.findNext)\n - Shift-F3, Shift-Mod-g: [`findPrevious`](https://codemirror.net/6/docs/ref/#search.findPrevious)\n - Alt-g: [`gotoLine`](https://codemirror.net/6/docs/ref/#search.gotoLine)\n*/\nconst searchKeymap = [\n    { key: \"Mod-f\", run: openSearchPanel, scope: \"editor search-panel\" },\n    { key: \"F3\", run: findNext, shift: findPrevious, scope: \"editor search-panel\" },\n    { key: \"Mod-g\", run: findNext, shift: findPrevious, scope: \"editor search-panel\" },\n    { key: \"Escape\", run: closeSearchPanel, scope: \"editor search-panel\" },\n    { key: \"Mod-Shift-l\", run: selectSelectionMatches },\n    { key: \"Alt-g\", run: gotoLine }\n];\nfunction buildPanel(conf) {\n    function phrase(phrase) { return conf.view.state.phrase(phrase); }\n    let searchField = elt(\"input\", {\n        value: conf.query.search,\n        placeholder: phrase(\"Find\"),\n        \"aria-label\": phrase(\"Find\"),\n        class: \"cm-textfield\",\n        name: \"search\",\n        onchange: update,\n        onkeyup: update\n    });\n    let replaceField = elt(\"input\", {\n        value: conf.query.replace,\n        placeholder: phrase(\"Replace\"),\n        \"aria-label\": phrase(\"Replace\"),\n        class: \"cm-textfield\",\n        name: \"replace\",\n        onchange: update,\n        onkeyup: update\n    });\n    let caseField = elt(\"input\", {\n        type: \"checkbox\",\n        name: \"case\",\n        checked: !conf.query.caseInsensitive,\n        onchange: update\n    });\n    let reField = elt(\"input\", {\n        type: \"checkbox\",\n        name: \"re\",\n        checked: conf.query instanceof RegExpQuery,\n        onchange: update\n    });\n    function update() {\n        conf.updateQuery(new (reField.checked ? RegExpQuery : StringQuery)(searchField.value, replaceField.value, !caseField.checked));\n    }\n    function keydown(e) {\n        if (runScopeHandlers(conf.view, e, \"search-panel\")) {\n            e.preventDefault();\n        }\n        else if (e.keyCode == 13 && e.target == searchField) {\n            e.preventDefault();\n            (e.shiftKey ? findPrevious : findNext)(conf.view);\n        }\n        else if (e.keyCode == 13 && e.target == replaceField) {\n            e.preventDefault();\n            replaceNext(conf.view);\n        }\n    }\n    function button(name, onclick, content) {\n        return elt(\"button\", { class: \"cm-button\", name, onclick }, content);\n    }\n    let panel = elt(\"div\", { onkeydown: keydown, class: \"cm-search\" }, [\n        searchField,\n        button(\"next\", () => findNext(conf.view), [phrase(\"next\")]),\n        button(\"prev\", () => findPrevious(conf.view), [phrase(\"previous\")]),\n        button(\"select\", () => selectMatches(conf.view), [phrase(\"all\")]),\n        elt(\"label\", null, [caseField, phrase(\"match case\")]),\n        elt(\"label\", null, [reField, phrase(\"regexp\")]),\n        elt(\"br\"),\n        replaceField,\n        button(\"replace\", () => replaceNext(conf.view), [phrase(\"replace\")]),\n        button(\"replaceAll\", () => replaceAll(conf.view), [phrase(\"replace all\")]),\n        elt(\"button\", { name: \"close\", onclick: () => closeSearchPanel(conf.view), \"aria-label\": phrase(\"close\") }, [\"Ã—\"])\n    ]);\n    return panel;\n}\nconst AnnounceMargin = 30;\nconst Break = /[\\s\\.,:;?!]/;\nfunction announceMatch(view, { from, to }) {\n    let lineStart = view.state.doc.lineAt(from).from, lineEnd = view.state.doc.lineAt(to).to;\n    let start = Math.max(lineStart, from - AnnounceMargin), end = Math.min(lineEnd, to + AnnounceMargin);\n    let text = view.state.sliceDoc(start, end);\n    if (start != lineStart) {\n        for (let i = 0; i < AnnounceMargin; i++)\n            if (!Break.test(text[i + 1]) && Break.test(text[i])) {\n                text = text.slice(i);\n                break;\n            }\n    }\n    if (end != lineEnd) {\n        for (let i = text.length - 1; i > text.length - AnnounceMargin; i--)\n            if (!Break.test(text[i - 1]) && Break.test(text[i])) {\n                text = text.slice(0, i);\n                break;\n            }\n    }\n    return EditorView.announce.of(`${view.state.phrase(\"current match\")}. ${text} ${view.state.phrase(\"on line\")} ${view.state.doc.lineAt(from).number}`);\n}\nconst baseTheme = EditorView.baseTheme({\n    \".cm-panel.cm-search\": {\n        padding: \"2px 6px 4px\",\n        position: \"relative\",\n        \"& [name=close]\": {\n            position: \"absolute\",\n            top: \"0\",\n            right: \"4px\",\n            backgroundColor: \"inherit\",\n            border: \"none\",\n            font: \"inherit\",\n            padding: 0,\n            margin: 0\n        },\n        \"& input, & button, & label\": {\n            margin: \".2em .6em .2em 0\"\n        },\n        \"& input[type=checkbox]\": {\n            marginRight: \".2em\"\n        },\n        \"& label\": {\n            fontSize: \"80%\"\n        }\n    },\n    \"&light .cm-searchMatch\": { backgroundColor: \"#ffff0054\" },\n    \"&dark .cm-searchMatch\": { backgroundColor: \"#00ffff8a\" },\n    \"&light .cm-searchMatch-selected\": { backgroundColor: \"#ff6a0054\" },\n    \"&dark .cm-searchMatch-selected\": { backgroundColor: \"#ff00ff8a\" }\n});\nconst searchExtensions = [\n    searchState,\n    Prec.override(searchHighlighter),\n    baseTheme\n];\n\nexport { RegExpCursor, SearchCursor, closeSearchPanel, findNext, findPrevious, gotoLine, highlightSelectionMatches, openSearchPanel, replaceAll, replaceNext, searchKeymap, selectMatches, selectSelectionMatches };\n"]},"metadata":{},"sourceType":"module"}