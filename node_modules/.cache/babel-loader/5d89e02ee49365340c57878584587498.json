{"ast":null,"code":"import { parser } from 'lezer-python';\nimport { LezerLanguage, indentNodeProp, continuedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\nimport { styleTags, tags } from '@codemirror/highlight'; /// A language provider based on the [Lezer Python\n/// parser](https://github.com/lezer-parser/python), extended with\n/// highlighting and indentation information.\n\nconst pythonLanguage = LezerLanguage.define({\n  parser: parser.configure({\n    props: [indentNodeProp.add({\n      Body: continuedIndent()\n    }), foldNodeProp.add({\n      \"Body ArrayExpression DictionaryExpression\": foldInside\n    }), styleTags({\n      \"async '*' '**' FormatConversion\": tags.modifier,\n      \"for while if elif else try except finally return raise break continue with pass assert await yield\": tags.controlKeyword,\n      \"in not and or is del\": tags.operatorKeyword,\n      \"import from def class global nonlocal lambda\": tags.definitionKeyword,\n      \"with as print\": tags.keyword,\n      self: tags.self,\n      Boolean: tags.bool,\n      None: tags.null,\n      VariableName: tags.variableName,\n      \"CallExpression/VariableName\": tags.function(tags.variableName),\n      \"FunctionDefinition/VariableName\": tags.function(tags.definition(tags.variableName)),\n      \"ClassDefinition/VariableName\": tags.definition(tags.className),\n      PropertyName: tags.propertyName,\n      \"CallExpression/MemberExpression/ProperyName\": tags.function(tags.propertyName),\n      Comment: tags.lineComment,\n      Number: tags.number,\n      String: tags.string,\n      FormatString: tags.special(tags.string),\n      UpdateOp: tags.updateOperator,\n      ArithOp: tags.arithmeticOperator,\n      BitOp: tags.bitwiseOperator,\n      CompareOp: tags.compareOperator,\n      AssignOp: tags.definitionOperator,\n      Ellipsis: tags.punctuation,\n      At: tags.meta,\n      \"( )\": tags.paren,\n      \"[ ]\": tags.squareBracket,\n      \"{ }\": tags.brace,\n      \".\": tags.derefOperator,\n      \", ;\": tags.separator\n    })]\n  }),\n  languageData: {\n    closeBrackets: {\n      brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"'''\", '\"\"\"']\n    },\n    commentTokens: {\n      line: \"#\"\n    },\n    indentOnInput: /^\\s*[\\}\\]\\)]$/\n  }\n}); /// Python language support.\n\nfunction python() {\n  return new LanguageSupport(pythonLanguage);\n}\n\nexport { python, pythonLanguage };","map":{"version":3,"sources":["D:/MSIT/Practicum - iLMS/AssessmentsSystem/node_modules/@codemirror/lang-python/dist/index.js"],"names":["parser","LezerLanguage","indentNodeProp","continuedIndent","foldNodeProp","foldInside","LanguageSupport","styleTags","tags","pythonLanguage","define","configure","props","add","Body","modifier","controlKeyword","operatorKeyword","definitionKeyword","keyword","self","Boolean","bool","None","null","VariableName","variableName","function","definition","className","PropertyName","propertyName","Comment","lineComment","Number","number","String","string","FormatString","special","UpdateOp","updateOperator","ArithOp","arithmeticOperator","BitOp","bitwiseOperator","CompareOp","compareOperator","AssignOp","definitionOperator","Ellipsis","punctuation","At","meta","paren","squareBracket","brace","derefOperator","separator","languageData","closeBrackets","brackets","commentTokens","line","indentOnInput","python"],"mappings":"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","sourcesContent":["import { parser } from 'lezer-python';\nimport { LezerLanguage, indentNodeProp, continuedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';\nimport { styleTags, tags } from '@codemirror/highlight';\n\n/// A language provider based on the [Lezer Python\n/// parser](https://github.com/lezer-parser/python), extended with\n/// highlighting and indentation information.\nconst pythonLanguage = LezerLanguage.define({\n    parser: parser.configure({\n        props: [\n            indentNodeProp.add({\n                Body: continuedIndent()\n            }),\n            foldNodeProp.add({\n                \"Body ArrayExpression DictionaryExpression\": foldInside\n            }),\n            styleTags({\n                \"async '*' '**' FormatConversion\": tags.modifier,\n                \"for while if elif else try except finally return raise break continue with pass assert await yield\": tags.controlKeyword,\n                \"in not and or is del\": tags.operatorKeyword,\n                \"import from def class global nonlocal lambda\": tags.definitionKeyword,\n                \"with as print\": tags.keyword,\n                self: tags.self,\n                Boolean: tags.bool,\n                None: tags.null,\n                VariableName: tags.variableName,\n                \"CallExpression/VariableName\": tags.function(tags.variableName),\n                \"FunctionDefinition/VariableName\": tags.function(tags.definition(tags.variableName)),\n                \"ClassDefinition/VariableName\": tags.definition(tags.className),\n                PropertyName: tags.propertyName,\n                \"CallExpression/MemberExpression/ProperyName\": tags.function(tags.propertyName),\n                Comment: tags.lineComment,\n                Number: tags.number,\n                String: tags.string,\n                FormatString: tags.special(tags.string),\n                UpdateOp: tags.updateOperator,\n                ArithOp: tags.arithmeticOperator,\n                BitOp: tags.bitwiseOperator,\n                CompareOp: tags.compareOperator,\n                AssignOp: tags.definitionOperator,\n                Ellipsis: tags.punctuation,\n                At: tags.meta,\n                \"( )\": tags.paren,\n                \"[ ]\": tags.squareBracket,\n                \"{ }\": tags.brace,\n                \".\": tags.derefOperator,\n                \", ;\": tags.separator\n            })\n        ],\n    }),\n    languageData: {\n        closeBrackets: { brackets: [\"(\", \"[\", \"{\", \"'\", '\"', \"'''\", '\"\"\"'] },\n        commentTokens: { line: \"#\" },\n        indentOnInput: /^\\s*[\\}\\]\\)]$/\n    }\n});\n/// Python language support.\nfunction python() {\n    return new LanguageSupport(pythonLanguage);\n}\n\nexport { python, pythonLanguage };\n"]},"metadata":{},"sourceType":"module"}