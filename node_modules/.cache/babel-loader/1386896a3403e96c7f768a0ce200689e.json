{"ast":null,"code":"/// The default maximum length of a `TreeBuffer` node.\nconst DefaultBufferLength = 1024;\nlet nextPropID = 0;\nconst CachedNode = new WeakMap(); /// Each [node type](#tree.NodeType) can have metadata associated with\n/// it in props. Instances of this class represent prop names.\n\nclass NodeProp {\n  /// Create a new node prop type. You can optionally pass a\n  /// `deserialize` function.\n  constructor({\n    deserialize\n  } = {}) {\n    this.id = nextPropID++;\n\n    this.deserialize = deserialize || (() => {\n      throw new Error(\"This node type doesn't define a deserialize function\");\n    });\n  } /// Create a string-valued node prop whose deserialize function is\n  /// the identity function.\n\n\n  static string() {\n    return new NodeProp({\n      deserialize: str => str\n    });\n  } /// Create a number-valued node prop whose deserialize function is\n  /// just `Number`.\n\n\n  static number() {\n    return new NodeProp({\n      deserialize: Number\n    });\n  } /// Creates a boolean-valued node prop whose deserialize function\n  /// returns true for any input.\n\n\n  static flag() {\n    return new NodeProp({\n      deserialize: () => true\n    });\n  } /// Store a value for this prop in the given object. This can be\n  /// useful when building up a prop object to pass to the\n  /// [`NodeType`](#tree.NodeType) constructor. Returns its first\n  /// argument.\n\n\n  set(propObj, value) {\n    propObj[this.id] = value;\n    return propObj;\n  } /// This is meant to be used with\n  /// [`NodeSet.extend`](#tree.NodeSet.extend) or\n  /// [`Parser.withProps`](#lezer.Parser.withProps) to compute prop\n  /// values for each node type in the set. Takes a [match\n  /// object](#tree.NodeType^match) or function that returns undefined\n  /// if the node type doesn't get this prop, and the prop's value if\n  /// it does.\n\n\n  add(match) {\n    if (typeof match != \"function\") match = NodeType.match(match);\n    return type => {\n      let result = match(type);\n      return result === undefined ? null : [this, result];\n    };\n  }\n\n} /// Prop that is used to describe matching delimiters. For opening\n/// delimiters, this holds an array of node names (written as a\n/// space-separated string when declaring this prop in a grammar)\n/// for the node types of closing delimiters that match it.\n\n\nNodeProp.closedBy = new NodeProp({\n  deserialize: str => str.split(\" \")\n}); /// The inverse of [`openedBy`](#tree.NodeProp^closedBy). This is\n/// attached to closing delimiters, holding an array of node names\n/// of types of matching opening delimiters.\n\nNodeProp.openedBy = new NodeProp({\n  deserialize: str => str.split(\" \")\n}); /// Used to assign node types to groups (for example, all node\n/// types that represent an expression could be tagged with an\n/// `\"Expression\"` group).\n\nNodeProp.group = new NodeProp({\n  deserialize: str => str.split(\" \")\n});\nconst noProps = Object.create(null); /// Each node in a syntax tree has a node type associated with it.\n\nclass NodeType {\n  /// @internal\n  constructor( /// The name of the node type. Not necessarily unique, but if the\n  /// grammar was written properly, different node types with the\n  /// same name within a node set should play the same semantic\n  /// role.\n  name, /// @internal\n  props, /// The id of this node in its set. Corresponds to the term ids\n  /// used in the parser.\n  id, /// @internal\n  flags = 0) {\n    this.name = name;\n    this.props = props;\n    this.id = id;\n    this.flags = flags;\n  }\n\n  static define(spec) {\n    let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n    let flags = (spec.top ? 1\n    /* Top */\n    : 0) | (spec.skipped ? 2\n    /* Skipped */\n    : 0) | (spec.error ? 4\n    /* Error */\n    : 0) | (spec.name == null ? 8\n    /* Anonymous */\n    : 0);\n    let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n    if (spec.props) for (let src of spec.props) {\n      if (!Array.isArray(src)) src = src(type);\n      if (src) src[0].set(props, src[1]);\n    }\n    return type;\n  } /// Retrieves a node prop for this type. Will return `undefined` if\n  /// the prop isn't present on this node.\n\n\n  prop(prop) {\n    return this.props[prop.id];\n  } /// True when this is the top node of a grammar.\n\n\n  get isTop() {\n    return (this.flags & 1\n    /* Top */\n    ) > 0;\n  } /// True when this node is produced by a skip rule.\n\n\n  get isSkipped() {\n    return (this.flags & 2\n    /* Skipped */\n    ) > 0;\n  } /// Indicates whether this is an error node.\n\n\n  get isError() {\n    return (this.flags & 4\n    /* Error */\n    ) > 0;\n  } /// When true, this node type doesn't correspond to a user-declared\n  /// named node, for example because it is used to cache repetition.\n\n\n  get isAnonymous() {\n    return (this.flags & 8\n    /* Anonymous */\n    ) > 0;\n  } /// Returns true when this node's name or one of its\n  /// [groups](#tree.NodeProp^group) matches the given string.\n\n\n  is(name) {\n    if (typeof name == 'string') {\n      if (this.name == name) return true;\n      let group = this.prop(NodeProp.group);\n      return group ? group.indexOf(name) > -1 : false;\n    }\n\n    return this.id == name;\n  } /// Create a function from node types to arbitrary values by\n  /// specifying an object whose property names are node or\n  /// [group](#tree.NodeProp^group) names. Often useful with\n  /// [`NodeProp.add`](#tree.NodeProp.add). You can put multiple\n  /// names, separated by spaces, in a single property name to map\n  /// multiple node names to a single value.\n\n\n  static match(map) {\n    let direct = Object.create(null);\n\n    for (let prop in map) for (let name of prop.split(\" \")) direct[name] = map[prop];\n\n    return node => {\n      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n        let found = direct[i < 0 ? node.name : groups[i]];\n        if (found) return found;\n      }\n    };\n  }\n\n} /// An empty dummy node type to use when no actual type is available.\n\n\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8\n/* Anonymous */\n); /// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a number array. Each parser\n/// [has](#lezer.Parser.nodeSet) a node set, and [tree\n/// buffers](#tree.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536)\n/// node types in it, so that the ids fit into 16-bit typed array\n/// slots.\n\nclass NodeSet {\n  /// Create a set with the given types. The `id` property of each\n  /// type should correspond to its position within the array.\n  constructor( /// The node types in this set, by id.\n  types) {\n    this.types = types;\n\n    for (let i = 0; i < types.length; i++) if (types[i].id != i) throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n  } /// Create a copy of this set with some node properties added. The\n  /// arguments to this method should be created with\n  /// [`NodeProp.add`](#tree.NodeProp.add).\n\n\n  extend(...props) {\n    let newTypes = [];\n\n    for (let type of this.types) {\n      let newProps = null;\n\n      for (let source of props) {\n        let add = source(type);\n\n        if (add) {\n          if (!newProps) newProps = Object.assign({}, type.props);\n          add[0].set(newProps, add[1]);\n        }\n      }\n\n      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n    }\n\n    return new NodeSet(newTypes);\n  }\n\n} /// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the `TreeCursor` interface instead, which provides a view on\n/// some part of this data structure, and can be used to move around\n/// to adjacent nodes.\n\n\nclass Tree {\n  /// Construct a new tree. You usually want to go through\n  /// [`Tree.build`](#tree.Tree^build) instead.\n  constructor(type, /// The tree's child nodes. Children small enough to fit in a\n  /// `TreeBuffer will be represented as such, other children can be\n  /// further `Tree` instances with their own internal structure.\n  children, /// The positions (offsets relative to the start of this tree) of\n  /// the children.\n  positions, /// The total length of this tree\n  length) {\n    this.type = type;\n    this.children = children;\n    this.positions = positions;\n    this.length = length;\n  } /// @internal\n\n\n  toString() {\n    let children = this.children.map(c => c.toString()).join();\n    return !this.type.name ? children : (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) + (children.length ? \"(\" + children + \")\" : \"\");\n  } /// Get a [tree cursor](#tree.TreeCursor) rooted at this tree. When\n  /// `pos` is given, the cursor is [moved](#tree.TreeCursor.moveTo)\n  /// to the given position and side.\n\n\n  cursor(pos, side = 0) {\n    let scope = pos != null && CachedNode.get(this) || this.topNode;\n    let cursor = new TreeCursor(scope);\n\n    if (pos != null) {\n      cursor.moveTo(pos, side);\n      CachedNode.set(this, cursor._tree);\n    }\n\n    return cursor;\n  } /// Get a [tree cursor](#tree.TreeCursor) that, unlike regular\n  /// cursors, doesn't skip [anonymous](#tree.NodeType.isAnonymous)\n  /// nodes.\n\n\n  fullCursor() {\n    return new TreeCursor(this.topNode, true);\n  } /// Get a [syntax node](#tree.SyntaxNode) object for the top of the\n  /// tree.\n\n\n  get topNode() {\n    return new TreeNode(this, 0, 0, null);\n  } /// Get the [syntax node](#tree.SyntaxNode) at the given position.\n  /// If `side` is -1, this will move into nodes that end at the\n  /// position. If 1, it'll move into nodes that start at the\n  /// position. With 0, it'll only enter nodes that cover the position\n  /// from both sides.\n\n\n  resolve(pos, side = 0) {\n    return this.cursor(pos, side).node;\n  } /// Iterate over the tree and its children, calling `enter` for any\n  /// node that touches the `from`/`to` region (if given) before\n  /// running over such a node's children, and `leave` (if given) when\n  /// leaving the node. When `enter` returns `false`, the given node\n  /// will not have its children iterated over (or `leave` called).\n\n\n  iterate(spec) {\n    let {\n      enter,\n      leave,\n      from = 0,\n      to = this.length\n    } = spec;\n\n    for (let c = this.cursor();;) {\n      let mustLeave = false;\n\n      if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to) !== false)) {\n        if (c.firstChild()) continue;\n        if (!c.type.isAnonymous) mustLeave = true;\n      }\n\n      for (;;) {\n        if (mustLeave && leave) leave(c.type, c.from, c.to);\n        mustLeave = c.type.isAnonymous;\n        if (c.nextSibling()) break;\n        if (!c.parent()) return;\n        mustLeave = true;\n      }\n    }\n  } /// Balance the direct children of this tree.\n\n\n  balance(maxBufferLength = DefaultBufferLength) {\n    return this.children.length <= BalanceBranchFactor ? this : balanceRange(this.type, NodeType.none, this.children, this.positions, 0, this.children.length, 0, maxBufferLength, this.length, 0);\n  } /// Build a tree from a postfix-ordered buffer of node information,\n  /// or a cursor over such a buffer.\n\n\n  static build(data) {\n    return buildTree(data);\n  }\n\n} /// The empty tree\n\n\nTree.empty = new Tree(NodeType.none, [], [], 0); // For trees that need a context hash attached, we're using this\n// kludge which assigns an extra property directly after\n// initialization (creating a single new object shape).\n\nfunction withHash(tree, hash) {\n  if (hash) tree.contextHash = hash;\n  return tree;\n} /// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it)\n\n\nclass TreeBuffer {\n  /// Create a tree buffer @internal\n  constructor( /// @internal\n  buffer, // The total length of the group of nodes in the buffer.\n  length, /// @internal\n  set, type = NodeType.none) {\n    this.buffer = buffer;\n    this.length = length;\n    this.set = set;\n    this.type = type;\n  } /// @internal\n\n\n  toString() {\n    let result = [];\n\n    for (let index = 0; index < this.buffer.length;) {\n      result.push(this.childString(index));\n      index = this.buffer[index + 3];\n    }\n\n    return result.join(\",\");\n  } /// @internal\n\n\n  childString(index) {\n    let id = this.buffer[index],\n        endIndex = this.buffer[index + 3];\n    let type = this.set.types[id],\n        result = type.name;\n    if (/\\W/.test(result) && !type.isError) result = JSON.stringify(result);\n    index += 4;\n    if (endIndex == index) return result;\n    let children = [];\n\n    while (index < endIndex) {\n      children.push(this.childString(index));\n      index = this.buffer[index + 3];\n    }\n\n    return result + \"(\" + children.join(\",\") + \")\";\n  } /// @internal\n\n\n  findChild(startIndex, endIndex, dir, after) {\n    let {\n      buffer\n    } = this,\n        pick = -1;\n\n    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n      if (after != -100000000\n      /* None */\n      ) {\n          let start = buffer[i + 1],\n              end = buffer[i + 2];\n\n          if (dir > 0) {\n            if (end > after) pick = i;\n            if (end > after) break;\n          } else {\n            if (start < after) pick = i;\n            if (end >= after) break;\n          }\n        } else {\n        pick = i;\n        if (dir > 0) break;\n      }\n    }\n\n    return pick;\n  }\n\n}\n\nclass TreeNode {\n  constructor(node, from, index, _parent) {\n    this.node = node;\n    this.from = from;\n    this.index = index;\n    this._parent = _parent;\n  }\n\n  get type() {\n    return this.node.type;\n  }\n\n  get name() {\n    return this.node.type.name;\n  }\n\n  get to() {\n    return this.from + this.node.length;\n  }\n\n  nextChild(i, dir, after, full = false) {\n    for (let parent = this;;) {\n      for (let {\n        children,\n        positions\n      } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n        let next = children[i],\n            start = positions[i] + parent.from;\n        if (after != -100000000\n        /* None */\n        && (dir < 0 ? start >= after : start + next.length <= after)) continue;\n\n        if (next instanceof TreeBuffer) {\n          let index = next.findChild(0, next.buffer.length, dir, after == -100000000\n          /* None */\n          ? -100000000\n          /* None */\n          : after - start);\n          if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n        } else if (full || !next.type.isAnonymous || hasChild(next)) {\n          let inner = new TreeNode(next, start, i, parent);\n          return full || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, after);\n        }\n      }\n\n      if (full || !parent.type.isAnonymous) return null;\n      i = parent.index + dir;\n      parent = parent._parent;\n      if (!parent) return null;\n    }\n  }\n\n  get firstChild() {\n    return this.nextChild(0, 1, -100000000\n    /* None */\n    );\n  }\n\n  get lastChild() {\n    return this.nextChild(this.node.children.length - 1, -1, -100000000\n    /* None */\n    );\n  }\n\n  childAfter(pos) {\n    return this.nextChild(0, 1, pos);\n  }\n\n  childBefore(pos) {\n    return this.nextChild(this.node.children.length - 1, -1, pos);\n  }\n\n  nextSignificantParent() {\n    let val = this;\n\n    while (val.type.isAnonymous && val._parent) val = val._parent;\n\n    return val;\n  }\n\n  get parent() {\n    return this._parent ? this._parent.nextSignificantParent() : null;\n  }\n\n  get nextSibling() {\n    return this._parent ? this._parent.nextChild(this.index + 1, 1, -1) : null;\n  }\n\n  get prevSibling() {\n    return this._parent ? this._parent.nextChild(this.index - 1, -1, -1) : null;\n  }\n\n  get cursor() {\n    return new TreeCursor(this);\n  }\n\n  resolve(pos, side = 0) {\n    return this.cursor.moveTo(pos, side).node;\n  }\n\n  getChild(type, before = null, after = null) {\n    let r = getChildren(this, type, before, after);\n    return r.length ? r[0] : null;\n  }\n\n  getChildren(type, before = null, after = null) {\n    return getChildren(this, type, before, after);\n  } /// @internal\n\n\n  toString() {\n    return this.node.toString();\n  }\n\n}\n\nfunction getChildren(node, type, before, after) {\n  let cur = node.cursor,\n      result = [];\n  if (!cur.firstChild()) return result;\n  if (before != null) while (!cur.type.is(before)) if (!cur.nextSibling()) return result;\n\n  for (;;) {\n    if (after != null && cur.type.is(after)) return result;\n    if (cur.type.is(type)) result.push(cur.node);\n    if (!cur.nextSibling()) return after == null ? result : [];\n  }\n}\n\nclass BufferContext {\n  constructor(parent, buffer, index, start) {\n    this.parent = parent;\n    this.buffer = buffer;\n    this.index = index;\n    this.start = start;\n  }\n\n}\n\nclass BufferNode {\n  constructor(context, _parent, index) {\n    this.context = context;\n    this._parent = _parent;\n    this.index = index;\n    this.type = context.buffer.set.types[context.buffer.buffer[index]];\n  }\n\n  get name() {\n    return this.type.name;\n  }\n\n  get from() {\n    return this.context.start + this.context.buffer.buffer[this.index + 1];\n  }\n\n  get to() {\n    return this.context.start + this.context.buffer.buffer[this.index + 2];\n  }\n\n  child(dir, after) {\n    let {\n      buffer\n    } = this.context;\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -100000000\n    /* None */\n    ? -100000000\n    /* None */\n    : after - this.context.start);\n    return index < 0 ? null : new BufferNode(this.context, this, index);\n  }\n\n  get firstChild() {\n    return this.child(1, -100000000\n    /* None */\n    );\n  }\n\n  get lastChild() {\n    return this.child(-1, -100000000\n    /* None */\n    );\n  }\n\n  childAfter(pos) {\n    return this.child(1, pos);\n  }\n\n  childBefore(pos) {\n    return this.child(-1, pos);\n  }\n\n  get parent() {\n    return this._parent || this.context.parent.nextSignificantParent();\n  }\n\n  externalSibling(dir) {\n    return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, -1);\n  }\n\n  get nextSibling() {\n    let {\n      buffer\n    } = this.context;\n    let after = buffer.buffer[this.index + 3];\n    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length)) return new BufferNode(this.context, this._parent, after);\n    return this.externalSibling(1);\n  }\n\n  get prevSibling() {\n    let {\n      buffer\n    } = this.context;\n    let parentStart = this._parent ? this._parent.index + 4 : 0;\n    if (this.index == parentStart) return this.externalSibling(-1);\n    return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, -100000000\n    /* None */\n    ));\n  }\n\n  get cursor() {\n    return new TreeCursor(this);\n  }\n\n  resolve(pos, side = 0) {\n    return this.cursor.moveTo(pos, side).node;\n  } /// @internal\n\n\n  toString() {\n    return this.context.buffer.childString(this.index);\n  }\n\n  getChild(type, before = null, after = null) {\n    let r = getChildren(this, type, before, after);\n    return r.length ? r[0] : null;\n  }\n\n  getChildren(type, before = null, after = null) {\n    return getChildren(this, type, before, after);\n  }\n\n} /// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\n\n\nclass TreeCursor {\n  /// @internal\n  constructor(node, full = false) {\n    this.full = full;\n    this.buffer = null;\n    this.stack = [];\n    this.index = 0;\n    this.bufferNode = null;\n\n    if (node instanceof TreeNode) {\n      this.yieldNode(node);\n    } else {\n      this._tree = node.context.parent;\n      this.buffer = node.context;\n\n      for (let n = node._parent; n; n = n._parent) this.stack.unshift(n.index);\n\n      this.bufferNode = node;\n      this.yieldBuf(node.index);\n    }\n  } /// Shorthand for `.type.name`.\n\n\n  get name() {\n    return this.type.name;\n  }\n\n  yieldNode(node) {\n    if (!node) return false;\n    this._tree = node;\n    this.type = node.type;\n    this.from = node.from;\n    this.to = node.to;\n    return true;\n  }\n\n  yieldBuf(index, type) {\n    this.index = index;\n    let {\n      start,\n      buffer\n    } = this.buffer;\n    this.type = type || buffer.set.types[buffer.buffer[index]];\n    this.from = start + buffer.buffer[index + 1];\n    this.to = start + buffer.buffer[index + 2];\n    return true;\n  }\n\n  yield(node) {\n    if (!node) return false;\n\n    if (node instanceof TreeNode) {\n      this.buffer = null;\n      return this.yieldNode(node);\n    }\n\n    this.buffer = node.context;\n    return this.yieldBuf(node.index, node.type);\n  } /// @internal\n\n\n  toString() {\n    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n  } /// @internal\n\n\n  enter(dir, after) {\n    if (!this.buffer) return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, after, this.full));\n    let {\n      buffer\n    } = this.buffer;\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, after == -100000000\n    /* None */\n    ? -100000000\n    /* None */\n    : after - this.buffer.start);\n    if (index < 0) return false;\n    this.stack.push(this.index);\n    return this.yieldBuf(index);\n  } /// Move the cursor to this node's first child. When this returns\n  /// false, the node has no child, and the cursor has not been moved.\n\n\n  firstChild() {\n    return this.enter(1, -100000000\n    /* None */\n    );\n  } /// Move the cursor to this node's last child.\n\n\n  lastChild() {\n    return this.enter(-1, -100000000\n    /* None */\n    );\n  } /// Move the cursor to the first child that starts at or after `pos`.\n\n\n  childAfter(pos) {\n    return this.enter(1, pos);\n  } /// Move to the last child that ends at or before `pos`.\n\n\n  childBefore(pos) {\n    return this.enter(-1, pos);\n  } /// Move the node's parent node, if this isn't the top node.\n\n\n  parent() {\n    if (!this.buffer) return this.yieldNode(this.full ? this._tree._parent : this._tree.parent);\n    if (this.stack.length) return this.yieldBuf(this.stack.pop());\n    let parent = this.full ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n    this.buffer = null;\n    return this.yieldNode(parent);\n  } /// @internal\n\n\n  sibling(dir) {\n    if (!this.buffer) return !this._tree._parent ? false : this.yield(this._tree._parent.nextChild(this._tree.index + dir, dir, -100000000\n    /* None */\n    , this.full));\n    let {\n      buffer\n    } = this.buffer,\n        d = this.stack.length - 1;\n\n    if (dir < 0) {\n      let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n      if (this.index != parentStart) return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, -100000000\n      /* None */\n      ));\n    } else {\n      let after = buffer.buffer[this.index + 3];\n      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3])) return this.yieldBuf(after);\n    }\n\n    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, -100000000\n    /* None */\n    , this.full)) : false;\n  } /// Move to this node's next sibling, if any.\n\n\n  nextSibling() {\n    return this.sibling(1);\n  } /// Move to this node's previous sibling, if any.\n\n\n  prevSibling() {\n    return this.sibling(-1);\n  }\n\n  atLastNode(dir) {\n    let index,\n        parent,\n        {\n      buffer\n    } = this;\n\n    if (buffer) {\n      if (dir > 0) {\n        if (this.index < buffer.buffer.buffer.length) return false;\n      } else {\n        for (let i = 0; i < this.index; i++) if (buffer.buffer.buffer[i + 3] < this.index) return false;\n      }\n\n      ({\n        index,\n        parent\n      } = buffer);\n    } else {\n      ({\n        index,\n        _parent: parent\n      } = this._tree);\n    }\n\n    for (; parent; ({\n      index,\n      _parent: parent\n    } = parent)) {\n      for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {\n        let child = parent.node.children[i];\n        if (this.full || !child.type.isAnonymous || child instanceof TreeBuffer || hasChild(child)) return false;\n      }\n    }\n\n    return true;\n  }\n\n  move(dir) {\n    if (this.enter(dir, -100000000\n    /* None */\n    )) return true;\n\n    for (;;) {\n      if (this.sibling(dir)) return true;\n      if (this.atLastNode(dir) || !this.parent()) return false;\n    }\n  } /// Move to the next node in a\n  /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))\n  /// traversal, going from a node to its first child or, if the\n  /// current node is empty, its next sibling or the next sibling of\n  /// the first parent node that has one.\n\n\n  next() {\n    return this.move(1);\n  } /// Move to the next node in a last-to-first pre-order traveral. A\n  /// node is followed by ist last child or, if it has none, its\n  /// previous sibling or the previous sibling of the first parent\n  /// node that has one.\n\n\n  prev() {\n    return this.move(-1);\n  } /// Move the cursor to the innermost node that covers `pos`. If\n  /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n  /// it will enter nodes that start at `pos`.\n\n\n  moveTo(pos, side = 0) {\n    // Move up to a node that actually holds the position, if possible\n    while (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos)) if (!this.parent()) break; // Then scan down into child nodes as far as possible\n\n\n    for (;;) {\n      if (side < 0 ? !this.childBefore(pos) : !this.childAfter(pos)) break;\n\n      if (this.from == this.to || (side < 1 ? this.from >= pos : this.from > pos) || (side > -1 ? this.to <= pos : this.to < pos)) {\n        this.parent();\n        break;\n      }\n    }\n\n    return this;\n  } /// Get a [syntax node](#tree.SyntaxNode) at the cursor's current\n  /// position.\n\n\n  get node() {\n    if (!this.buffer) return this._tree;\n    let cache = this.bufferNode,\n        result = null,\n        depth = 0;\n\n    if (cache && cache.context == this.buffer) {\n      scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n        for (let c = cache; c; c = c._parent) if (c.index == index) {\n          if (index == this.index) return c;\n          result = c;\n          depth = d + 1;\n          break scan;\n        }\n\n        index = this.stack[--d];\n      }\n    }\n\n    for (let i = depth; i < this.stack.length; i++) result = new BufferNode(this.buffer, result, this.stack[i]);\n\n    return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n  } /// Get the [tree](#tree.Tree) that represents the current node, if\n  /// any. Will return null when the node is in a [tree\n  /// buffer](#tree.TreeBuffer).\n\n\n  get tree() {\n    return this.buffer ? null : this._tree.node;\n  }\n\n}\n\nfunction hasChild(tree) {\n  return tree.children.some(ch => !ch.type.isAnonymous || ch instanceof TreeBuffer || hasChild(ch));\n}\n\nclass FlatBufferCursor {\n  constructor(buffer, index) {\n    this.buffer = buffer;\n    this.index = index;\n  }\n\n  get id() {\n    return this.buffer[this.index - 4];\n  }\n\n  get start() {\n    return this.buffer[this.index - 3];\n  }\n\n  get end() {\n    return this.buffer[this.index - 2];\n  }\n\n  get size() {\n    return this.buffer[this.index - 1];\n  }\n\n  get pos() {\n    return this.index;\n  }\n\n  next() {\n    this.index -= 4;\n  }\n\n  fork() {\n    return new FlatBufferCursor(this.buffer, this.index);\n  }\n\n}\n\nconst BalanceBranchFactor = 8;\n\nfunction buildTree(data) {\n  var _a;\n\n  let {\n    buffer,\n    nodeSet,\n    topID = 0,\n    maxBufferLength = DefaultBufferLength,\n    reused = [],\n    minRepeatType = nodeSet.types.length\n  } = data;\n  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n  let types = nodeSet.types;\n  let contextHash = 0;\n\n  function takeNode(parentStart, minPos, children, positions, inRepeat) {\n    let {\n      id,\n      start,\n      end,\n      size\n    } = cursor;\n    let startPos = start - parentStart;\n\n    if (size < 0) {\n      if (size == -1) {\n        // Reused node\n        children.push(reused[id]);\n        positions.push(startPos);\n      } else {\n        // Context change\n        contextHash = id;\n      }\n\n      cursor.next();\n      return;\n    }\n\n    let type = types[id],\n        node,\n        buffer;\n\n    if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n      // Small enough for a buffer, and no reused nodes inside\n      let data = new Uint16Array(buffer.size - buffer.skip);\n      let endPos = cursor.pos - buffer.size,\n          index = data.length;\n\n      while (cursor.pos > endPos) index = copyToBuffer(buffer.start, data, index, inRepeat);\n\n      node = new TreeBuffer(data, end - buffer.start, nodeSet, inRepeat < 0 ? NodeType.none : types[inRepeat]);\n      startPos = buffer.start - parentStart;\n    } else {\n      // Make it a node\n      let endPos = cursor.pos - size;\n      cursor.next();\n      let localChildren = [],\n          localPositions = [];\n      let localInRepeat = id >= minRepeatType ? id : -1;\n\n      while (cursor.pos > endPos) {\n        if (cursor.id == localInRepeat) cursor.next();else takeNode(start, endPos, localChildren, localPositions, localInRepeat);\n      }\n\n      localChildren.reverse();\n      localPositions.reverse();\n      if (localInRepeat > -1 && localChildren.length > BalanceBranchFactor) node = balanceRange(type, type, localChildren, localPositions, 0, localChildren.length, 0, maxBufferLength, end - start, contextHash);else node = withHash(new Tree(type, localChildren, localPositions, end - start), contextHash);\n    }\n\n    children.push(node);\n    positions.push(startPos);\n  }\n\n  function findBufferSize(maxSize, inRepeat) {\n    // Scan through the buffer to find previous siblings that fit\n    // together in a TreeBuffer, and don't contain any reused nodes\n    // (which can't be stored in a buffer).\n    // If `inRepeat` is > -1, ignore node boundaries of that type for\n    // nesting, but make sure the end falls either at the start\n    // (`maxSize`) or before such a node.\n    let fork = cursor.fork();\n    let size = 0,\n        start = 0,\n        skip = 0,\n        minStart = fork.end - maxBufferLength;\n    let result = {\n      size: 0,\n      start: 0,\n      skip: 0\n    };\n\n    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n      // Pretend nested repeat nodes of the same type don't exist\n      if (fork.id == inRepeat) {\n        // Except that we store the current state as a valid return\n        // value.\n        result.size = size;\n        result.start = start;\n        result.skip = skip;\n        skip += 4;\n        size += 4;\n        fork.next();\n        continue;\n      }\n\n      let nodeSize = fork.size,\n          startPos = fork.pos - nodeSize;\n      if (nodeSize < 0 || startPos < minPos || fork.start < minStart) break;\n      let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n      let nodeStart = fork.start;\n      fork.next();\n\n      while (fork.pos > startPos) {\n        if (fork.size < 0) break scan;\n        if (fork.id >= minRepeatType) localSkipped += 4;\n        fork.next();\n      }\n\n      start = nodeStart;\n      size += nodeSize;\n      skip += localSkipped;\n    }\n\n    if (inRepeat < 0 || size == maxSize) {\n      result.size = size;\n      result.start = start;\n      result.skip = skip;\n    }\n\n    return result.size > 4 ? result : undefined;\n  }\n\n  function copyToBuffer(bufferStart, buffer, index, inRepeat) {\n    let {\n      id,\n      start,\n      end,\n      size\n    } = cursor;\n    cursor.next();\n    if (id == inRepeat) return index;\n    let startIndex = index;\n\n    if (size > 4) {\n      let endPos = cursor.pos - (size - 4);\n\n      while (cursor.pos > endPos) index = copyToBuffer(bufferStart, buffer, index, inRepeat);\n    }\n\n    if (id < minRepeatType) {\n      // Don't copy repeat nodes into buffers\n      buffer[--index] = startIndex;\n      buffer[--index] = end - bufferStart;\n      buffer[--index] = start - bufferStart;\n      buffer[--index] = id;\n    }\n\n    return index;\n  }\n\n  let children = [],\n      positions = [];\n\n  while (cursor.pos > 0) takeNode(data.start || 0, 0, children, positions, -1);\n\n  let length = (_a = data.length) !== null && _a !== void 0 ? _a : children.length ? positions[0] + children[0].length : 0;\n  return new Tree(types[topID], children.reverse(), positions.reverse(), length);\n}\n\nfunction balanceRange(outerType, innerType, children, positions, from, to, start, maxBufferLength, length, contextHash) {\n  let localChildren = [],\n      localPositions = [];\n\n  if (length <= maxBufferLength) {\n    for (let i = from; i < to; i++) {\n      localChildren.push(children[i]);\n      localPositions.push(positions[i] - start);\n    }\n  } else {\n    let maxChild = Math.max(maxBufferLength, Math.ceil(length * 1.5 / BalanceBranchFactor));\n\n    for (let i = from; i < to;) {\n      let groupFrom = i,\n          groupStart = positions[i];\n      i++;\n\n      for (; i < to; i++) {\n        let nextEnd = positions[i] + children[i].length;\n        if (nextEnd - groupStart > maxChild) break;\n      }\n\n      if (i == groupFrom + 1) {\n        let only = children[groupFrom];\n\n        if (only instanceof Tree && only.type == innerType && only.length > maxChild << 1) {\n          // Too big, collapse\n          for (let j = 0; j < only.children.length; j++) {\n            localChildren.push(only.children[j]);\n            localPositions.push(only.positions[j] + groupStart - start);\n          }\n\n          continue;\n        }\n\n        localChildren.push(only);\n      } else if (i == groupFrom + 1) {\n        localChildren.push(children[groupFrom]);\n      } else {\n        let inner = balanceRange(innerType, innerType, children, positions, groupFrom, i, groupStart, maxBufferLength, positions[i - 1] + children[i - 1].length - groupStart, contextHash);\n        if (innerType != NodeType.none && !containsType(inner.children, innerType)) inner = withHash(new Tree(NodeType.none, inner.children, inner.positions, inner.length), contextHash);\n        localChildren.push(inner);\n      }\n\n      localPositions.push(groupStart - start);\n    }\n  }\n\n  return withHash(new Tree(outerType, localChildren, localPositions, length), contextHash);\n}\n\nfunction containsType(nodes, type) {\n  for (let elt of nodes) if (elt.type == type) return true;\n\n  return false;\n} /// Tree fragments are used during [incremental\n/// parsing](#lezer.ParseOptions.fragments) to track parts of old\n/// trees that can be reused in a new parse. An array of fragments is\n/// used to track regions of an old tree whose nodes might be reused\n/// in new parses. Use the static\n/// [`applyChanges`](#tree.TreeFragment^applyChanges) method to update\n/// fragments for document changes.\n\n\nclass TreeFragment {\n  constructor( /// The start of the unchanged range pointed to by this fragment.\n  /// This refers to an offset in the _updated_ document (as opposed\n  /// to the original tree).\n  from, /// The end of the unchanged range.\n  to, /// The tree that this fragment is based on.\n  tree, /// The offset between the fragment's tree and the document that\n  /// this fragment can be used against. Add this when going from\n  /// document to tree positions, subtract it to go from tree to\n  /// document positions.\n  offset, open) {\n    this.from = from;\n    this.to = to;\n    this.tree = tree;\n    this.offset = offset;\n    this.open = open;\n  }\n\n  get openStart() {\n    return (this.open & 1\n    /* Start */\n    ) > 0;\n  }\n\n  get openEnd() {\n    return (this.open & 2\n    /* End */\n    ) > 0;\n  } /// Apply a set of edits to an array of fragments, removing or\n  /// splitting fragments as necessary to remove edited ranges, and\n  /// adjusting offsets for fragments that moved.\n\n\n  static applyChanges(fragments, changes, minGap = 128) {\n    if (!changes.length) return fragments;\n    let result = [];\n    let fI = 1,\n        nextF = fragments.length ? fragments[0] : null;\n    let cI = 0,\n        pos = 0,\n        off = 0;\n\n    for (;;) {\n      let nextC = cI < changes.length ? changes[cI++] : null;\n      let nextPos = nextC ? nextC.fromA : 1e9;\n      if (nextPos - pos >= minGap) while (nextF && nextF.from < nextPos) {\n        let cut = nextF;\n\n        if (pos >= cut.from || nextPos <= cut.to || off) {\n          let fFrom = Math.max(cut.from, pos) - off,\n              fTo = Math.min(cut.to, nextPos) - off;\n          cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, (cI > 0 ? 1\n          /* Start */\n          : 0) | (nextC ? 2\n          /* End */\n          : 0));\n        }\n\n        if (cut) result.push(cut);\n        if (nextF.to > nextPos) break;\n        nextF = fI < fragments.length ? fragments[fI++] : null;\n      }\n      if (!nextC) break;\n      pos = nextC.toA;\n      off = nextC.toA - nextC.toB;\n    }\n\n    return result;\n  } /// Create a set of fragments from a freshly parsed tree, or update\n  /// an existing set of fragments by replacing the ones that overlap\n  /// with a tree with content from the new tree. When `partial` is\n  /// true, the parse is treated as incomplete, and the token at its\n  /// end is not included in [`safeTo`](#tree.TreeFragment.safeTo).\n\n\n  static addTree(tree, fragments = [], partial = false) {\n    let result = [new TreeFragment(0, tree.length, tree, 0, partial ? 2\n    /* End */\n    : 0)];\n\n    for (let f of fragments) if (f.to > tree.length) result.push(f);\n\n    return result;\n  }\n\n} // Creates an `Input` that is backed by a single, flat string.\n\n\nfunction stringInput(input) {\n  return new StringInput(input);\n}\n\nclass StringInput {\n  constructor(string, length = string.length) {\n    this.string = string;\n    this.length = length;\n  }\n\n  get(pos) {\n    return pos < 0 || pos >= this.length ? -1 : this.string.charCodeAt(pos);\n  }\n\n  lineAfter(pos) {\n    if (pos < 0) return \"\";\n    let end = this.string.indexOf(\"\\n\", pos);\n    return this.string.slice(pos, end < 0 ? this.length : Math.min(end, this.length));\n  }\n\n  read(from, to) {\n    return this.string.slice(from, Math.min(this.length, to));\n  }\n\n  clip(at) {\n    return new StringInput(this.string, at);\n  }\n\n}\n\nexport { DefaultBufferLength, NodeProp, NodeSet, NodeType, Tree, TreeBuffer, TreeCursor, TreeFragment, stringInput };","map":{"version":3,"sources":["../src/tree.ts"],"names":[],"mappings":"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","sourcesContent":["/// The default maximum length of a `TreeBuffer` node.\nexport const DefaultBufferLength = 1024\n\nlet nextPropID = 0\n\nconst CachedNode = new WeakMap<Tree, TreeNode>()\n\n/// Each [node type](#tree.NodeType) can have metadata associated with\n/// it in props. Instances of this class represent prop names.\nexport class NodeProp<T> {\n  /// @internal\n  id: number\n\n  /// A method that deserializes a value of this prop from a string.\n  /// Can be used to allow a prop to be directly written in a grammar\n  /// file. Defaults to raising an error.\n  deserialize: (str: string) => T\n\n  /// Create a new node prop type. You can optionally pass a\n  /// `deserialize` function.\n  constructor({deserialize}: {deserialize?: (str: string) => T} = {}) {\n    this.id = nextPropID++\n    this.deserialize = deserialize || (() => {\n      throw new Error(\"This node type doesn't define a deserialize function\")\n    })\n  }\n\n  /// Create a string-valued node prop whose deserialize function is\n  /// the identity function.\n  static string() { return new NodeProp<string>({deserialize: str => str}) }\n\n  /// Create a number-valued node prop whose deserialize function is\n  /// just `Number`.\n  static number() { return new NodeProp<number>({deserialize: Number}) }\n\n  /// Creates a boolean-valued node prop whose deserialize function\n  /// returns true for any input.\n  static flag() { return new NodeProp<boolean>({deserialize: () => true}) }\n\n  /// Store a value for this prop in the given object. This can be\n  /// useful when building up a prop object to pass to the\n  /// [`NodeType`](#tree.NodeType) constructor. Returns its first\n  /// argument.\n  set(propObj: {[prop: number]: any}, value: T) {\n    propObj[this.id] = value\n    return propObj\n  }\n\n  /// This is meant to be used with\n  /// [`NodeSet.extend`](#tree.NodeSet.extend) or\n  /// [`Parser.withProps`](#lezer.Parser.withProps) to compute prop\n  /// values for each node type in the set. Takes a [match\n  /// object](#tree.NodeType^match) or function that returns undefined\n  /// if the node type doesn't get this prop, and the prop's value if\n  /// it does.\n  add(match: {[selector: string]: T} | ((type: NodeType) => T | undefined)): NodePropSource {\n    if (typeof match != \"function\") match = NodeType.match(match)\n    return (type) => {\n      let result = (match as (type: NodeType) => T | undefined)(type)\n      return result === undefined ? null : [this, result]\n    }\n  }\n\n  /// Prop that is used to describe matching delimiters. For opening\n  /// delimiters, this holds an array of node names (written as a\n  /// space-separated string when declaring this prop in a grammar)\n  /// for the node types of closing delimiters that match it.\n  static closedBy = new NodeProp<readonly string[]>({deserialize: str => str.split(\" \")})\n\n  /// The inverse of [`openedBy`](#tree.NodeProp^closedBy). This is\n  /// attached to closing delimiters, holding an array of node names\n  /// of types of matching opening delimiters.\n  static openedBy = new NodeProp<readonly string[]>({deserialize: str => str.split(\" \")})\n\n  /// Used to assign node types to groups (for example, all node\n  /// types that represent an expression could be tagged with an\n  /// `\"Expression\"` group).\n  static group = new NodeProp<readonly string[]>({deserialize: str => str.split(\" \")})\n}\n\n/// Type returned by [`NodeProp.add`](#tree.NodeProp.add). Describes\n/// the way a prop should be added to each node type in a node set.\nexport type NodePropSource = (type: NodeType) => null | [NodeProp<any>, any]\n\n// Note: this is duplicated in lezer/src/constants.ts\nconst enum NodeFlag {\n  Top = 1,\n  Skipped = 2,\n  Error = 4,\n  Anonymous = 8\n}\n\nconst noProps: {[propID: number]: any} = Object.create(null)\n\n/// Each node in a syntax tree has a node type associated with it.\nexport class NodeType {\n  /// @internal\n  constructor(\n    /// The name of the node type. Not necessarily unique, but if the\n    /// grammar was written properly, different node types with the\n    /// same name within a node set should play the same semantic\n    /// role.\n    readonly name: string,\n    /// @internal\n    readonly props: {readonly [prop: number]: any},\n    /// The id of this node in its set. Corresponds to the term ids\n    /// used in the parser.\n    readonly id: number,\n    /// @internal\n    readonly flags: number = 0) {}\n\n  static define(spec: {\n    /// The ID of the node type. When this type is used in a\n    /// [set](#tree.NodeSet), the ID must correspond to its index in\n    /// the type array.\n    id: number, \n    /// The name of the node type. Leave empty to define an anonymous\n    /// node.\n    name?: string,\n    /// [Node props](#tree.NodeProp) to assign to the type. The value\n    /// given for any given prop should correspond to the prop's type.\n    props?: readonly ([NodeProp<any>, any] | NodePropSource)[],\n    /// Whether is is a [top node](#tree.NodeType.isTop).\n    top?: boolean,\n    /// Whether this node counts as an [error\n    /// node](#tree.NodeType.isError).\n    error?: boolean,\n    /// Whether this node is a [skipped](#tree.NodeType.isSkipped)\n    /// node.\n    skipped?: boolean\n  }) {\n    let props = spec.props && spec.props.length ? Object.create(null) : noProps\n    let flags = (spec.top ? NodeFlag.Top : 0) | (spec.skipped ? NodeFlag.Skipped : 0) |\n      (spec.error ? NodeFlag.Error : 0) | (spec.name == null ? NodeFlag.Anonymous : 0)\n    let type = new NodeType(spec.name || \"\", props, spec.id, flags)\n    if (spec.props) for (let src of spec.props) {\n      if (!Array.isArray(src)) src = src(type)!\n      if (src) src[0].set(props, src[1])\n    }\n    return type\n  }\n\n  /// Retrieves a node prop for this type. Will return `undefined` if\n  /// the prop isn't present on this node.\n  prop<T>(prop: NodeProp<T>): T | undefined { return this.props[prop.id] }\n\n  /// True when this is the top node of a grammar.\n  get isTop() { return (this.flags & NodeFlag.Top) > 0 }\n\n  /// True when this node is produced by a skip rule.\n  get isSkipped() { return (this.flags & NodeFlag.Skipped) > 0 }\n\n  /// Indicates whether this is an error node.\n  get isError() { return (this.flags & NodeFlag.Error) > 0 }\n\n  /// When true, this node type doesn't correspond to a user-declared\n  /// named node, for example because it is used to cache repetition.\n  get isAnonymous() { return (this.flags & NodeFlag.Anonymous) > 0 }\n\n  /// Returns true when this node's name or one of its\n  /// [groups](#tree.NodeProp^group) matches the given string.\n  is(name: string | number) {\n    if (typeof name == 'string') {\n      if (this.name == name) return true\n      let group = this.prop(NodeProp.group)\n      return group ? group.indexOf(name) > -1 : false\n    }\n    return this.id == name\n  }\n\n  /// An empty dummy node type to use when no actual type is available.\n  static none: NodeType = new NodeType(\"\", Object.create(null), 0, NodeFlag.Anonymous)\n\n  /// Create a function from node types to arbitrary values by\n  /// specifying an object whose property names are node or\n  /// [group](#tree.NodeProp^group) names. Often useful with\n  /// [`NodeProp.add`](#tree.NodeProp.add). You can put multiple\n  /// names, separated by spaces, in a single property name to map\n  /// multiple node names to a single value.\n  static match<T>(map: {[selector: string]: T}): (node: NodeType) => T | undefined {\n    let direct = Object.create(null)\n    for (let prop in map)\n      for (let name of prop.split(\" \")) direct[name] = map[prop]\n    return (node: NodeType) => {\n      for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n        let found = direct[i < 0 ? node.name : groups![i]]\n        if (found) return found\n      }\n    }\n  }\n}\n\n/// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a number array. Each parser\n/// [has](#lezer.Parser.nodeSet) a node set, and [tree\n/// buffers](#tree.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536)\n/// node types in it, so that the ids fit into 16-bit typed array\n/// slots.\nexport class NodeSet {\n  /// Create a set with the given types. The `id` property of each\n  /// type should correspond to its position within the array.\n  constructor(\n    /// The node types in this set, by id.\n    readonly types: readonly NodeType[]\n  ) {\n    for (let i = 0; i < types.length; i++) if (types[i].id != i)\n      throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\")\n  }\n\n  /// Create a copy of this set with some node properties added. The\n  /// arguments to this method should be created with\n  /// [`NodeProp.add`](#tree.NodeProp.add).\n  extend(...props: NodePropSource[]): NodeSet {\n    let newTypes: NodeType[] = []\n    for (let type of this.types) {\n      let newProps = null\n      for (let source of props) {\n        let add = source(type)\n        if (add) {\n          if (!newProps) newProps = Object.assign({}, type.props)\n          add[0].set(newProps, add[1])\n        }\n      }\n      newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type)\n    }\n    return new NodeSet(newTypes)\n  }\n}\n\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the `TreeCursor` interface instead, which provides a view on\n/// some part of this data structure, and can be used to move around\n/// to adjacent nodes.\nexport class Tree {\n  /// Construct a new tree. You usually want to go through\n  /// [`Tree.build`](#tree.Tree^build) instead.\n  constructor(\n    readonly type: NodeType,\n    /// The tree's child nodes. Children small enough to fit in a\n    /// `TreeBuffer will be represented as such, other children can be\n    /// further `Tree` instances with their own internal structure.\n    readonly children: readonly (Tree | TreeBuffer)[],\n    /// The positions (offsets relative to the start of this tree) of\n    /// the children.\n    readonly positions: readonly number[],\n    /// The total length of this tree\n    readonly length: number\n  ) {}\n\n  /// @internal\n  toString(): string {\n    let children = this.children.map(c => c.toString()).join()\n    return !this.type.name ? children :\n      (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +\n      (children.length ? \"(\" + children + \")\" : \"\")\n  }\n\n  /// The empty tree\n  static empty = new Tree(NodeType.none, [], [], 0)\n\n  /// Get a [tree cursor](#tree.TreeCursor) rooted at this tree. When\n  /// `pos` is given, the cursor is [moved](#tree.TreeCursor.moveTo)\n  /// to the given position and side.\n  cursor(pos?: number, side: -1 | 0 | 1 = 0): TreeCursor {\n    let scope = (pos != null && CachedNode.get(this)) || (this.topNode as TreeNode)\n    let cursor = new TreeCursor(scope)\n    if (pos != null) {\n      cursor.moveTo(pos, side)\n      CachedNode.set(this, cursor._tree)\n    }\n    return cursor\n  }\n\n  /// Get a [tree cursor](#tree.TreeCursor) that, unlike regular\n  /// cursors, doesn't skip [anonymous](#tree.NodeType.isAnonymous)\n  /// nodes.\n  fullCursor(): TreeCursor {\n    return new TreeCursor(this.topNode as TreeNode, true)\n  }\n\n  /// Get a [syntax node](#tree.SyntaxNode) object for the top of the\n  /// tree.\n  get topNode(): SyntaxNode {\n    return new TreeNode(this, 0, 0, null)\n  }\n\n  /// Get the [syntax node](#tree.SyntaxNode) at the given position.\n  /// If `side` is -1, this will move into nodes that end at the\n  /// position. If 1, it'll move into nodes that start at the\n  /// position. With 0, it'll only enter nodes that cover the position\n  /// from both sides.\n  resolve(pos: number, side: -1 | 0 | 1 = 0) {\n    return this.cursor(pos, side).node\n  }\n\n  /// Iterate over the tree and its children, calling `enter` for any\n  /// node that touches the `from`/`to` region (if given) before\n  /// running over such a node's children, and `leave` (if given) when\n  /// leaving the node. When `enter` returns `false`, the given node\n  /// will not have its children iterated over (or `leave` called).\n  iterate(spec: {\n    enter(type: NodeType, from: number, to: number): false | void,\n    leave?(type: NodeType, from: number, to: number): void,\n    from?: number,\n    to?: number\n  }) {\n    let {enter, leave, from = 0, to = this.length} = spec\n    for (let c = this.cursor();;) {\n      let mustLeave = false\n      if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to) !== false)) {\n        if (c.firstChild()) continue\n        if (!c.type.isAnonymous) mustLeave = true\n      }\n      for (;;) {\n        if (mustLeave && leave) leave(c.type, c.from, c.to)\n        mustLeave = c.type.isAnonymous\n        if (c.nextSibling()) break\n        if (!c.parent()) return\n        mustLeave = true\n      }\n    }\n  }\n\n  /// Balance the direct children of this tree.\n  balance(maxBufferLength = DefaultBufferLength) {\n    return this.children.length <= BalanceBranchFactor ? this\n      : balanceRange(this.type, NodeType.none, this.children, this.positions, 0, this.children.length, 0,\n                     maxBufferLength, this.length, 0)\n  }\n\n  /// Build a tree from a postfix-ordered buffer of node information,\n  /// or a cursor over such a buffer.\n  static build(data: BuildData) { return buildTree(data) }\n}\n\n// For trees that need a context hash attached, we're using this\n// kludge which assigns an extra property directly after\n// initialization (creating a single new object shape).\nfunction withHash(tree: Tree, hash: number) {\n  if (hash) (tree as any).contextHash = hash\n  return tree\n}\n\ntype BuildData = {\n  /// The buffer or buffer cursor to read the node data from.\n  ///\n  /// When this is an array, it should contain four values for every\n  /// node in the tree.\n  ///\n  ///  - The first holds the node's type, as a node ID pointing into\n  ///    the given `NodeSet`.\n  ///  - The second holds the node's start offset.\n  ///  - The third the end offset.\n  ///  - The fourth the amount of space taken up in the array by this\n  ///    node and its children. Since there's four values per node,\n  ///    this is the total number of nodes inside this node (children\n  ///    and transitive children) plus one for the node itself, times\n  ///    four.\n  ///\n  /// Parent nodes should appear _after_ child nodes in the array. As\n  /// an example, a node of type 10 spanning positions 0 to 4, with\n  /// two children, of type 11 and 12, might look like this:\n  ///\n  ///     [11, 0, 1, 4, 12, 2, 4, 4, 10, 0, 4, 12]\n  buffer: BufferCursor | readonly number[],\n  /// The node types to use.\n  nodeSet: NodeSet,\n  /// The id of the top node type, if any.\n  topID?: number,\n  /// The position the tree should start at. Defaults to 0.\n  start?: number,\n  /// The length of the wrapping node. The end offset of the last\n  /// child is used when not provided.\n  length?: number,\n  /// The maximum buffer length to use. Defaults to\n  /// [`DefaultBufferLength`](#tree.DefaultBufferLength).\n  maxBufferLength?: number,\n  /// An optional set of reused nodes that the buffer can refer to.\n  reused?: (Tree | TreeBuffer)[],\n  /// The first node type that indicates repeat constructs in this\n  /// grammar.\n  minRepeatType?: number\n}\n\n/// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it)\nexport class TreeBuffer {\n  /// Create a tree buffer @internal\n  constructor(\n    /// @internal\n    readonly buffer: Uint16Array,\n    // The total length of the group of nodes in the buffer.\n    readonly length: number,\n    /// @internal\n    readonly set: NodeSet,\n    readonly type = NodeType.none\n  ) {}\n\n  /// @internal\n  toString() {\n    let result: string[] = []\n    for (let index = 0; index < this.buffer.length;) {\n      result.push(this.childString(index))\n      index = this.buffer[index + 3]\n    }\n    return result.join(\",\")\n  }\n\n  /// @internal\n  childString(index: number): string {\n    let id = this.buffer[index], endIndex = this.buffer[index + 3]\n    let type = this.set.types[id], result = type.name\n    if (/\\W/.test(result) && !type.isError) result = JSON.stringify(result)\n    index += 4\n    if (endIndex == index) return result\n    let children: string[] = []\n    while (index < endIndex) {\n      children.push(this.childString(index))\n      index = this.buffer[index + 3]\n    }\n    return result + \"(\" + children.join(\",\") + \")\"\n  }\n\n  /// @internal\n  findChild(startIndex: number, endIndex: number, dir: 1 | -1, after: number) {\n    let {buffer} = this, pick = -1\n    for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n      if (after != After.None) {\n        let start = buffer[i + 1], end = buffer[i + 2]\n        if (dir > 0) {\n          if (end > after) pick = i\n          if (end > after) break\n        } else {\n          if (start < after) pick = i\n          if (end >= after) break\n        }\n      } else {\n        pick = i\n        if (dir > 0) break\n      }\n    }\n    return pick\n  }\n}\n\nconst enum After { None = -1e8 }\n\n/// A syntax node provides an immutable pointer at a given node in a\n/// tree. When iterating over large amounts of nodes, you may want to\n/// use a mutable [cursor](#tree.TreeCursor) instead, which is more\n/// efficient.\nexport interface SyntaxNode {\n  /// The type of the node.\n  type: NodeType\n  /// The name of the node (`.type.name`).\n  name: string\n  /// The start position of the node.\n  from: number\n  /// The end position of the node.\n  to: number\n\n  /// The node's parent node, if any.\n  parent: SyntaxNode | null\n  /// The first child, if the node has children.\n  firstChild: SyntaxNode | null\n  /// The node's last child, if available.\n  lastChild: SyntaxNode | null\n  /// The first child that starts at or after `pos`.\n  childAfter(pos: number): SyntaxNode | null\n  /// The last child that ends at or before `pos`.\n  childBefore(pos: number): SyntaxNode | null\n  /// This node's next sibling, if any.\n  nextSibling: SyntaxNode | null\n  /// This node's previous sibling.\n  prevSibling: SyntaxNode | null\n  /// A [tree cursor](#tree.TreeCursor) starting at this node.\n  cursor: TreeCursor\n  /// Find the node around, before (if `side` is -1), or after (`side`\n  /// is 1) the given position. Will look in parent nodes if the\n  /// position is outside this node.\n  resolve(pos: number, side?: -1 | 0 | 1): SyntaxNode\n\n  /// Get the first child of the given type (which may be a [node\n  /// name](#tree.NodeProp.name) or a [group\n  /// name](#tree.NodeProp^group)). If `before` is non-null, only\n  /// return children that occur somewhere after a node with that name\n  /// or group. If `after` is non-null, only return children that\n  /// occur somewhere before a node with that name or group.\n  getChild(type: string | number, before?: string | number | null, after?: string | number | null): SyntaxNode | null\n\n  /// Like [`getChild`](#tree.SyntaxNode.getChild), but return all\n  /// matching children, not just the first.\n  getChildren(type: string | number, before?: string | number | null, after?: string | number | null): SyntaxNode[]\n}\n\nclass TreeNode implements SyntaxNode {\n  constructor(readonly node: Tree,\n              readonly from: number,\n              readonly index: number,\n              readonly _parent: TreeNode | null) {}\n\n  get type() { return this.node.type }\n\n  get name() { return this.node.type.name }\n\n  get to() { return this.from + this.node.length }\n\n  nextChild(i: number, dir: 1 | -1, after: number, full = false): TreeNode | BufferNode | null {\n    for (let parent: TreeNode = this;;) {\n      for (let {children, positions} = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n        let next = children[i], start = positions[i] + parent.from\n        if (after != After.None && (dir < 0 ? start >= after : start + next.length <= after))\n          continue\n        if (next instanceof TreeBuffer) {\n          let index = next.findChild(0, next.buffer.length, dir, after == After.None ? After.None : after - start)\n          if (index > -1) return new BufferNode(new BufferContext(parent, next, i, start), null, index)\n        } else if (full || (!next.type.isAnonymous || hasChild(next))) {\n          let inner = new TreeNode(next, start, i, parent)\n          return full || !inner.type.isAnonymous ? inner : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, after)\n        }\n      }\n      if (full || !parent.type.isAnonymous) return null\n      i = parent.index + dir\n      parent = parent._parent!\n      if (!parent) return null\n    }\n  }\n\n  get firstChild() { return this.nextChild(0, 1, After.None) }\n  get lastChild() { return this.nextChild(this.node.children.length - 1, -1, After.None) }\n\n  childAfter(pos: number) { return this.nextChild(0, 1, pos) }\n  childBefore(pos: number) { return this.nextChild(this.node.children.length - 1, -1, pos) }\n\n  nextSignificantParent() {\n    let val: TreeNode = this\n    while (val.type.isAnonymous && val._parent) val = val._parent\n    return val\n  }\n\n  get parent() {\n    return this._parent ? this._parent.nextSignificantParent() : null\n  }\n\n  get nextSibling() {\n    return this._parent ? this._parent.nextChild(this.index + 1, 1, -1) : null\n  }\n  get prevSibling() {\n    return this._parent ? this._parent.nextChild(this.index - 1, -1, -1) : null\n  }\n\n  get cursor() { return new TreeCursor(this) }\n\n  resolve(pos: number, side: -1 | 0 | 1 = 0) {\n    return this.cursor.moveTo(pos, side).node\n  }\n\n  getChild(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    let r = getChildren(this, type, before, after)\n    return r.length ? r[0] : null\n  }\n\n  getChildren(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    return getChildren(this, type, before, after)\n  }\n\n  /// @internal\n  toString() { return this.node.toString() }\n}\n\nfunction getChildren(node: SyntaxNode, type: string | number, before: string | number | null, after: string | number | null): SyntaxNode[] {\n  let cur = node.cursor, result: SyntaxNode[] = []\n  if (!cur.firstChild()) return result\n  if (before != null) while (!cur.type.is(before)) if (!cur.nextSibling()) return result\n  for (;;) {\n    if (after != null && cur.type.is(after)) return result\n    if (cur.type.is(type)) result.push(cur.node)\n    if (!cur.nextSibling()) return after == null ? result : []\n  }\n}\n\nclass BufferContext {\n  constructor(readonly parent: TreeNode,\n              readonly buffer: TreeBuffer,\n              readonly index: number,\n              readonly start: number) {}\n}\n\nclass BufferNode implements SyntaxNode {\n  type: NodeType\n\n  get name() { return this.type.name }\n\n  get from() { return this.context.start + this.context.buffer.buffer[this.index + 1] }\n\n  get to() { return this.context.start + this.context.buffer.buffer[this.index + 2] }\n\n  constructor(readonly context: BufferContext,\n              readonly _parent: BufferNode | null,\n              readonly index: number) {\n    this.type = context.buffer.set.types[context.buffer.buffer[index]]\n  }\n\n  child(dir: 1 | -1, after: number): BufferNode | null {\n    let {buffer} = this.context\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir,\n                                 after == After.None ? After.None : after - this.context.start)\n    return index < 0 ? null : new BufferNode(this.context, this, index)\n  }\n\n  get firstChild() { return this.child(1, After.None) }\n  get lastChild() { return this.child(-1, After.None) }\n\n  childAfter(pos: number) { return this.child(1, pos) }\n  childBefore(pos: number) { return this.child(-1, pos) }\n\n  get parent() {\n    return this._parent || this.context.parent.nextSignificantParent()\n  }\n\n  externalSibling(dir: 1 | -1) {\n    return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, -1)\n  }\n\n  get nextSibling(): SyntaxNode | null {\n    let {buffer} = this.context\n    let after = buffer.buffer[this.index + 3]\n    if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))\n      return new BufferNode(this.context, this._parent, after)\n    return this.externalSibling(1)\n  }\n\n  get prevSibling(): SyntaxNode | null {\n    let {buffer} = this.context\n    let parentStart = this._parent ? this._parent.index + 4 : 0\n    if (this.index == parentStart) return this.externalSibling(-1)\n    return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, After.None))\n  }\n\n  get cursor() { return new TreeCursor(this) }\n\n  resolve(pos: number, side: -1 | 0 | 1 = 0) {\n    return this.cursor.moveTo(pos, side).node\n  }\n\n  /// @internal\n  toString() { return this.context.buffer.childString(this.index) }\n\n  getChild(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    let r = getChildren(this, type, before, after)\n    return r.length ? r[0] : null\n  }\n\n  getChildren(type: string | number, before: string | number | null = null, after: string | number | null = null) {\n    return getChildren(this, type, before, after)\n  }\n}\n\n/// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\nexport class TreeCursor {\n  /// The node's type.\n  type!: NodeType\n\n  /// Shorthand for `.type.name`.\n  get name() { return this.type.name }\n\n  /// The start source offset of this node.\n  from!: number\n\n  /// The end source offset.\n  to!: number\n\n  /// @internal\n  _tree!: TreeNode\n  private buffer: BufferContext | null = null\n  private stack: number[] = []\n  private index: number = 0\n  private bufferNode: BufferNode | null = null\n\n  /// @internal\n  constructor(node: TreeNode | BufferNode, readonly full = false) {\n    if (node instanceof TreeNode) {\n      this.yieldNode(node)\n    } else {\n      this._tree = node.context.parent\n      this.buffer = node.context\n      for (let n: BufferNode | null = node._parent; n; n = n._parent) this.stack.unshift(n.index)\n      this.bufferNode = node\n      this.yieldBuf(node.index)\n    }\n  }\n\n  private yieldNode(node: TreeNode | null) {\n    if (!node) return false\n    this._tree = node\n    this.type = node.type\n    this.from = node.from\n    this.to = node.to\n    return true\n  }\n\n  private yieldBuf(index: number, type?: NodeType) {\n    this.index = index\n    let {start, buffer} = this.buffer!\n    this.type = type || buffer.set.types[buffer.buffer[index]]\n    this.from = start + buffer.buffer[index + 1]\n    this.to = start + buffer.buffer[index + 2]\n    return true\n  }\n\n  private yield(node: TreeNode | BufferNode | null) {\n    if (!node) return false\n    if (node instanceof TreeNode) {\n      this.buffer = null\n      return this.yieldNode(node)\n    }\n    this.buffer = node.context\n    return this.yieldBuf(node.index, node.type)\n  }\n\n  /// @internal\n  toString() {\n    return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString()\n  }\n\n  /// @internal\n  enter(dir: 1 | -1, after: number) {\n    if (!this.buffer)\n      return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, after, this.full))\n\n    let {buffer} = this.buffer\n    let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir,\n                                 after == After.None ? After.None : after - this.buffer.start)\n    if (index < 0) return false\n    this.stack.push(this.index)\n    return this.yieldBuf(index)\n  }\n\n  /// Move the cursor to this node's first child. When this returns\n  /// false, the node has no child, and the cursor has not been moved.\n  firstChild() { return this.enter(1, After.None) }\n\n  /// Move the cursor to this node's last child.\n  lastChild() { return this.enter(-1, After.None) }\n\n  /// Move the cursor to the first child that starts at or after `pos`.\n  childAfter(pos: number) { return this.enter(1, pos) }\n\n  /// Move to the last child that ends at or before `pos`.\n  childBefore(pos: number) { return this.enter(-1, pos) }\n\n  /// Move the node's parent node, if this isn't the top node.\n  parent() {\n    if (!this.buffer) return this.yieldNode(this.full ? this._tree._parent : this._tree.parent)\n    if (this.stack.length) return this.yieldBuf(this.stack.pop()!)\n    let parent = this.full ? this.buffer.parent : this.buffer.parent.nextSignificantParent()\n    this.buffer = null\n    return this.yieldNode(parent)\n  }\n\n  /// @internal\n  sibling(dir: 1 | -1) {\n    if (!this.buffer)\n      return !this._tree._parent ? false\n        : this.yield(this._tree._parent.nextChild(this._tree.index + dir, dir, After.None, this.full))\n\n    let {buffer} = this.buffer, d = this.stack.length - 1\n    if (dir < 0) {\n      let parentStart = d < 0 ? 0 : this.stack[d] + 4\n      if (this.index != parentStart)\n        return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, After.None))\n    } else {\n      let after = buffer.buffer[this.index + 3]\n      if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))\n        return this.yieldBuf(after)\n    }\n    return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, After.None, this.full)) : false\n  }\n\n  /// Move to this node's next sibling, if any.\n  nextSibling() { return this.sibling(1) }\n\n  /// Move to this node's previous sibling, if any.\n  prevSibling() { return this.sibling(-1) }\n\n  private atLastNode(dir: 1 | -1) {\n    let index, parent: TreeNode | null, {buffer} = this\n    if (buffer) {\n      if (dir > 0) {\n        if (this.index < buffer.buffer.buffer.length) return false\n      } else {\n        for (let i = 0; i < this.index; i++) if (buffer.buffer.buffer[i + 3] < this.index) return false\n      }\n      ;({index, parent} = buffer)\n    } else {\n      ({index, _parent: parent} = this._tree)\n    }\n    for (; parent; {index, _parent: parent} = parent) {\n      for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {\n        let child = parent.node.children[i]\n        if (this.full || !child.type.isAnonymous || child instanceof TreeBuffer || hasChild(child)) return false\n      }\n    }\n    return true\n  }\n\n  private move(dir: 1 | -1) {\n    if (this.enter(dir, After.None)) return true\n    for (;;) {\n      if (this.sibling(dir)) return true\n      if (this.atLastNode(dir) || !this.parent()) return false\n    }\n  }\n\n  /// Move to the next node in a\n  /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))\n  /// traversal, going from a node to its first child or, if the\n  /// current node is empty, its next sibling or the next sibling of\n  /// the first parent node that has one.\n  next() { return this.move(1) }\n\n  /// Move to the next node in a last-to-first pre-order traveral. A\n  /// node is followed by ist last child or, if it has none, its\n  /// previous sibling or the previous sibling of the first parent\n  /// node that has one.\n  prev() { return this.move(-1) }\n\n  /// Move the cursor to the innermost node that covers `pos`. If\n  /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n  /// it will enter nodes that start at `pos`.\n  moveTo(pos: number, side: -1 | 0 | 1 = 0) {\n    // Move up to a node that actually holds the position, if possible\n    while (this.from == this.to ||\n           (side < 1 ? this.from >= pos : this.from > pos) ||\n           (side > -1 ? this.to <= pos : this.to < pos))\n      if (!this.parent()) break\n\n    // Then scan down into child nodes as far as possible\n    for (;;) {\n      if (side < 0 ? !this.childBefore(pos) : !this.childAfter(pos)) break\n      if (this.from == this.to ||\n          (side < 1 ? this.from >= pos : this.from > pos) ||\n          (side > -1 ? this.to <= pos : this.to < pos)) {\n        this.parent()\n        break\n      }\n    }\n    return this\n  }\n\n  /// Get a [syntax node](#tree.SyntaxNode) at the cursor's current\n  /// position.\n  get node(): SyntaxNode {\n    if (!this.buffer) return this._tree\n    \n    let cache = this.bufferNode, result: BufferNode | null = null, depth = 0\n    if (cache && cache.context == this.buffer) {\n      scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n        for (let c: BufferNode | null = cache; c; c = c._parent) if (c.index == index) {\n          if (index == this.index) return c\n          result = c\n          depth = d + 1\n          break scan\n        }\n        index = this.stack[--d]\n      }\n    }\n    for (let i = depth; i < this.stack.length; i++) result = new BufferNode(this.buffer, result, this.stack[i])\n    return this.bufferNode = new BufferNode(this.buffer, result, this.index)\n  }\n\n  /// Get the [tree](#tree.Tree) that represents the current node, if\n  /// any. Will return null when the node is in a [tree\n  /// buffer](#tree.TreeBuffer).\n  get tree(): Tree | null {\n    return this.buffer ? null : this._tree.node\n  }\n}\n\nfunction hasChild(tree: Tree): boolean {\n  return tree.children.some(ch => !ch.type.isAnonymous || ch instanceof TreeBuffer || hasChild(ch))\n}\n\n/// This is used by `Tree.build` as an abstraction for iterating over\n/// a tree buffer. A cursor initially points at the very last element\n/// in the buffer. Every time `next()` is called it moves on to the\n/// previous one.\nexport interface BufferCursor {\n  /// The current buffer position (four times the number of nodes\n  /// remaining).\n  pos: number\n  /// The node ID of the next node in the buffer.\n  id: number\n  /// The start position of the next node in the buffer.\n  start: number\n  /// The end position of the next node.\n  end: number\n  /// The size of the next node (the number of nodes inside, counting\n  /// the node itself, times 4).\n  size: number\n  /// Moves `this.pos` down by 4.\n  next(): void\n  /// Create a copy of this cursor.\n  fork(): BufferCursor\n}\n\nclass FlatBufferCursor implements BufferCursor {\n  constructor(readonly buffer: readonly number[], public index: number) {}\n\n  get id() { return this.buffer[this.index - 4] }\n  get start() { return this.buffer[this.index - 3] }\n  get end() { return this.buffer[this.index - 2] }\n  get size() { return this.buffer[this.index - 1] }\n\n  get pos() { return this.index }\n\n  next() { this.index -= 4 }\n\n  fork() { return new FlatBufferCursor(this.buffer, this.index) }\n}\n\nconst BalanceBranchFactor = 8\n\nfunction buildTree(data: BuildData) {\n  let {buffer, nodeSet, topID = 0,\n       maxBufferLength = DefaultBufferLength,\n       reused = [],\n       minRepeatType = nodeSet.types.length} = data as BuildData\n  let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer as BufferCursor\n  let types = nodeSet.types\n\n  let contextHash = 0\n\n  function takeNode(parentStart: number, minPos: number,\n                    children: (Tree | TreeBuffer)[], positions: number[],\n                    inRepeat: number) {\n    let {id, start, end, size} = cursor\n    let startPos = start - parentStart\n    if (size < 0) {\n      if (size == -1) { // Reused node\n        children.push(reused[id])\n        positions.push(startPos)\n      } else { // Context change\n        contextHash = id\n      }\n      cursor.next()\n      return\n    }\n\n    let type = types[id], node, buffer: {size: number, start: number, skip: number} | undefined\n    if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n      // Small enough for a buffer, and no reused nodes inside\n      let data = new Uint16Array(buffer.size - buffer.skip)\n      let endPos = cursor.pos - buffer.size, index = data.length\n      while (cursor.pos > endPos)\n        index = copyToBuffer(buffer.start, data, index, inRepeat)\n      node = new TreeBuffer(data, end - buffer.start, nodeSet, inRepeat < 0 ? NodeType.none : types[inRepeat])\n      startPos = buffer.start - parentStart\n    } else { // Make it a node\n      let endPos = cursor.pos - size\n      cursor.next()\n      let localChildren: (Tree | TreeBuffer)[] = [], localPositions: number[] = []\n      let localInRepeat = id >= minRepeatType ? id : -1\n      while (cursor.pos > endPos) {\n        if (cursor.id == localInRepeat) cursor.next()\n        else takeNode(start, endPos, localChildren, localPositions, localInRepeat)\n      }\n      localChildren.reverse(); localPositions.reverse()\n\n      if (localInRepeat > -1 && localChildren.length > BalanceBranchFactor)\n        node = balanceRange(type, type, localChildren, localPositions, 0, localChildren.length, 0, maxBufferLength,\n                            end - start, contextHash)\n      else\n        node = withHash(new Tree(type, localChildren, localPositions, end - start), contextHash)\n    }\n\n    children.push(node)\n    positions.push(startPos)\n  }\n\n  function findBufferSize(maxSize: number, inRepeat: number) {\n    // Scan through the buffer to find previous siblings that fit\n    // together in a TreeBuffer, and don't contain any reused nodes\n    // (which can't be stored in a buffer).\n    // If `inRepeat` is > -1, ignore node boundaries of that type for\n    // nesting, but make sure the end falls either at the start\n    // (`maxSize`) or before such a node.\n    let fork = cursor.fork()\n    let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength\n    let result = {size: 0, start: 0, skip: 0}\n    scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n      // Pretend nested repeat nodes of the same type don't exist\n      if (fork.id == inRepeat) {\n        // Except that we store the current state as a valid return\n        // value.\n        result.size = size; result.start = start; result.skip = skip\n        skip += 4; size += 4\n        fork.next()\n        continue\n      }\n      let nodeSize = fork.size, startPos = fork.pos - nodeSize\n      if (nodeSize < 0 || startPos < minPos || fork.start < minStart) break\n      let localSkipped = fork.id >= minRepeatType ? 4 : 0\n      let nodeStart = fork.start\n      fork.next()\n      while (fork.pos > startPos) {\n        if (fork.size < 0) break scan\n        if (fork.id >= minRepeatType) localSkipped += 4\n        fork.next()\n      }\n      start = nodeStart\n      size += nodeSize\n      skip += localSkipped\n    }\n    if (inRepeat < 0 || size == maxSize) {\n      result.size = size; result.start = start; result.skip = skip\n    }\n    return result.size > 4 ? result : undefined\n  }\n\n  function copyToBuffer(bufferStart: number, buffer: Uint16Array, index: number, inRepeat: number): number {\n    let {id, start, end, size} = cursor\n    cursor.next()\n    if (id == inRepeat) return index\n    let startIndex = index\n    if (size > 4) {\n      let endPos = cursor.pos - (size - 4)\n      while (cursor.pos > endPos)\n        index = copyToBuffer(bufferStart, buffer, index, inRepeat)\n    }\n    if (id < minRepeatType) { // Don't copy repeat nodes into buffers\n      buffer[--index] = startIndex\n      buffer[--index] = end - bufferStart\n      buffer[--index] = start - bufferStart\n      buffer[--index] = id\n    }\n    return index\n  }\n\n  let children: (Tree | TreeBuffer)[] = [], positions: number[] = []\n  while (cursor.pos > 0) takeNode(data.start || 0, 0, children, positions, -1)\n  let length = data.length ?? (children.length ? positions[0] + children[0].length : 0)\n  return new Tree(types[topID], children.reverse(), positions.reverse(), length)\n}\n\nfunction balanceRange(outerType: NodeType, innerType: NodeType,\n                      children: readonly (Tree | TreeBuffer)[], positions: readonly number[],\n                      from: number, to: number,\n                      start: number, maxBufferLength: number,\n                      length: number, contextHash: number): Tree {\n  let localChildren: (Tree | TreeBuffer)[] = [], localPositions: number[] = []\n  if (length <= maxBufferLength) {\n    for (let i = from; i < to; i++) {\n      localChildren.push(children[i])\n      localPositions.push(positions[i] - start)\n    }\n  } else {\n    let maxChild = Math.max(maxBufferLength, Math.ceil(length * 1.5 / BalanceBranchFactor))\n    for (let i = from; i < to;) {\n      let groupFrom = i, groupStart = positions[i]\n      i++\n      for (; i < to; i++) {\n        let nextEnd = positions[i] + children[i].length\n        if (nextEnd - groupStart > maxChild) break\n      }\n      if (i == groupFrom + 1) {\n        let only = children[groupFrom]\n        if (only instanceof Tree && only.type == innerType && only.length > maxChild << 1) { // Too big, collapse\n          for (let j = 0; j < only.children.length; j++) {\n            localChildren.push(only.children[j])\n            localPositions.push(only.positions[j] + groupStart - start)\n          }\n          continue\n        }\n        localChildren.push(only)\n      } else if (i == groupFrom + 1) {\n        localChildren.push(children[groupFrom])\n      } else {\n        let inner = balanceRange(innerType, innerType, children, positions, groupFrom, i, groupStart,\n                                 maxBufferLength, positions[i - 1] + children[i - 1].length - groupStart, contextHash)\n        if (innerType != NodeType.none && !containsType(inner.children, innerType))\n          inner = withHash(new Tree(NodeType.none, inner.children, inner.positions, inner.length), contextHash)\n        localChildren.push(inner)\n      }\n      localPositions.push(groupStart - start)\n    }\n  }\n  return withHash(new Tree(outerType, localChildren, localPositions, length), contextHash)\n}\n\nfunction containsType(nodes: readonly (Tree | TreeBuffer)[], type: NodeType) {\n  for (let elt of nodes) if (elt.type == type) return true\n  return false\n}\n\n/// The [`TreeFragment.applyChanges`](#tree.TreeFragment^applyChanges)\n/// method expects changed ranges in this format.\nexport interface ChangedRange {\n  /// The start of the change in the start document\n  fromA: number\n  /// The end of the change in the start document\n  toA: number\n  /// The start of the replacement in the new document\n  fromB: number\n  /// The end of the replacement in the new document\n  toB: number\n}\n\nconst enum Open { Start = 1, End = 2 }\n\n/// Tree fragments are used during [incremental\n/// parsing](#lezer.ParseOptions.fragments) to track parts of old\n/// trees that can be reused in a new parse. An array of fragments is\n/// used to track regions of an old tree whose nodes might be reused\n/// in new parses. Use the static\n/// [`applyChanges`](#tree.TreeFragment^applyChanges) method to update\n/// fragments for document changes.\nexport class TreeFragment {\n  constructor(\n    /// The start of the unchanged range pointed to by this fragment.\n    /// This refers to an offset in the _updated_ document (as opposed\n    /// to the original tree).\n    readonly from: number,\n    /// The end of the unchanged range.\n    readonly to: number,\n    /// The tree that this fragment is based on.\n    readonly tree: Tree,\n    /// The offset between the fragment's tree and the document that\n    /// this fragment can be used against. Add this when going from\n    /// document to tree positions, subtract it to go from tree to\n    /// document positions.\n    readonly offset: number,\n    private open: number\n  ) {}\n\n  get openStart() { return (this.open & Open.Start) > 0 }\n\n  get openEnd() { return (this.open & Open.End) > 0 }\n\n  /// Apply a set of edits to an array of fragments, removing or\n  /// splitting fragments as necessary to remove edited ranges, and\n  /// adjusting offsets for fragments that moved.\n  static applyChanges(fragments: readonly TreeFragment[], changes: readonly ChangedRange[], minGap = 128) {\n    if (!changes.length) return fragments\n    let result: TreeFragment[] = []\n    let fI = 1, nextF = fragments.length ? fragments[0] : null\n    let cI = 0, pos = 0, off = 0\n    for (;;) {\n      let nextC = cI < changes.length ? changes[cI++] : null\n      let nextPos = nextC ? nextC.fromA : 1e9\n      if (nextPos - pos >= minGap) while (nextF && nextF.from < nextPos) {\n        let cut: TreeFragment | null = nextF\n        if (pos >= cut.from || nextPos <= cut.to || off) {\n          let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off\n          cut = fFrom >= fTo ? null :\n            new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off,\n                             (cI > 0 ? Open.Start : 0) | (nextC ? Open.End : 0))\n        }\n        if (cut) result.push(cut)\n        if (nextF.to > nextPos) break\n        nextF = fI < fragments.length ? fragments[fI++] : null\n      }\n      if (!nextC) break\n      pos = nextC.toA\n      off = nextC.toA - nextC.toB\n    }\n    return result\n  }\n\n  /// Create a set of fragments from a freshly parsed tree, or update\n  /// an existing set of fragments by replacing the ones that overlap\n  /// with a tree with content from the new tree. When `partial` is\n  /// true, the parse is treated as incomplete, and the token at its\n  /// end is not included in [`safeTo`](#tree.TreeFragment.safeTo).\n  static addTree(tree: Tree, fragments: readonly TreeFragment[] = [], partial = false) {\n    let result = [new TreeFragment(0, tree.length, tree, 0, partial ? Open.End : 0)]\n    for (let f of fragments) if (f.to > tree.length) result.push(f)\n    return result\n  }\n}\n\n/// Interface used to represent an in-progress parse, which can be\n/// moved forward piece-by-piece.\nexport interface PartialParse {\n  /// Advance the parse state by some amount.\n  advance(): Tree | null\n  /// The current parse position.\n  pos: number\n  /// Get the currently parsed content as a tree, even though the\n  /// parse hasn't finished yet.\n  forceFinish(): Tree\n}\n\n/// A parse context is an object providing additional information to the\n/// parser. It is passed through to nested parsers.\nexport interface ParseContext {\n  /// A set of fragments from a previous parse to be used for incremental\n  /// parsing. These should be aligned with the current document\n  /// (through a call to\n  /// [`TreeFragment.applyChanges`](#tree.TreeFragment^applyChanges))\n  /// if any changes were made since they were produced. The parser\n  /// will try to reuse nodes from the fragments in the new parse,\n  /// greatly speeding up the parse when it can do so for most of the\n  /// document.\n  fragments?: readonly TreeFragment[]\n}\n\n/// This is the interface the parser uses to access the document. It\n/// exposes a sequence of UTF16 code units. Most (but not _all_)\n/// access, especially through `get`, will be sequential, so\n/// implementations can optimize for that.\nexport interface Input {\n  /// The end of the stream.\n  length: number\n  /// Get the code unit at the given position. Will return -1 when\n  /// asked for a point below 0 or beyond the end of the stream.\n  get(pos: number): number\n  /// Returns the string between `pos` and the next newline character\n  /// or the end of the document. Not used by the built-in tokenizers,\n  /// but can be useful in custom tokenizers or completely custom\n  /// parsers.\n  lineAfter(pos: number): string\n  /// Read part of the stream as a string\n  read(from: number, to: number): string\n  /// Return a new `Input` over the same data, but with a lower\n  /// `length`. Used, for example, when nesting grammars to give the\n  /// inner grammar a narrower view of the input.\n  clip(at: number): Input\n}\n\n// Creates an `Input` that is backed by a single, flat string.\nexport function stringInput(input: string): Input { return new StringInput(input) }\n\nclass StringInput implements Input {\n  constructor(readonly string: string, readonly length = string.length) {}\n\n  get(pos: number) {\n    return pos < 0 || pos >= this.length ? -1 : this.string.charCodeAt(pos)\n  }\n\n  lineAfter(pos: number) {\n    if (pos < 0) return \"\"\n    let end = this.string.indexOf(\"\\n\", pos)\n    return this.string.slice(pos, end < 0 ? this.length : Math.min(end, this.length))\n  }\n  \n  read(from: number, to: number): string { return this.string.slice(from, Math.min(this.length, to)) }\n\n  clip(at: number) { return new StringInput(this.string, at) }\n}\n"]},"metadata":{},"sourceType":"module"}